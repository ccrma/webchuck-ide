{
    "examples": [
        {
            "help.ck": {
                "code": "// name: help.ck\n//       (available in chuck-1.4.1.0 and later)\n// desc: example showing .help(), which can be invoked on\n//       any object or class; .help() dynamically generates\n//       information regarding the underlying type of an object\n//       or a class and outputs this information to the console.\n//       the information includes the inheritance chain of the\n//       type in question, its functions as well as functions\n//       inherited from its parent (and its parent's parent, and\n//       so on).\n//\n// .help() is designed to be a run-time teaching/learning tool\n//       and a quick referencewhile programming. It's fun, sort of!\n\n// an object/ugen instance\nSinOsc osc;\n// call help() on it to learn about its underlying information\nosc.help();\n\n// help() can be called directly on classes without instances\nMachine.help();\n\n// 2-d int array\nint a[10][10];\n// calling apropros on a 2d-array\na.help();\n// calling apropros on an array\na[0].help();\n\n// a user-created class\npublic class Foo\n{\n    fun void bar()\n    { <<< \"hi\" >>>; }\n}\n// calling help() on the class\nFoo.help();\n",
                "data": []
            }
        },
        {
            "status.ck": {
                "code": "// useful little shred for on-the-fly programming...\n\n// infinite time loop\nwhile( true )\n{\n    // print out machine status (same as chuck ^)\n    Machine.status();\n    // every so often\n    3::second => now;\n}\n",
                "data": []
            }
        },
        {
            "hanoi++.ck": {
                "code": "// towers of annoy\n// demonstrates: recursion, arrays, stereo, sndbuf,\n//               questionable sonification\n\n// number of disks\n10 => int disks;\n// min duration for each move\n200::ms => dur wait => dur the_wait;\n// step number\n0 => int STEPS;\n\n// gain to pan to dac\nGain g => Pan2 pan;\n// stereo from here\npan.left => NRev r1 => dac.left;\npan.right => NRev r2 => dac.right;\n// set gain\n.5 => g.gain;\n// set mix\n.1 => r1.mix => r2.mix;\n\n// the pegs (0 not used - for easy indexing)\nSndBuf pegs[4];\n\n// load files\nme.dir() + \"snare-chili.wav\" => pegs[1].read;\nme.dir() + \"kick.wav\" => pegs[2].read;\nme.dir() + \"snare-hop.wav\" => pegs[3].read;\n\n// connect to gain\nfor( 1 => int i; i < pegs.size(); i++ )\n    pegs[i] => g;\n\n// the hanoi\nfun void hanoi( int num, int src, int dest, int other )\n{\n    // move all except the biggest\n    if( num > 1 ) hanoi( num - 1, src, other, dest );\n\n    // increment steps\n    STEPS++;\n    // move the biggest\n    <<< \"step\", STEPS, \" | move disk from peg\", src, \" -> \", \"peg\", dest >>>;\n    // sonify\n    0 => pegs[dest].pos;\n    // gain\n    Math.random2f( .2, .9 ) => pegs[dest].gain;\n    // pan\n    .8 * (dest - 2) => pan.pan;\n    // advance time\n    the_wait => now;\n\n    // move onto the biggest\n    if( num > 1 ) hanoi( num - 1, other, dest, src );\n}\n\n// start it\nhanoi( disks, 1, 3, 2 );\n\n<<<\"done!\">>>;\n\n// let time pass for reverb to go...\n2::second => now;\n\n\n",
                "data": [
                    "https://raw.githubusercontent.com/ccrma/chuck/main/examples/data/kick.wav",
                    "https://raw.githubusercontent.com/ccrma/chuck/main/examples/data/snare-hop.wav",
                    "https://raw.githubusercontent.com/ccrma/chuck/main/examples/data/snare-chili.wav"
                ]
            }
        },
        {
            "hanoi2.ck": {
                "code": "// towers of annoy\n// demonstrates: recursion, arrays, sndbuf, stereo, questionable sonification\n\n// number of disks\n11 => int disks;\n// duration for each move\n200::ms => dur wait;\n// step number\n0 => int STEPS;\n\n// gain to pan to dac\nGain g => Pan2 pan => JCRev r => dac;\n// set gain\n.5 => g.gain;\n// set mix\n.15 => r.mix;\n\n// the pegs (0 not used - for easy indexing)\nSndBuf pegs[4];\n\n// load files\n\"hihat-open.wav\" => pegs[1].read;\n\"hihat.wav\" => pegs[2].read;\n\"snare-chili.wav\" => pegs[3].read;\n\n// connect to gain\nfor( 1 => int i; i < pegs.size(); i++ )\n    pegs[i] => g;\n\n// the hanoi\nfun void hanoi( int num, int src, int dest, int other )\n{\n    // move all except the biggest\n    if( num > 1 ) hanoi( num - 1, src, other, dest );\n\n    // increment steps\n    STEPS++;\n    // move the biggest\n    <<< \"step\", STEPS, \" | move disk from peg\", src, \" -> \", \"peg\", dest >>>;\n    // sonify\n    0 => pegs[dest].pos;\n    // pan\n    dest - 2 => pan.pan;\n    // advance time\n    wait => now;\n\n    // move onto the biggest\n    if( num > 1 ) hanoi( num - 1, other, dest, src );\n}\n\nhanoi( disks, 1, 3, 2 );\n\n<<< \"done.\", \"\" >>>;\n\n// let time pass for reverb to go...\n2::second => now;\n",
                "data": [
                    "https://raw.githubusercontent.com/ccrma/chuck/main/examples/data/hihat-open.wav",
                    "https://raw.githubusercontent.com/ccrma/chuck/main/examples/data/snare-chili.wav",
                    "https://raw.githubusercontent.com/ccrma/chuck/main/examples/data/hihat.wav"
                ]
            }
        },
        {
            "hanoi.ck": {
                "code": "// towers of annoy : non-sonified version\n// demonstrates: recursion\n\n// number of disks\n10 => int disks;\n// step number\n0 => int STEPS;\n\n// moves\n0 => int moves;\n\n// the hanoi\nfun void hanoi( int num, int src, int dest, int other )\n{\n    // stop here\n    if( num <= 0 ) return;\n\n    // increment steps\n    STEPS++;\n\n    // move all except the biggest\n    hanoi( num - 1, src, other, dest );\n    // move the biggest\n    <<< \"step\", STEPS, \" | move disk from peg\", src, \" -> \", \"peg\", dest >>>;\n    // move onto the biggest\n    hanoi( num - 1, other, dest, src );\n}\n\n// start it\nhanoi( disks, 1, 3, 2 );\n\n<<< \"done.\", \"\" >>>;\n",
                "data": []
            }
        },
        {
            "hanoi3.ck": {
                "code": "// towers of annoy\n// demonstrates: recursion, arrays, sndbuf, stereo, questionable sonification\n\n// number of disks\n10 => int disks;\n// min duration for each move\n100::ms => dur wait;\n// step number\n0 => int STEPS;\n\n// gain to pan to dac\nGain g => Pan2 pan;\n// stereo from here\npan.left => NRev r1 => dac.left;\npan.right => NRev r2 => dac.right;\n// set gain\n1 => g.gain;\n// set mix\n.1 => r1.mix => r2.mix;\n\n// the pegs (0 not used - for easy indexing)\nSndBuf pegs[4];\n\n// load files\n\"special:ahh\" => pegs[1].read;\n\"special:eee\" => pegs[2].read;\n\"special:ooo\" => pegs[3].read;\n\n// connect to gain\nfor( 1 => int i; i < pegs.size(); i++ )\n    pegs[i] => g;\n\n// the hanoi\nfun void hanoi( int num, int src, int dest, int other )\n{\n    // move all except the biggest\n    if( num > 1 ) hanoi( num - 1, src, other, dest );\n\n    // increment steps\n    STEPS++;\n    // move the biggest\n    <<< \"step\", STEPS, \" | move disk from peg\", src, \" -> \", \"peg\", dest >>>;\n    // sonify\n    0 => pegs[dest].pos;\n    // gain\n    Math.random2f( .2, .9 ) => pegs[dest].gain;\n    // pan\n    .8 * (dest - 2) => pan.pan;\n    // advance time\n    wait => now;\n\n    // move onto the biggest\n    if( num > 1 ) hanoi( num - 1, other, dest, src );\n}\n\n// start it\nhanoi( disks, 1, 3, 2 );\n\n<<<\"done!\">>>;\n\n// let time pass for reverb to go...\n2::second => now;\n",
                "data": []
            }
        },
        "extend",
        "stereo",
        "analysis",
        "array",
        "ctrl",
        "multi",
        "io",
        "basic",
        "deep",
        "stk",
        "math",
        "time",
        "special",
        "type",
        "ai",
        "machine",
        "class",
        "shred",
        "string",
        "filter",
        "spatial",
        "effects",
        "vector",
        "event",
        "oper",
        "func"
    ],
    "extend": [
        {
            "chugraph.ck": {
                "code": "// name: chugraph.ck\n// desc: pronounced \"chu-graph\" -- rhymes with \"chew-graph\"\n//       create new UGens by compositing existing UGens!\n// note: (chuck-1.4.1.0 and up) \"Chubgraph\" deprecated; use \"Chugraph\"\n//       BTW deprecated Chubgraph rhymes with \"subgraph\"\n\n// make a plucked string\nclass PluckedString extends Chugraph // Chubgraph\n{\n    // karplus + strong plucked string filter\n    // Ge Wang (gewang@cs.princeton.edu)\n    \n    Noise imp => OneZero lowpass => outlet;\n    lowpass => DelayA delay => lowpass;\n    \n    .99999 => float R;\n    1/220 => float L;\n    -1 => lowpass.zero;\n    220 => freq;\n    0 => imp.gain;\n    \n    fun float freq( float f )\n    {\n        // delay length\n        1/f => L;\n        // set delay length\n        L::second => delay.delay;\n        // set gain\n        Math.pow( R, L ) => delay.gain;\n        // return frequency through\n        return f;\n    }\n    \n    fun void pluck( dur ringDur )\n    {\n        // turn on the noise...\n        1 => imp.gain;\n        // for one delay length\n        L::second => now;\n        // turn off the noise\n        0 => imp.gain;\n        // let it ring\n        ringDur => now;\n    }\n}\n\n// instantiate three chugraphs\nPluckedString ps[3];\n// connect as any other UGen\nfor( int i; i < ps.size(); i++ ) ps[i] => dac;\n// ring duration\n2::second => dur ringDur;\n\n// infinite time loop\nwhile( true )\n{\n    // iterate over plucked strings\n    for( int i; i < ps.size(); i++ )\n    {\n        // randomize pitch\n        Math.random2( 36, 72 ) => Std.mtof => ps[i].freq;\n        // spork the pluck\n        spork ~ ps[i].pluck( 2*ringDur );\n        // wait a bit\n        0.25::second => now;\n    }\n    \n    // let ring...\n    ringDur => now;\n}\n",
                "data": []
            }
        },
        {
            "chugen.ck": {
                "code": "// name: chugen.ck\n// name: \"chu-gen\" -- rhymes with \"UGen\"\n//      create new UGens by performing audio-rate processing in ChucK\n\n// a chugen!\nclass Fuzz extends Chugen\n{\n    // p\n    1.0/2.0 => float p;\n    // intensity\n    2 => intensity;\n\n    // single-sample tick function (ChuGen specialty)    \n    fun float tick( float in )\n    {\n        Math.sgn(in) => float sgn;\n        return Math.pow(Math.fabs(in), p) * sgn;\n    }\n    \n    // set intensity\n    fun void intensity( float i )\n    {\n        if(i > 1) 1.0/i => p;\n    }\n}\n\n// patch it in!\nadc => Fuzz f => dac;\n// set intensity\n2.5 => f.intensity;\n// advance time\nwhile(true) 1::second => now;\n",
                "data": []
            }
        }
    ],
    "stereo": [
        {
            "curly2.ck": {
                "code": "// impulse to filter to dac\nImpulse i => BiQuad f => Pan2 p => dac;\n// set the filter's pole radius\n.99 => f.prad; \n// set equal gain zeros\n1 => f.eqzs;\n// set filter gain\n.5 => f.gain;\n  \n// infinite time-loop   \nwhile( true )\n{\n    // set the current sample/impulse\n    1.0 => i.next;\n    // set filter resonant frequency\n    Math.random2f( 50, 5000 ) => f.pfreq;\n    // pan\n    Math.random2f( -1, 1 ) => p.pan;\n    // advance time\n    99::ms => now;\n}\n\n",
                "data": []
            }
        },
        {
            "array.ck": {
                "code": "// dope storm\n// using arrays as UGen busses\n// author: Spencer Salazar - spencer@ccrma.stanford.edu\n// date: May 2013\n\n// patch mixing arrays of mono and stereo UGens\nSndBuf buf[32] => Pan2 pan[32] => NRev reverb[2] => dac;\n\n// set reverb mix\n0.1 => reverb[0].mix;\n0.11 => reverb[1].mix;\n\n// load sound\nfor( int i; i < buf.size(); i++ )\n{\n    // load dope sound\n    \"special:dope\" => buf[i].read;\n    // set to end\n    buf[i].samples() => buf[i].pos;\n}\n\n// index\n0 => int i;\n\nwhile(true)\n{\n    // randomize pan\n    Math.random2f(-0.5,0.5) => pan[i%pan.size()].pan;\n    // Math.pow(2, Math.random2f(-1.5, 1.5)) => buf[i%buf.size()].rate;\n\n    // reset playback position for a buf\n    0 => buf[i%buf.size()].pos;\n\n    // randomize time\n    Math.random2f(0.075, 0.125)::second => now;\n    //0.5::second => now;\n\n    // increment    \n    i++;\n}\n",
                "data": []
            }
        },
        {
            "moe2.ck": {
                "code": "// impulse to filter to dac\nImpulse i => BiQuad f => Pan2 p => dac;\n// set the filter's pole radius\n.99 => f.prad; \n// set equal gain zeros\n1 => f.eqzs;\n// set filter gain\n.5 => f.gain;\n  \n// infinite time-loop   \nwhile( true )\n{\n    // set the current sample/impulse\n    1.0 => i.next;\n    // set filter resonant frequency\n    Math.random2f( 250, 5000 ) => f.pfreq;\n    // pan\n    Math.random2f( -1, 1 ) => p.pan;\n    // advance time\n    100::ms => now;\n}\n",
                "data": []
            }
        },
        {
            "powerup2.ck": {
                "code": "// power up!\n// - philipd, stereo gewang\n\n0.0 => float t;\nNoise n;\n\n// timer shred\nfun void timer() { \n    while ( true ) { \n        t + 0.01 => t;\n        10::ms => now;\n    }\n}\n\n// spork the timer\nspork ~ timer();\n\n// sweep shred\nfun void sweep( float st, float inc, float end, int c )\n{\n    n => TwoPole z => Pan2 p => dac; \n    1  => z.norm;\n    0.1 => z.gain;\n    t => float dt;\n    st => float frq;\n    Math.random2f( -1, 1 ) => float s;\n    Math.random2f( -1, 1 ) => float e;\n    ( e - s ) / ( end - t ) * .01 => float i;\n    s => p.pan;\n    Math.random2f( 0.94, 0.99 ) => z.radius;\n    while( t < end ) {\n        Math.max( ( t - dt ) * 4.0, 1.0 ) * 0.1 => z.gain; \n        frq + inc * -0.02  => frq; \n        frq => z.freq;\n        p.pan() + i => p.pan;\n        10::ms => now;\n    }\n\n    n =< z;\n    z =< p;\n    p =< dac;\n}\n\n0 => int c;\n// time loop\nwhile( true ) { \n    500::ms => dur d;\n    if( Math.random2( 0, 10 ) > 3 ) d * 2.0 => d;\n    if( Math.random2( 0, 10 ) > 6 ) d * 3.0 => d;\n    spork ~ sweep( 220.0 * Math.random2( 1, 8 ), \n                   880.0 + Math.random2f( 100.0, 880.0 ),\n                   t + Math.random2f( 1.0, 3.0 ) , c);\n    1 + c => c; \n    d => now;\n}\n",
                "data": []
            }
        },
        {
            "larry2.ck": {
                "code": "// impulse to filter to dac\nImpulse i => BiQuad f => Pan2 p => dac;\n// set the filter's pole radius\n.99 => f.prad; \n// set equal gain zeros\n1 => f.eqzs;\n// set filter gain\n.5 => f.gain;\n  \n// infinite time-loop   \nwhile( true )\n{\n    // set the current sample/impulse\n    1.0 => i.next;\n    // set filter resonant frequency\n    Math.random2f( 500, 5000 ) => f.pfreq;\n    // pan\n    Math.random2f( -1, 1 ) => p.pan;\n    // advance time\n    101::ms => now;\n}\n\n",
                "data": []
            }
        },
        {
            "ugen-array.ck": {
                "code": "// working with arrays of UGens\nSndBuf buf => Pan2 pan => NRev reverb[2] => Gain master[2] => dac;\n// set reveb mix\n0.1 => reverb[0].mix => reverb[1].mix;\n// load sound\n\"special:dope\" => buf.read;\n\n// infinite time loop\nwhile( true )\n{\n    // randomize pan\n    Math.random2(-1, 1) => pan.pan;\n    // reset playback position\n    0 => buf.pos;\n    // advance time\n    0.35::second => now;\n}\n",
                "data": []
            }
        },
        {
            "stereo-noise.ck": {
                "code": "// white noise to Pan2 (stereo) to dac\nNoise n => Pan2 p => dac;\n// pan type; 1 is equal power panning\n// <<< \"pan type:\", p.panType() >>>;\n// not too loud\n.1 => n.gain;\n\n// variable\n0.0 => float t;\n// smaller == smoother\n10::ms => dur T;\n\n// print\n<<< \"holding pan at center for 1 second...\", \"\" >>>;\n// hold the pan to be in the middle first\n1::second => now;\n\n// print\n<<< \"panning left <-> right...\", \"\" >>>;\n// time loop\nwhile( true )\n{\n    // pan goes from -1 (left) to 1 (right)\n    Math.sin(t) => p.pan;\n    // increment t (scaling by T)\n    T / second * 2.5 +=> t;\n    // advancde time\n    T => now;\n}\n",
                "data": []
            }
        }
    ],
    "analysis": [
        {
            "fft.ck": {
                "code": "// fft.ck: taking FFT via upchcuk, printing the spectrum\n// authors: Rebecca Fiebrink and Ge Wang\n\n// our patch\nSinOsc g => FFT fft => blackhole;\n\n// set srate\nsecond / samp => float srate;\n// set parameters\n8 => fft.size;\n// divide\nint div;\n\n// control loop\nwhile( true )\n{\n    // set freq\n    srate / fft.size() * div++ => g.freq;\n    fft.size()/2 %=> div;\n    \n    // take fft\n    fft.upchuck();\n    // examine contents\n    <<< fft.cval(0)$polar, fft.cval(1)$polar,\n        fft.cval(2)$polar, fft.cval(3)$polar >>>;\n\n    // advance time\n    100::ms => now;\n}\n",
                "data": []
            }
        },
        {
            "fft2.ck": {
                "code": "// fft2.ck: yet another way to FFT, by getting array out of blob\n// author: Rebecca Fiebrink and Ge Wang\n\n// our patch\nSinOsc g => FFT fft => blackhole;\n\n// set srate\nsecond / samp => float srate;\n// set parameters\n8 => fft.size;\n\n// divide\nint div;\n// array ref\ncomplex c[];\n\n// control loop\nwhile( true )\n{\n    // set freq\n    srate / fft.size() * div++ => g.freq;\n    fft.size()/2 %=> div;\n    \n    // take fft\n    fft.upchuck().cvals() @=> c;\n    // examine contents\n    <<< c[0]$polar, c[1]$polar, c[2]$polar, c[3]$polar >>>;\n\n    // advance time\n    100::ms => now;\n}\n",
                "data": []
            }
        },
        {
            "fft3.ck": {
                "code": "// fft3.ck: yet another way to get FFT spectrum - without blobs\n// authors: Rebecca Fiebrink and Ge Wang\n\n// our patch\nSinOsc g => FFT fft => blackhole;\n// set srate\nsecond / samp => float srate;\n\n// set parameters\n8 => fft.size;\n\n// use this to hold contents\ncomplex s[fft.size()/2];\n// divide\nint div;\n\n// control loop\nwhile( true )\n{\n    // set freq\n    srate / fft.size() * div++ => g.freq;\n    fft.size()/2 %=> div;\n    \n    // take fft\n    fft.upchuck();\n    // get contents\n    fft.spectrum( s );\n    // examine contents\n    <<< s[0]$polar, s[1]$polar, s[2]$polar, s[3]$polar >>>;\n\n    // advance time\n    100::ms => now;\n}\n",
                "data": []
            }
        },
        {
            "ifft.ck": {
                "code": "// our patch\nSinOsc g => FFT fft =^ IFFT ifft => dac;\n\n// set parameters\n1024 => fft.size;\n440 => g.freq;\n\n// control loop\nwhile( true )\n{\n    // take fft then ifft\n    ifft.upchuck();\n\n    // advance time\n    fft.size()::samp => now;\n}\n",
                "data": []
            }
        },
        {
            "flip.ck": {
                "code": "// Flip: turns the last N samples into a vector in the UAna domain\n// UnFlip: turns a UAna frame back into the time domain via overlap add\n// author: Ge Wang (ge@ccrma.stanford.edu)\n//         Rebecca Fiebrink (fiebrink@cs.princeton.edu)\n\n// identity test\nSinOsc s => Flip flip =^ UnFlip unflip => dac;\n\n// set size\n512 => flip.size => unflip.size;\n\n// go\nwhile( true )\n{\n    // do it\n    unflip.upchuck();\n    // hop\n    unflip.size()::samp => now;\n}\n",
                "data": []
            }
        },
        {
            "autocorr.ck": {
                "code": "// name: autocorr.ck\n// desc: finding the pitch of a note\n// author: Curtis Ullerich\n\n// UGen/UAna patch\nSinOsc s => Flip flip =^ AutoCorr corr => blackhole;\n// analysis zie\n1024 => flip.size;\n// output in [-1,1]\ntrue => corr.normalize;\n// calculate sample rate\nsecond/samp => float srate;\n\n// pitch estimate\nfun float estimatePitch()\n{\n    // perform analysis at corr (propagating backwards)\n    corr.upchuck();\n    // for simplicity, ignore bins for notes that are \"too high\"\n    // to care about; stop at the mid-point because it's symmetrical.\n    (srate/Std.mtof(90)) $ int => int maxBin;\n    // iterate over result of analysis\n    for( maxBin => int bin; bin < corr.fvals().size()/2; bin++ )\n    {\n        // look for max\n        if( corr.fval(bin) >= corr.fval(maxBin) ) {\n            bin => maxBin;\n        }\n    }\n    // return frequency\n    return srate/maxBin;\n}\n\n// loop\nfor (int i; i < 10; i++)\n{\n    // randomize freq\n    Math.random2f(Std.mtof(40), Std.mtof(80)) => s.freq;\n    // move forward in time (by analysis frame size)\n    flip.size()::samp => now;\n    // print\n    <<< \"pitch\", s.freq(), \"estimated to be\", estimatePitch(), \"hz\" >>>;\n}\n",
                "data": []
            }
        },
        {
            "xcorr.ck": {
                "code": "// name: xcorr.ck\n// desc: calculting how much delay is applied to a signal\n// author: Curtis Ullerich\n\n// signal source\nSndBuf signal => dac;\n// delayed signal\nsignal => DelayL delay => dac;\n// load sound\n\"special:dope\" => signal.read;\n// randomize delay\nMath.random2f(100, 400)$int => int delayMs;\n// set delay\ndelayMs::ms => delay.max => delay.delay;\n// set gain\n0.8 => signal.gain;\n\n// set analysis\nsignal => Flip f1 =^ XCorr xcorr => blackhole;\ndelay => Flip f2 =^ xcorr;\n(second/samp)$int => int srate;\n\n// will get bumped to the next power of two for the actual\n// Fourier transform\nsignal.samples() + delayMs*srate/1000 => float size;\n// FFT sizes\nsize$int => f1.size => f2.size;\n// wait\nsignal.samples()::samp + delayMs::ms => now;\n// analyze!\nxcorr.upchuck();\n\n// iterate\n0 => int maxI;\nfor (0 => int i; i < size; i++)\n{\n    // look for max\n    if (xcorr.fval(i) >= xcorr.fval(maxI)) {\n        i => maxI;\n    }\n}\n\n// print\n<<< \"    actual delay was\", delayMs, \"milliseconds\" >>>;\n<<< \"calculated delay was\", 1000*maxI/srate$float, \"milliseconds\" >>>;\n// wait\n1::second => now;\n",
                "data": []
            }
        },
        {
            "win.ck": {
                "code": "// our patch\nSinOsc g => FFT fft => blackhole;\n// synthesis\nIFFT ifft => dac;\n// set srate\nsecond / samp => float srate;\n\n// set parameters\n1024 => fft.size;\n// window\nWindowing.hamming(512) => fft.window;\nWindowing.hamming(512) => ifft.window;\n\n// use this to hold contents\ncomplex s[fft.size()/2];\n// divide\nint div;\n\n// control loop\nwhile( true )\n{\n    // set freq\n    srate / fft.size() * div++ => g.freq;\n    fft.size()/2 %=> div;\n    \n    // take fft\n    fft.upchuck();\n    // get contents\n    fft.spectrum( s );\n    // take ifft\n    ifft.transform( s );\n\n    // advance time\n    256::samp => now;\n}\n",
                "data": []
            }
        },
        {
            "fft1.ck": {
                "code": "// fft1.ck: using uana blobs!\n// authors: Rebecca Fiebrink and Ge Wang\n\n// our patch\nSinOsc g => FFT fft => blackhole;\n\n// set srate\nsecond / samp => float srate;\n// set parameters\n8 => fft.size;\n\n// divide\nint div;\n// the blob\nUAnaBlob blob;\n\n// control loop\nwhile( true )\n{\n    // set freq\n    srate / fft.size() * div++ => g.freq;\n    fft.size()/2 %=> div;\n    \n    // take fft\n    fft.upchuck() @=> blob;\n    // examine contents\n    <<< blob.cval(0)$polar, blob.cval(1)$polar,\n        blob.cval(2)$polar, blob.cval(3)$polar >>>;\n\n    // advance time\n    100::ms => now;\n}\n",
                "data": []
            }
        },
        {
            "xsynth.ck": {
                "code": "// really really bad cross synthesizer...\n\n// source one (mic)\nadc => FFT X => blackhole;\n// source two (to be connected below)\nFFT Y => blackhole;\n// synthesis\nIFFT ifft => dac;\n\n// what to cross\nBlitSquare blt[6];\n[ 40, 46, 52, 60, 64, 87] @=> int pitches[];\nfor( int i; i < blt.size(); i++ )\n{\n    blt[i] => Y;\n    20 => blt[i].harmonics;\n    pitches[i] => Std.mtof => blt[i].freq;\n}\n\n// set FFT size\n1024 => X.size => Y.size => int FFT_SIZE;\n// desired hop size\nFFT_SIZE / 4 => int HOP_SIZE;\n// set window and window size\nWindowing.hann(512) => X.window;\nWindowing.hann(512) => Y.window;\nWindowing.hann(512) => ifft.window;\n// use this to hold contents\ncomplex Z[FFT_SIZE/2];\n\n// control loop\nwhile( true )\n{\n    // take ffts\n    X.upchuck();\n    Y.upchuck();\n    \n    // multiply in frequency domain\n    for( int i; i < X.size()/2; i++ )\n        Math.sqrt((Y.cval(i)$polar).mag) * X.cval(i) => Z[i];\n        // 2 * Y.cval(i) * X.cval(i) => Z[i];\n    \n    // take ifft\n    ifft.transform( Z );\n    \n    // advance time\n    HOP_SIZE::samp => now;\n}\n",
                "data": []
            }
        },
        {
            "ifft3.ck": {
                "code": "// our patch\nSinOsc g => FFT fft =^ IFFT ifft => dac;\n\n// set srate\nsecond / samp => float srate;\n// set parameters\n1024 => fft.size;\n\n// divide\nint div;\n\n// control loop\nwhile( true )\n{\n    // set freq\n    srate / fft.size() * div++ => g.freq;\n    fft.size()/2 %=> div;\n    \n    // pull from ifft\n    ifft.upchuck();\n\n    // advance time\n    fft.size()::samp => now;\n}\n",
                "data": []
            }
        },
        {
            "Sigmund.ck": {
                "code": "///////////////////////////////////////////////////\n// Sigmund: sinusoidal analysis & pitch tracking //\n//                                               //\n// by Miller Puckette                            //\n//                                               //\n///////////////////////////////////////////////////\n\n// Options:\n// npts (int): number of points used in analysis.\n//     Must be a power of 2, at least 128. The\n//     minimum frequency that can be tracked is\n//     about 2 * samplerate / npts\n//     default: 1024\n//\n// npeak (int): maximum number of sinusoidal peaks\n//     to look for. The computation time is\n//     quadratic in the number of peaks actually\n//     found (this number only sets an upper\n//     limit). Use it to balance CPU time with\n//     quality of results.\n//\n// maxfreq (float): maximum frequency of sinusoidal\n//     peaks to look for. This can be useful in\n//     situations where background nose creates\n//     high-frequency, spurious peaks...\n//\n// minpower (float): minimum dB level to\n//     report a pitch. Signals quieter than this\n//     will be assumed to be crosstalk and ignored.\n//     default: 50\n//\n// freq() (read-only): get reported frequency of\n//     input signal\n//\n// env() (read-only): get reported RMS value (in dB)\n//     of input signal\n//\n// peak (int): report freq of nth sinusoundal peak\n//     sorting depends on parameter \"dotracks\"\n//\n// amp (int): report amplitude of nth sinusoundal peak\n//     sorting depends on parameter \"dotracks\"\n//\n// tracks (0/1): toggle whether peak and amp are\n//     sorted in order of amplitude or organized into\n//     tracks\n//\n// clear(): clear buffers and reset\n//\n// param1, param2, param3 (float): mysterious settings...\n\n// must connect to blackhole to perform DSP\nTriOsc foo => Sigmund siggy => blackhole;\n\n4096 => siggy.npts;\n20 => siggy.npeak;\n1000 => siggy.maxfreq;\n25 => siggy.minpower;\n\nwhile (true)\n{\n\tMath.random2f(5,300) => foo.freq;\n\tMath.random2f(0,1) => foo.gain;\n\tsecond => now;\n\t<<< \"Real frequency:\",foo.freq(),\"real gain:\",foo.gain(),\"Sigmund found this:\",siggy.freq(), \"power:\", siggy.env() >>>;\n}\n",
                "data": []
            }
        },
        {
            "ifft2.ck": {
                "code": "// our patch\nSinOsc g => FFT fft => blackhole;\n// synthesize\nIFFT ifft => dac;\n\n// set parameters\n1024 => fft.size;\n440 => g.freq;\n\n// use this to hold contents\ncomplex s[fft.size()/2];\n\n// control loop\nwhile( true )\n{\n    // take fft\n    fft.upchuck();\n    // get contents\n    fft.spectrum( s );\n    // take ifft\n    ifft.transform( s );\n\n    // advance time\n    fft.size()::samp => now;\n}\n",
                "data": []
            }
        },
        {
            "concat.ck": {
                "code": "// name: concat.ck\n// desc: FeatureCollector is really meant to be used for recording data for machine\n// learning analysis (see https://chuck.cs.princeton.edu/doc/language/uana.html),\n// but this example shows bare-bones usage of the UAana for something silly.\n//\n// author: Curtis Ullerich\n\nFeatureCollector fc =^ UnFlip unflip => dac;\nSinOsc one => Flip f1 =^ fc;\nTriOsc two => Flip f2 =^ fc;\n.5 => one.gain => two.gain;\n\n300 => int freq;\nfreq => one.freq;\n2*freq => two.freq;\nsecond/freq => dur period;\n(period/samp)$int => int size; // number of samples in a period\nsize => f1.size => f2.size;\n\nwhile(true)\n{\n    period => now;\n    unflip.upchuck();\n}\n",
                "data": []
            }
        },
        {
            "dct.ck": {
                "code": "// dct.ck: taking DCT via upchuck, printing the spectrum\n// authors: Rebecca Fiebrink and Ge Wang\n\n// our patch\nSinOsc g => DCT dct => blackhole;\n\n// set srate\nsecond / samp => float srate;\n// set parameters\n8 => dct.size;\n// divide\nint div;\n\n// control loop\nwhile( true )\n{\n    // set freq\n    srate / dct.size() * div++ => g.freq;\n    dct.size()/2 %=> div;\n    \n    // take dct\n    dct.upchuck();\n    // examine contents\n    <<< dct.fval(0), dct.fval(1), dct.fval(2), dct.fval(3) >>>;\n\n    // advance time\n    100::ms => now;\n}\n",
                "data": []
            }
        },
        "tracking"
    ],
    "tracking": [
        {
            "Tracking.ck": {
                "code": "//--\n// name: Tracking.ck\n// desc: class and process for tracking a peak and amplitutde via FFT\n//       the Tracking class can be accessed from external shreds\n//\n// author: Ge Wang + Rebecca Fiebrink\n// date: 2007\n//--\n\n\n// public class\npublic class Tracking\n{\n    static float the_freq;\n    static float the_gain;\n    static Event @ the_event;\n}\n\n// initialize separately (due to a bug)\nnew Event @=> Tracking.the_event;\n\n// analysis\nadc => PoleZero dcblock => FFT fft => blackhole;\n\n// set to block DC\n.99 => dcblock.blockZero;\n// set FFT params\n2048 => fft.size;\n// window\nWindowing.hamming( fft.size() ) => fft.window;\n\n// go for it\nwhile( true )\n{\n    // take fft\n    fft.upchuck() @=> UAnaBlob blob;\n    \n    // find peak\n    0 => float max; float where;\n    for( int i; i < blob.fvals().size()/8; i++ )\n    {\n        // compare\n        if( blob.fvals()[i] > max )\n        {\n            // save\n            blob.fvals()[i] => max;\n            i => where;\n        }\n    }\n    \n    // set freq\n    (where / fft.size() * (second / samp)) => Tracking.the_freq;\n    // set gain\n    (max / .5) => Tracking.the_gain;\n    // clamp\n    if( Tracking.the_gain > 1 )\n        1 => Tracking.the_gain;\n    // fire!\n    Tracking.the_event.broadcast();\n\n    // hop\n    (fft.size()/4)::samp => now;\n}\n",
                "data": []
            }
        },
        {
            "pitch-track.ck": {
                "code": "//--\n// name: pitch-track.ck\n// desc: rough pitch tracking\n//\n// author: Rebecca Fiebrink + Ge Wang\n//   date: 2007\n//--\n\n\n// analysis\nadc => PoleZero dcblock => FFT fft => blackhole;\n// synthesis\nSinOsc s => JCRev r => dac;\n\n// set reverb mix\n.05 => r.mix;\n// set to block DC\n.99 => dcblock.blockZero;\n// set FFT params\n1024 => fft.size;\n// window\nWindowing.hamming( fft.size() ) => fft.window;\n\n// to hold result\nUAnaBlob blob;\n// find sample rate\nsecond / samp => float srate;\n\n// interpolate\nfloat target_freq, curr_freq, target_gain, curr_gain;\nspork ~ ramp_stuff();\n\n// go for it\nwhile( true )\n{\n    // take fft\n    fft.upchuck() @=> blob;\n    \n    // find peak\n    0 => float max; int where;\n    for( int i; i < blob.fvals().size(); i++ )\n    {\n        // compare\n        if( blob.fvals()[i] > max )\n        {\n            // save\n            blob.fvals()[i] => max;\n            i => where;\n        }\n    }\n    \n    // set freq\n    (where $ float) / fft.size() * srate => target_freq;\n    // set gain\n    (max / .8) => target_gain;\n    \n    // hop\n    (fft.size()/2)::samp => now;\n}\n\n\n// interpolation\nfun void ramp_stuff()\n{\n    // mysterious 'slew'\n    0.025 => float slew;\n    \n    // infinite time loop\n    while( true )\n    {\n        (target_freq - curr_freq) * 5 * slew + curr_freq => curr_freq => s.freq;\n        (target_gain - curr_gain) * slew + curr_gain => curr_gain => s.gain;\n        0.0025::second => now;\n    }\n}\n",
                "data": []
            }
        },
        {
            "harm.ck": {
                "code": "//--\n// name: harm.ck\n// desc: using Tracking and Smacking to harmonize\n//\n// author: Rebecca Fiebrink + Ge Wang\n// date: 2007\n//--\n\n\n// synthesis\nBlitSaw s => JCRev r => dac;\n4 => s.harmonics;\n\n// set reverb mix\n.05 => r.mix;\n// possible hamonizing intervals\n[ 3-24, 4-12, 7, 9+12 ] @=> int harms[];\nfloat the_harm;\n\n// interpolate\nfloat target_freq, curr_freq, target_gain, curr_gain;\nspork ~ ramp_stuff();\nspork ~ smack_handler();\n\n// go for it\nwhile( true )\n{\n    // wait for analysis event\n    Tracking.the_event => now;\n    \n    // set freq\n    Tracking.the_freq * Math.pow(1.059, the_harm) => target_freq;\n    // set gain\n    Tracking.the_gain => target_gain;\n}\n\n// interpolation\nfun void ramp_stuff()\n{\n    // mysterious 'slew'\n    0.025 => float slew;\n    \n    // infinite time loop\n    while( true )\n    {\n        (target_freq - curr_freq) * 1 * slew + curr_freq => curr_freq => s.freq;\n        (target_gain - curr_gain) * .25 * slew + curr_gain => curr_gain => s.gain;\n        0.0025::second => now;\n    }\n}\n\n// handles smack\nfun void smack_handler()\n{\n    // go\n    while( true )\n    {\n        // wait\n        Smacking.the_event => now;\n        \n        // choose random interval\n        harms[Math.random2(0,harms.size()-1)] => the_harm;\n        // set freq\n        Tracking.the_freq * Math.pow(1.059, the_harm) => target_freq;\n        // print\n        <<< \"new interval:\", the_harm >>>;\n    }\n}\n",
                "data": []
            }
        },
        {
            "pitch-seventh.ck": {
                "code": "//--\n// name: pitch-seventh.ck\n// desc: rough pitch tracking + dominant 7th\n//\n// author: Rebecca Fiebrink + Ge Wang\n// date: 2007\n//--\n\n\n// analysis\nadc => PoleZero dcblock => FFT fft => blackhole;\n// synthesis\nSinOsc s => JCRev r => dac;\n\n// set reverb mix\n.05 => r.mix;\n// set to block DC\n.99 => dcblock.blockZero;\n// set FFT params\n1024 => fft.size;\n// window\nWindowing.hamming( fft.size() ) => fft.window;\n\n// interpolate\nfloat target_freq, curr_freq, target_gain, curr_gain;\nspork ~ ramp_stuff();\n\n// go for it\nwhile( true )\n{\n    // take fft\n    fft.upchuck() @=> UAnaBlob blob;\n    \n    // find peak\n    0 => float max; float where;\n    for( int i; i < blob.fvals().size(); i++ )\n    {\n        // compare\n        if( blob.fvals()[i] > max )\n        {\n            // save\n            blob.fvals()[i] => max;\n            i => where;\n        }\n    }\n    \n    // set freq\n    (where / fft.size() * (second / samp)) * Math.pow(1.059,10) => target_freq;\n    // set gain\n    (max / .25) => target_gain;\n    \n    // hop\n    (fft.size()/2)::samp => now;\n}\n\n\n// interpolation\nfun void ramp_stuff()\n{\n    // mysterious 'slew'\n    0.025 => float slew;\n    \n    // infinite time loop\n    while( true )\n    {\n        (target_freq - curr_freq) * 5 * slew + curr_freq => curr_freq => s.freq;\n        (target_gain - curr_gain) * slew + curr_gain => curr_gain => s.gain;\n        0.0025::second => now;\n    }\n}\n",
                "data": []
            }
        },
        {
            "pitch-third.ck": {
                "code": "//--\n// name: pitch-third.ck\n// desc: rough pitch tracking + major third\n//\n// author: Rebecca Fiebrink + Ge Wang\n// date: 2007\n//--\n\n\n// analysis\nadc => PoleZero dcblock => FFT fft => blackhole;\n// synthesis\nSinOsc s => JCRev r => dac;\n\n// set reverb mix\n.05 => r.mix;\n// set to block DC\n.99 => dcblock.blockZero;\n// set FFT params\n1024 => fft.size;\n// window\nWindowing.hamming( fft.size() ) => fft.window;\n\n// interpolate\nfloat target_freq, curr_freq, target_gain, curr_gain;\nspork ~ ramp_stuff();\n\n// go for it\nwhile( true )\n{\n    // take fft\n    fft.upchuck() @=> UAnaBlob blob;\n    \n    // find peak\n    0 => float max; float where;\n    for( int i; i < blob.fvals().size(); i++ )\n    {\n        // compare\n        if( blob.fvals()[i] > max )\n        {\n            // save\n            blob.fvals()[i] => max;\n            i => where;\n        }\n    }\n    \n    // set freq\n    (where / fft.size() * (second / samp)) * Math.pow(1.059,4) => target_freq;\n    // set gain\n    (max / .25) => target_gain;\n    \n    // hop\n    (fft.size()/2)::samp => now;\n}\n\n\n// interpolation\nfun void ramp_stuff()\n{\n    // mysterious 'slew'\n    0.025 => float slew;\n    \n    // infinite time loop\n    while( true )\n    {\n        (target_freq - curr_freq) * 5 * slew + curr_freq => curr_freq => s.freq;\n        (target_gain - curr_gain) * slew + curr_gain => curr_gain => s.gain;\n        0.0025::second => now;\n    }\n}\n",
                "data": []
            }
        },
        {
            "pitch-fifth.ck": {
                "code": "//--\n// name: pitch-fifth.ck\n// desc: tough pitch tracking + perfect fifth\n//\n// author: Rebecca Fiebrink + Ge Wang\n// date: 2007\n//--\n\n\n// analysis\nadc => PoleZero dcblock => FFT fft => blackhole;\n// synthesis\nSinOsc s => JCRev r => dac;\n\n// set reverb mix\n.05 => r.mix;\n// set to block DC\n.99 => dcblock.blockZero;\n// set FFT params\n2048 => fft.size;\n// window\nWindowing.hamming( fft.size() ) => fft.window;\n\n// interpolate\nfloat target_freq, curr_freq, target_gain, curr_gain;\nspork ~ ramp_stuff();\n\n// go for it\nwhile( true )\n{\n    // take fft\n    fft.upchuck() @=> UAnaBlob blob;\n    \n    // find peak\n    0 => float max; float where;\n    for( int i; i < blob.fvals().size()/8; i++ )\n    {\n        // compare\n        if( blob.fvals()[i] > max )\n        {\n            // save\n            blob.fvals()[i] => max;\n            i => where;\n        }\n    }\n    \n    // set freq\n    (where / fft.size() * (second / samp)) * Math.pow(1.059,7) => target_freq;\n    // set gain\n    (max / .5) => target_gain;\n    \n    // hop\n    (fft.size()/4)::samp => now;\n}\n\n\n// interpolation\nfun void ramp_stuff()\n{\n    // mysterious 'slew'\n    0.025 => float slew;\n    \n    // infinite time loop\n    while( true )\n    {\n        (target_freq - curr_freq) * 5 * slew + curr_freq => curr_freq => s.freq;\n        (target_gain - curr_gain) * slew + curr_gain => curr_gain => s.gain;\n        0.0025::second => now;\n    }\n}\n",
                "data": []
            }
        }
    ],
    "array": [
        {
            "array_associative.ck": {
                "code": "// declare regular array (capacity doesn't matter so much)\nfloat foo[4];\n\n// use as int-based array\n2.5 => foo[0];\n\n// use as associative array with key \"yoyo\"\n4.0 => foo[\"yoyo\"];\n\n// access as associative (print)\n<<< foo[\"yoyo\"] >>>;\n\n// access empty element\n<<< foo[\"gaga\"] >>>;  // -> should print 0.0\n\n// add a second associative element\n44.0 => foo[\"yiyi\"];\n\n// get the array keys with all of the keys in the array\nstring keys[0];\nfoo.getKeys(keys);\n\n// print all keys current in foo\nfor( auto key : keys )\n{\n    <<< \"key:\", key >>>;\n}\n\n// isInMap\n<<< \"(isInMap?)\",\n    \"\\nyiyi:\", foo.isInMap(\"yiyi\"),\n    \"\\nyoyo:\", foo.isInMap(\"yoyo\"),\n    \"\\ngaga:\", foo.isInMap(\"gaga\"),\n    \"\\nNONO:\", foo.isInMap(\"NONO\") >>>;\n\n// call .help() on an array to get more information about its type, methods, etc.\n// foo.help();\n",
                "data": []
            }
        },
        {
            "foreach-6.ck": {
                "code": "//-------------------------------------------------------\n// name: foreach-6.ck\n// desc: foreach with unit generators\n//\n// requires: chuck-1.5.0.8 or higher\n//-------------------------------------------------------\n\n// create empty array\nTriOsc array[4];\n\n// for each, connect and set params\nfor( Osc x : array )\n{\n    // connect\n    x => dac;\n    // set gain\n    .25 => x.gain;\n    // set randomize freq\n    Math.random2f(200,800) => x.freq;\n}\n\n// advance time\n2::second => now;\n",
                "data": []
            }
        },
        {
            "array_zero.ck": {
                "code": "// .zero() zeros out the contents AND keeps size unchanged\n// version: need chuck-1.5.0.0 or higher\n\n// an array\n[1,3,4] @=> int array[];\n\n// should print 3 3\n<<< array[1], array.size() >>>;\n\n// zero out the array, leaving size as is\narray.zero();\n\n// now should print 0 3\n<<< array[1], array.size() >>>;\n",
                "data": []
            }
        },
        {
            "array_reverse.ck": {
                "code": "// example reversing the order of an array\n// version: need chuck-1.5.0.0 or higher\n\n// an array\n[1,2,3,4,5] @=> int a[];\n\n// print array in-order\nprint_arr(a);\n\n// reverse\na.reverse();\n\n// print reversed order\nprint_arr(a);\n\n// return to original order\na.reverse();\nprint_arr(a);\n\n\nfun void print_arr(int a[]) {\n    for (0 => int i; i < a.size(); i++) {\n        cherr <= a[i] <= \" \"; \n    }\n    cherr <= IO.nl();\n}\n",
                "data": []
            }
        },
        {
            "foreach-auto2.ck": {
                "code": "//-------------------------------------------------------\n// name: foreach-auto2.ck\n// desc: iterating over multi-dimensional arrays\n//.      using for-each and auto\n//\n// requires: chuck-1.5.0.8 or higher\n//-------------------------------------------------------\n\n// a multi dimensional array\nint array[2][0];\n\n// fill the two arrays\narray[0] << 1 << 2;\narray[1] << 3 << 4;\n\n// loop over outer array\nfor( auto x[] : array )\n{\n    // loop over inner array\n    for( int y : x )\n    {\n        <<< y >>>;\n    }\n}\n",
                "data": []
            }
        },
        {
            "foreach-2.ck": {
                "code": "//-------------------------------------------------------\n// name: foreach-2.ck\n// desc: iterating over an array of values\n//\n// requires: chuck-1.5.0.8 or higher\n//-------------------------------------------------------\n\n// iterating over an array literal\nfor( int x : [ 1, 2, 3 ] )\n{ \n    // do something with it\n    <<< x >>>; \n}\n",
                "data": []
            }
        },
        {
            "foreach-3.ck": {
                "code": "//-------------------------------------------------------\n// name: foreach-3.ck\n// desc: nested for-each loops\n//\n// requires: chuck-1.5.0.8 or higher\n//-------------------------------------------------------\n\n// two arrays\n[1, 2, 3] @=> int foo[];\n[1, 2, 3] @=> int bar[];\n\n// for each element in foo\nfor( int f : foo ) \n{\n    // for each element in bar\n    for( int b : bar )\n    {\n        // print the product\n        <<< f*b >>>;\n    }\n}\n",
                "data": []
            }
        },
        {
            "array_sort.ck": {
                "code": "//-----------------------------------------------------------------------------\n// name: array_sort.ck\n// desc: sort the contents of arrays (various types)\n// requires: chuck-1.5.0.9 or higher\n\n\n//-----------------------------------------------------------------------------\n// integer array\n//-----------------------------------------------------------------------------\n[ 5,2,-1,4,3,1,0,-2 ] @=> int arrayInt[];\n// sort by ascending value\narrayInt.sort();\n// print\nfor( auto x : arrayInt ) { cherr <= x <= \" \"; } cherr <= IO.nl();\n// reverse for descending\narrayInt.reverse();\n// print\nfor( auto x : arrayInt ) { cherr <= x <= \" \"; } cherr <= IO.nl();\n\n\n//-----------------------------------------------------------------------------\n// float array\n//-----------------------------------------------------------------------------\n[ 2.0, -pi, 1, pi ] @=> float arrayFloat[];\n// sort by ascending value\narrayFloat.sort();\n// print\nfor( auto x : arrayFloat ) { cherr <= x <= \" \"; } cherr <= IO.nl();\n\n\n//-----------------------------------------------------------------------------\n// complex array: sort by 2-norm/mag with phase as tie-breaker\n//-----------------------------------------------------------------------------\n[ #(-1,-1), #(1,1), #(0,0), #(1,0) ] @=> complex arrayComplex[];\n// sort by ascending value\narrayComplex.sort();\n// print\nfor( auto x : arrayComplex ) { cherr <= x <= \" \"; } cherr <= IO.nl();\n\n\n//-----------------------------------------------------------------------------\n// polar array: sort by magnitude with phase as tie-breaker\n//-----------------------------------------------------------------------------\n[ %(2,pi/2), %(1,pi), %(2,pi) ] @=> polar arrayPolar[];\n// sort by ascending value\narrayPolar.sort();\n// print\nfor( auto x : arrayPolar ) { cherr <= x <= \" \"; } cherr <= IO.nl();\n\n\n//-----------------------------------------------------------------------------\n// vec3 array: sort by magnitude with x then y then z as tie breakers\n//-----------------------------------------------------------------------------\n[ @(-1,-1,-1), @(1,2,1), @(0,0,0) ] @=> vec3 arrayVec3[];\n// sort by ascending value\narrayVec3.sort();\n// print\nfor( auto x : arrayVec3 ) { cherr <= x <= \" \"; } cherr <= IO.nl();\n\n\n//-----------------------------------------------------------------------------\n// vec4 array: sort by magnitude with x then y then z then w as tie breakers\n//-----------------------------------------------------------------------------\n[ @(-1,-1,-1,-1), @(1,3,1,-2), @(0,0,0,0) ] @=> vec4 arrayVec4[];\n// sort by ascending value\narrayVec4.sort();\n// print\nfor( auto x : arrayVec4 ) { cherr <= x <= \" \"; } cherr <= IO.nl();\n\n\n//-----------------------------------------------------------------------------\n// Object array: sort by reference/pointer value for now\n//-----------------------------------------------------------------------------\nSinOsc foos[3];\n// shuffle\nfoos.shuffle();\n// sort by ascending value\nfoos.sort();\n// print\nfor( auto x : foos ) { <<< x >>>; }\n",
                "data": []
            }
        },
        {
            "array_range.ck": {
                "code": "// using Std.range() to generate arrays containing a range of values\n// (requires chuck-1.5.1.1 or higher)\n\n// *** VARIANT #1 Std.range(stop) ***\n// [ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, ]\nprint( Std.range(10) );\n// [ 0, -1, -2, -3, -4, ]\nprint( Std.range(-5) );\n\n// *** VARIANT #2 Std.range(start,stop) ***\n// [ 5, 6, 7, ]\nprint( Std.range(5,8) );\n// [ 3, 2, 1, 0, -1, -2, -3, ]\nprint( Std.range(3,-4) ); // descending\n\n// *** VARIANT #2 Std.range(start,stop,step) ***\n// [ -1, 0, 1, 2, 3, 4, ]\nprint( Std.range(-1,5,1) );\n// [ -2, -3, -4, -5, -6, -7, -8, -9, ]\nprint( Std.range(-2,-10,-1) ); // descending\n// [ 0, 4, 8, ]\nprint( Std.range(0,10,4) ); // step of 4\n// [ 5, 1, -3, -7, -11, -15, -19, ]\nprint( Std.range(5,-20,-4) ); // step of -4\n// [ 5, 1, -3, -7, -11, -15, -19, ]\nprint( Std.range(5,-20,4) ); // same as 4\n\n// validate zero length\n// [ ]\nprint( Std.range(1,1,2) );\n// [ ]\nprint( Std.range(1,1,-1) );\n// [ ]\nprint( Std.range(-1,-1,-1) );\n// step == 0, results in [ ]\nprint( Std.range(1,1,0) );\n\n// formatted array print\nfun void print( int array[] )\n{\n    // print open\n    cherr <= \"[ \";\n    // print each element\n    for( int x : array ) cherr <= x <= \", \";\n    // print close\n    cherr <= \"]\";\n    // new line\n    cherr <= IO.nl();\n}\n",
                "data": []
            }
        },
        {
            "array_mmixed.ck": {
                "code": "// based on Robin Haberkorn's example\nint a[0][2];\n\n// instantiate arrays\nnew int[2] @=> a[\"foo\"];\nnew int[2] @=> a[\"bar\"];\n\n// fill them\n23 => a[\"foo\"][0];\n24 => a[\"foo\"][1];\n32 => a[\"bar\"][0];\n42 => a[\"bar\"][1];\n\n// test them\nif( a[\"foo\"][0] == 23 && a[\"bar\"][1] == 42 )\n    <<< \"success\" >>>;\n\n",
                "data": []
            }
        },
        {
            "array_capacity.ck": {
                "code": "// name: array_capacity.ck\n// desc: this demonstrates how array.size() array.capacity() works;\n//       added: 1.4.1.0 (ge)\n//\n//       (NOTE: .capacity() is not the same as .cap(); the latter is\n//       maintained for historical / compatibility reasons; .cap()\n//       actually is the same as .size() -- which is rather confusing!\n//\n//       It is strongly recommended that .cap() be avoided; instead,\n//       explicitly use .size() or .capacity() as appropriate.)\n\n// declare an array\n// (size = array length; capacity >= size)\nint a[4];\n// print size and capacity\nprint(1);\n\n// reset: clear array\n// (size is reset to 0; capacity is reset to at least 8)\na.reset();\n// print size and capacity\nprint(2);\n\n// append to array\n// (size should reflect the number of elements appended)\na << 1 << 2 << 3 << 5 << 8;\n// print size and capacity\nprint(3);\n\n// resize to 15\n// (this changes both size to 15 and capacity to at least 15)\n15 => a.size;\n// print size and capacity\nprint(4);\n\n// append to array\n// (size should reflect the number of elements appended)\na << 13 << 21 << 34;\n// print size and capacity\nprint(5);\n\n// *reserve* capacity\n// (since this is less than current capacity,\n// neither size nor capacity is actually changed)\n10 => a.capacity;\n// print size and capacity\nprint(6);\n\n// *reserve* a larger capacity\n// (this should result in a larger capacity without changing size)\n50 => a.capacity;\n// print size and capacity\nprint(7);\n\n// helper print function\nfun void print( int iteration )\n{\n    <<< iteration, \"| array size:\", a.size(), \n        \"capacity:\", a.capacity() >>>;\n}\n",
                "data": []
            }
        },
        {
            "array_resize.ck": {
                "code": "// name: array_resize.ck\n// desc: this demonstrates how array resize and clear;\n//       also see: array_capacity.ck\n//       modified: 1.4.1.0 (ge)\n//\n//       (NOTE: .capacity() is not the same as .cap(); the latter is\n//       maintained for historical / compatibility reasons; .cap()\n//       actually is the same as .size() -- which is rather confusing!\n//\n//       It is strongly recommended that .cap() be avoided; instead,\n//       explicitly use .size() or .capacity() as appropriate.)\n\n// instantiate a float array\nfloat argh[0];\n\n// print\n<<< \"array size:\", argh.size(), \"capacity:\", argh.capacity() >>>;\n\n// resize\n4 => argh.size;\n\n// print\n<<< \"array size:\", argh.size(), \"capacity:\", argh.capacity() >>>;\n\n// set elements\n3.0 => argh[0];\n4 => argh[1];\n5.0 => argh[2];\n6 => argh[3];\n\n// print\n<<< \"contents:\", \"\">>>;\nfor( int i; i < argh.size(); i++ )\n    <<< \"argh[\", i, \"]:\", argh[i] >>>;\n\n// recap\n2 => argh.size;\n\n// print\n<<< \"array size:\", argh.size(), \"capacity:\", argh.capacity() >>>;\n\n// clear the contents\nargh.clear();\n\n// print\n<<< \"array size:\", argh.size(), \"capacity:\", argh.capacity() >>>;\n",
                "data": []
            }
        },
        {
            "array_argument.ck": {
                "code": "// array pass by reference test\n\n// function that takes array\nfun void mirror( int arg[] )\n{\n    // assign 0th element to 1st element\n    arg[0] => arg[1];\n}\n\n// declare array\nint foo[2];\n2 => foo[0];\n1 => foo[1];\n\n// call the function\nmirror( foo );\n\n// test\nif ( foo[0] == foo[1] ) <<<\"success\">>>;\n",
                "data": []
            }
        },
        {
            "array_assign.ck": {
                "code": "// partial array (17.ck)\n\n// declare int array 2x2\nint x[2][2];\n\n// assign\n2 => x[1][1];\n\n// assign partial array reference to 'y'\nx[1] @=> int y[];\n\n// test\nif( y[1] == 2 ) <<<\"success\">>>;\n",
                "data": []
            }
        },
        {
            "array_erase.ck": {
                "code": "// name: array_erase.ck\n// desc: shows array.erase()\n//\n// requires: chuck-1.5.0.8 or higher\n\n// create zero-length array\nint a[0];\n\n// print size\n<<< \"size (before append):\", a.size() >>>;\n\n// append\na << 1 << 2 << 3 << 5 << 8;\n\n// print size\n<<< \"size (after append):\", a.size() >>>;\n\n// erase 5th element\na.erase( 4 );\n// erase front\na.popFront();\n\n// print size\n<<< \"size (after erase and popFront):\", a.size() >>>;\n\n// print contents\nfor( int i; i < a.size(); i++ )\n{\n    <<< i, \":\", a[i] >>>;\n}\n",
                "data": []
            }
        },
        {
            "array_sub_assign.ck": {
                "code": "// multi-dimensional array\n// array to array assignment\n\nint a[2][2][2];\nint b[2][2];\n// assignment\n1 => b[0][1];\n2 => b[0][0];\n\n// assign b to 0th element of a\nb @=> a[0];\n\n// verify\nif ( a[0][0][1] == 1 ) <<<\"success\">>>;\n",
                "data": []
            }
        },
        {
            "array_append.ck": {
                "code": "// create zero-length array\nint a[0];\n\n// print size\n<<< \"size (before append):\", a.size() >>>;\n\n// append\na << 1 << 2 << 3 << 5 << 8;\n\n// print size\n<<< \"size (after append):\", a.size() >>>;\n\n// print contents\nfor( int i; i < a.size(); i++ )\n{\n    <<< i, \":\", a[i] >>>;\n}\n",
                "data": []
            }
        },
        {
            "array_dynamic.ck": {
                "code": "// instantiate int array\nfloat argh[0];\n\n// print out relevant info\n<<< \"array size:\", argh.size() >>>;\n\n// append items (array should grow dynamically as needed)\nargh << 3.0 << 4 << 5;\n\n// print out relevant info\n<<< \"array size:\", argh.size() >>>;\n\n// print out elements\n<<< \"contents:\", argh[0], argh[1], argh[2] >>>;\n\n// pop last element\nargh.popBack();\n\n// print out relevant info\n<<< \"array size:\", argh.size() >>>;\n\nargh << 6 << 7 << 8;\n\n// pop middle element\nargh.popOut(2);\n\n// print array\n<<< \"printing remaining elements of array...\" >>>;\nfor (0 => int i; i < argh.size(); i++) {\n    <<< \"elem\", i, \"-\", argh[i] >>>;\n}\n",
                "data": []
            }
        },
        {
            "array_negative.ck": {
                "code": "// arrays can have negative indices!\n// version: need chuck-1.5.0.0 or higher\n\n// an array\n[1,2,3,4] @=> int a[];\n\n// same as a(s.size(()-1)\n<<<  a[-1] >>>; // 4\n\n// same as a(s.size(()-3)\n<<< a[-3] >>>; // 2\n",
                "data": []
            }
        },
        {
            "foreach-4.ck": {
                "code": "//-------------------------------------------------------\n// name: foreach-4.ck\n// desc: iterating over multi-dimensional arrays\n//\n// requires: chuck-1.5.0.8 or higher\n//-------------------------------------------------------\n\n// a multi dimensional array\nint array[2][0];\n\n// fill the two arrays\narray[0] << 1 << 2;\narray[1] << 3 << 4;\n\n// loop over outer array\nfor( int x[] : array )\n{\n    // loop over inner array\n    for( int y : x )\n    {\n        <<< y >>>;\n    }\n}\n",
                "data": []
            }
        },
        {
            "array_shuffle.ck": {
                "code": "// name: array_shuffle.ck\n// desc: shuffling the contents of an array; useful for tasks like random without replacement\n// author: kunwoo, nshaheed, andrew, ge | 1.5.0.0\n\n// an array\n[1,2,3,4,5] @=> int a[];\n\n// uncomment to print array API\n// a.help();\n// uncomment to explicitly set a random seed\n// Math.srandom(11);\n\n// shuffle a few times\nrepeat( 10 )\n{\n    // print\n    for( int i; i < a.size(); i++ )\n    { cherr <= a[i] <= \" \"; } cherr <= IO.nl();\n    // shuffle!\n    a.shuffle();\n}\n\n// one way to do random without replacement\nrepeat( 3 )\n{\n    cherr <= \"--- random without replacment --- \" <= IO.nl();\n    // shuffle!\n    a.shuffle();\n    // just go through array in order after shuffle\n    for( int i; i < a.size(); i++ )\n    {\n        // print the next \"random\" value\n        cherr <= \"next value: \" <= a[i] <= IO.nl();\n    }\n}\n",
                "data": []
            }
        },
        {
            "foreach-5.ck": {
                "code": "//-------------------------------------------------------\n// name: foreach-5.ck\n// desc: foreach with Objects\n//\n// requires: chuck-1.5.0.8 or higher\n//-------------------------------------------------------\n\n// create empty array\nSinOsc array[5];\n\n// number\n110 => float f;\n\n// for each element 'x' in array\nfor( SinOsc x : array )\n{\n    // set the frequency\n    f => x.freq;\n    // double it\n    2 *=> f;\n}\n\n\n// a second loop for testing's sake\n// (also using Osc, a parent of SinOsc to iterate)\nfor( Osc x : array )\n{\n    // print\n    <<< x.freq() >>>;\n}\n",
                "data": []
            }
        },
        {
            "array_erase2.ck": {
                "code": "// name: array_erase2.ck\n// desc: shows array.erase(int, int) to remove a range\n//\n// requires: chuck-1.5.0.8 or higher\n\n// create zero-length array\nint a[0];\n\n// print size\n<<< \"size (before append):\", a.size() >>>;\n\n// append\na << 1 << 2 << 3 << 4 << 5 << 6 << 7 << 8;\n\n// print size\n<<< \"size (after append):\", a.size() >>>;\n\n// erase 3rd to 5th element\n// NOTE erase(begin, end) remove [begin,end):\n// i.e., starting with begin and up to but NOT including end\na.erase( 2, 5 );\n\n// print size\n<<< \"size (after erase and popFront):\", a.size() >>>;\n\n// print contents\nfor( int i; i < a.size(); i++ )\n{\n    <<< i, \":\", a[i] >>>;\n}\n",
                "data": []
            }
        },
        {
            "array_mdim.ck": {
                "code": "// multi-dimensional array instantiation (15.ck)\n\n// delcare int array 2x2x2\nint a[2][2][2];\n// delcare float array 2x2x2\nfloat b[2][2][2];\n// assign\n5 => a[1][1][1] => b[1][1][1];\n\n// multi-dimensional array initialization\n[ [1,2], [3,4] ] @=> int c[][];\n\n// test\nif( a[1][1][1] == 5 && b[1][1][1] == 5.0 && c[0][1] == 2 )\n    <<<\"success\">>>;\n",
                "data": []
            }
        },
        {
            "array_storage.ck": {
                "code": "// multi-dimensional array\nint a[2][2][2];\n// assignment\n4 => a[0][0][1];\n// access\na[0][0][1] => int b;\n\n// test\nif ( b == 4 ) <<<\"success\">>>;\n",
                "data": []
            }
        },
        {
            "foreach-auto1.ck": {
                "code": "//-------------------------------------------------------\n// name: foreach-auto1.ck\n// desc: using for-each construct with auto type\n//\n// requires: chuck-1.5.0.8 or higher\n//-------------------------------------------------------\n\n// create array\n[1,2,3] @=> int array[];\n\n// for each element 'x' in array\nfor( auto x : array )\n{\n    // print the element\n    <<< x >>>;\n}\n",
                "data": []
            }
        },
        {
            "foreach-1.ck": {
                "code": "//-------------------------------------------------------\n// name: foreach-1.ck\n// desc: using for-each construct to loop over array\n//\n// requires: chuck-1.5.0.8 or higher\n//-------------------------------------------------------\n\n// create empty array\nfloat array[0];\n\n// append\narray << 1 << 2.5 << 3;\n\n// for each element 'x' in array\nfor( float x : array )\n{\n    // print the element\n    <<< x >>>;\n}\n",
                "data": []
            }
        }
    ],
    "ctrl": [
        {
            "ctrl_repeat.ck": {
                "code": "// a 'repeat' loop repeats for a fixed number of repetitions\n\n// our counter\n0 => int x;\n\n// repeat a fixed number of times\nrepeat( 4 )\n{\n    x++;\n}\n\n// repeat x number of times (or what the value of x is when we first\n// reach this loop...e.g., should be 4 in this instance)\nrepeat( x )\n{\n    // the repeat value 'x' is evaluated only once at the beginning\n    // of the loop; even if 'x' is subsequently changed, it will not\n    // alter the number of repetitions of the loop\n    x++;\n}\n\n// verify where the counter ended up\nif( x == 8 ) <<< \"success\" >>>;\n",
                "data": []
            }
        },
        {
            "ctrl_while.ck": {
                "code": "// while loop (opposite of until loop)\n\n0 => int j;\n0 => int i;\n\n// loop\nwhile( i < 5 )\n{ \n    1 +=> j;\n    1 +=> i;\n}\n\n// test\nif ( j == 5 ) <<<\"success\">>>;\n",
                "data": []
            }
        },
        {
            "ctrl_until.ck": {
                "code": "// until loop (opposite of while loop)\n\n0 => int j;\n0 => int i;\n\n// loop\nuntil ( i == 5 )\n{ \n    1 +=> j;\n    1 +=> i;\n}\n\n// test\nif ( j == 5 ) <<<\"success\">>>;\n",
                "data": []
            }
        },
        {
            "ctrl_for_loop.ck": {
                "code": "// for loop ( factorial ) , -=>, *=>\n\n// function\nfun int factorial ( int arg )\n{ \n    1 => int r;\n    arg => int b;\n    for ( b ; b > 1 ; 1 -=> b )\n    { \n        b *=> r;\n    }\n\n    return r;\n}\n\n// call the function\nfactorial ( 4 ) => int x;\n\n// test\nif ( x == 24 ) <<<\"success\">>>;\n",
                "data": []
            }
        },
        {
            "ctrl_do_until.ck": {
                "code": "// do-until\n\n0 => int j;\n0 => int i;\n\ndo { \n    1 +=> j;\n    1 +=> i;\n} until ( i >= 5 );\n\n// test\nif ( j == 5 ) <<<\"success\">>>;\n",
                "data": []
            }
        },
        {
            "ctrl_do_while.ck": {
                "code": "// do-while\n\n0 => int j;\n0 => int i;\n\ndo { \n    1 +=> j;\n    1 +=> i;\n} while( i < 5 );\n\n// test\nif( j == 5 ) <<<\"success\">>>;\n",
                "data": []
            }
        },
        {
            "ctrl_break.ck": {
                "code": "// break;\n\n0 => int j;\n\n// loop\nwhile ( true )\n{\n    if ( j >= 5 )\n        break;\n\n    1 +=> j;\n}\n\n// test\nif ( j == 5 ) <<<\"success\">>>;\n",
                "data": []
            }
        },
        {
            "ctrl_foreach.ck": {
                "code": "//-------------------------------------------------------\n// name: ctrl_foreach.ck\n// desc: for-each construct to loop over arrays\n//\n// requires: chuck-1.5.0.8 or higher\n//\n// SEE ALSO: examples/array/foreach-*.ck for more\n//-------------------------------------------------------\n\n// create empty array\nfloat array[0];\n\n// append\narray << 1 << 2.5 << 3;\n\n// for each element 'x' in array\nfor( float x : array )\n{\n    // print the element\n    <<< x >>>;\n}\n\n// iterating over an array literal\nfor( int x : [ 1, 2, 3 ] )\n{ \n    // do something with it\n    <<< x >>>; \n}\n",
                "data": []
            }
        },
        {
            "ctrl_continue.ck": {
                "code": "// continue in nested block\n \n0 => int j;\n0 => int i;\n0 => int check;\n\n// loop\nwhile ( j < 5 )\n{\n    0 => i;\n    while ( i < 5 )\n    {\n        1 +=> i;  \n        if ( j < 4 ) continue;  \n\n        // because of continue, this only happens in last ( j==0 )\n        2 +=> check; \n    }\n\n    // if continue malfunctions, this is skipped, and we get INFINITE LOOP \n    1 +=> j;\n}\n\n// make sure that continue does the right thing in the inner loop?\nif ( check == 10 ) <<<\"success\">>>;\n\n\n",
                "data": []
            }
        },
        {
            "ctrl_break_nested.ck": {
                "code": "// break in nested block\n \n0 => int j;\n0 => int i;\n\n// loop\nwhile ( j < 5 )\n{\n    while ( i < 10 )\n    { \n        1 +=> i;  \n        // arbitrary break here, shouldn't bust of out the outer loop\n        if ( i > 5 ) break;  \n    }\t\n\n    1 +=> j;\n}\n\n// test\nif ( j == 5 ) <<<\"success\">>>;\n",
                "data": []
            }
        },
        {
            "ctrl_sequencer.ck": {
                "code": "// um, by philipd\n// (what is it?)\n\n// base Player class\nclass Player\n{ \n    UGen @ base;\n    fun void connect( UGen target )\n    {\n        base => target;\n    }\n\n    fun void noteOn ( float note, float vel ) {}\n    fun void noteOff ( float vel ) {}\n}\n\nclass Note\n{ \n    float note;\n    float vel;\n    dur length;\n\n    fun void set ( float nt, float vl, dur ln )\n    { \n        nt => note;\n        vl => vel;\n        ln => length;\n    }\n\n    fun void playOn ( Player p)\n    { \n        if ( note > 0 )\n        { \n            p.noteOn( note , vel );\n        }\n    }\n\n    fun void playOnAlt( Player p, float noff, float vmul )\n    {\n        p.noteOn( note+noff, vel*vmul );\n    }\n}\n\n\nclass MandPlayer extends Player\n{\n    Mandolin m @=> base;\n\n    fun void noteOn ( float note, float vel )\n    { \n        Std.mtof ( note ) => m.freq;\n        vel => m.pluck;\n    }\n}\n\nclass FlutePlayer extends Player\n{ \n    PercFlut f @=> base; \n    fun void noteOn ( float note, float vel )\n    { \n        Std.mtof ( note ) => f.freq;\n        vel => f.noteOn;\n    }\n}\n\nclass ClarPlayer extends Player\n{\n    Clarinet c @=> base;\n    fun void noteOn ( float note, float vel )\n    { \n        Std.mtof ( note ) => c.freq;\n        vel => c.startBlowing;\n    }\n    fun void noteOff ( float vel )\n    { \n        vel => c.stopBlowing;\n    }\n}\n\n// length of sequence\n12 => int seqn;\n// a sequence\nNote sequence[seqn];\n// order\nint order[seqn];\n// scale\n[0, 2, 4, 7, 9, 12, 14, 16, 19, 21] @=> int scale[];\n// durations\n[0.25::second, 0.125::second, 0.125::second,  0.375::second] @=> dur times[];\n\n// new sequence\nfun void newsequence()\n{ \n    for( 0 => int i; i < seqn; i++ )\n    {\n        i => order[i];\t\t\n        55 + scale[Math.random2(0, scale.size() - 1)] => int note;\n        times[Math.random2(0, times.size() - 1)] => dur mydur;\n        Math.random2f( 0.75, 0.9 ) => float vel; \n        sequence[i].set( note, vel, mydur );\n    }\n}\n\nfun void swap( )\n{ \n    Math.random2(0,seqn-1) => int a;\n    ( a + Math.random2(1,seqn-1) ) % seqn => int b;\n    order[a] => int tmp;\n    order[b] => order[a];\n    tmp => order[a];\n}\n\n// instantiate a mandolin player\nMandPlayer mand;\n// instantiate a clarinet player\nClarPlayer clar;\n\n// effects\nGain g => JCRev j => Echo e => dac;\n0.95 => j.gain;\n0.1 => j.mix;\n// set echo amount\n1.15::second => e.max;\n1.0::second => e.delay;\n0.3 => e.mix;\n\n// connect to effects\nmand.connect(g);\n// connect to effects\nclar.connect(g);\n\n// set gain\n0.6 => g.gain;\n\n// new sequence!\nnewsequence();\n\n// infinite time-loop\nwhile( true )\n{\n    for( 0 => int j; j < seqn; j++ )\n    { \n        sequence[order[j]] @=> Note cur;\n        cur.playOn ( mand );\n        cur.playOnAlt ( clar, 12 , 0.7 );\n        2.0 * cur.length => now;\n        cur.playOnAlt( mand, 7, 0.33);\n        cur.length => now;\n    }\n\n    for ( Math.random2(0,2) => int j ; j > 0 ; j-- )\n        swap();\n\n    if ( Math.random2(0, 10) > 8 )\n        newsequence();\n}\n",
                "data": []
            }
        }
    ],
    "multi": [
        {
            "i.ck": {
                "code": "// name: i.ck\n// desc: n-channel demo\n// note: ChucK can be started with as much channels as is\n//       supported on the underlyding audio device; this can be\n//       done on command line (see chuck --help for more info)\n//       or in the miniAudicle Preferences (note changes will\n//       not take effect until the ChucK VM is (re)started\n\n// number of channels\ndac.channels() => int N;\n// print\n<<< \"dac has\", N, \"channels\" >>>;\nint i;\n\n// make osc bank\nImpulse s[N];\n// connect to individual channels\nfor( int i; i < N; i++ )\n{\n    s[i] => dac.chan(i);\n    // .5 => s[i].gain;\n}\n\n// go\nwhile( true )\n{\n    1 => s[i].next;\n    100::ms => now;\n    (i+1)%N => i;\n}\n",
                "data": []
            }
        },
        {
            "we-robot.ck": {
                "code": "// name: we-robot.ck\n// desc: take us to your leader (talk into the mic), multi-channel\n// author: gewang, prc\n// note: ChucK can be started with as much channels as is\n//       supported on the underlyding audio device; this can be\n//       done on command line (see chuck --help for more info)\n//       or in the miniAudicle Preferences (note changes will\n//       not take effect until the ChucK VM is (re)started\n\n// n channels\ndac.channels() => int N;\n// print\n<<< \"dac has\", N, \"channels...\" >>>;\n\n// delays\nDelayL d[N];\n// gains\nGain g3[N];\n\n// our patch - feedforward part\nadc => Gain g;\nadc => Gain g2 => dac;\n\n// set delays\nfor( int i; i < N; i++ )\n{\n    // feedfoward\n    g => d[i] => dac.chan(i);\n    // feedback\n    d[i] => g3[i] => d[i];\n    // detune\n    30::ms + Math.random2f(-15,15)::ms => d[i].max => d[i].delay;\n    .95 => g3[i].gain;\n}\n\n// set parameters\n0.25 => g.gain;\n0.05 => g2.gain;\n\n// time loop\nwhile( true ) 100::ms => now;\n",
                "data": []
            }
        },
        {
            "n.ck": {
                "code": "// name: n.ck\n// desc: n-channel demo\n// note: ChucK can be started with as much channels as is\n//       supported on the underlyding audio device; this can be\n//       done on command line (see chuck --help for more info)\n//       or in the miniAudicle Preferences (note changes will\n//       not take effect until the ChucK VM is (re)started\n\n// number of channels\ndac.channels() => int N;\n// print\n<<< \"dac has\", N, \"channels\" >>>;\n\n// make osc bank\nSinOsc s[N];\n// connect to individual channels\nfor( int i; i < N; i++ )\n{\n    s[i] => dac.chan(i);\n    Math.random2f( 400, 440 ) => s[i].freq;\n    .2 => s[i].gain;\n}\n\n// go\nwhile( true ) 1::second => now;\n",
                "data": []
            }
        }
    ],
    "io": [
        {
            "write-byte.ck": {
                "code": "//---------------------------------------------------------------------\n// name: write-byte.ck\n// desc: example of writing bytes in BINARY mode\n//---------------------------------------------------------------------\n// filename\n\"write-byte.txt\" => string filename;\n// instantiate a file IO object\nFileIO fout;\n// open for write (in BINARY mode)\nfout.open( filename, FileIO.WRITE | FileIO.BINARY );\n\n// test\nif( !fout.good() )\n{\n    cherr <= \"can't open file for writing...\" <= IO.newline();\n    me.exit();\n}\n\n// byte sequence to write; equivalent to:\n// abc\\n123\\n\n[97, 98, 99, 10, 49, 50, 51, 10] @=> int bytes[];\n\n// loop\nfor( int i; i < bytes.size(); i++ )\n{\n    // write the next byte\n    // (other options include IO.INT16 and IO.INT32)\n    fout.write( bytes[i], IO.INT8 );\n}\n\n// close the thing\nfout.close();\n\n// print\n<<< \"file written:\", filename >>>;\n",
                "data": [
                    "https://raw.githubusercontent.com/ccrma/chuck/main/examples/io/write-byte.txt"
                ]
            }
        },
        {
            "read-int.ck": {
                "code": "//---------------------------------------------------------------------\n// name: read-int.ck\n// desc: basic example of reading int using FileIO\n//---------------------------------------------------------------------\n\n// default file\nme.dir() + \"read-int.txt\" => string filename;\n\n// look at command line\nif( me.args() > 0 ) me.arg(0) => filename;\n\n// instantiate\nFileIO fio;\n\n// open a file\nfio.open( filename, FileIO.READ );\n\n// ensure it's ok\nif( !fio.good() )\n{\n    cherr <= \"can't open file: \" <= filename <= \" for reading...\"\n          <= IO.newline();\n    me.exit();\n}\n\n// variable to read into\nint val;\n\n// loop until end\nwhile( fio => val )\n{\n    cherr <= val <= IO.newline();\n}\n",
                "data": [
                    "https://raw.githubusercontent.com/ccrma/chuck/main/examples/io/read-int.txt"
                ]
            }
        },
        {
            "write-auto.ck": {
                "code": "// example showing auto-naming for file writing\n\n// instantiate a file IO object\nFileIO fout;\n\n// optional: set prefix and extension\n// (defaults prefix: \"chuck-file\" ext: \"txt\")\nfout.autoPrefixExtension( \"chuck-file\", \"txt\" );\n\n// open for write (default mode: ASCII)\nfout.open( \"special:auto\", FileIO.WRITE );\n\n// test\nif( !fout.good() )\n{\n    cherr <= \"can't open file for writing...\" <= IO.newline();\n    me.exit();\n}\n\n// write some stuff\nfout <= 1 <= \" \" <= 2 <= \" \" <= \"foo\" <= IO.newline();\n\n// print the file that was written\n// FYI before we close it as that clears the filename\n<<< \"file written:\", fout.filename() >>>;\n\n// close the thing\nfout.close();\n",
                "data": []
            }
        },
        {
            "read-byte.ck": {
                "code": "//---------------------------------------------------------------------\n// name: read-byte.ck\n// desc: example of reading raw bytes from file\n// NOTE: file must be opened in BINARY mode for this to work\n//---------------------------------------------------------------------\n\n// default filepath\nme.dir() + \"read-byte.txt\" => string filename;\n// look at command line\nif( me.args() > 0 ) me.arg(0) => filename;\n\n// instantiate\nFileIO fio;\n// open a file (in BINARY mode)\nfio.open( filename, FileIO.READ | FileIO.BINARY );\n// ensure it's ok\nif( !fio.good() )\n{\n    cherr <= \"can't open file: \" <= filename <= \" for reading...\"\n          <= IO.newline();\n    me.exit();\n}\n\n// variable to read into\nint val;\n\n// loop until end\nwhile( fio.more() )\n{\n    // read the next byte\n    fio.readInt( IO.INT8 ) => val;\n    // optionsss ^^^^^^^ | requires chuck-1.5.0.1 or higher\n    // IO.INT8, IO.INT16, IO.INT32 (default to unsigned)\n    // IO.UINT8, IO.UINT16, IO.UINT32 (explicitly unsigned)\n    // IO.SINT6, IO.SINT16, IO.SINT32 (explicitly signed)\n\n    // print the value\n    cherr <= val <= IO.newline();\n}\n",
                "data": [
                    "https://raw.githubusercontent.com/ccrma/chuck/main/examples/io/read-byte.txt"
                ]
            }
        },
        {
            "write2.ck": {
                "code": "// filename\n\"write2.txt\" => string filename;\n// instantiate a file IO object\nFileIO fout;\n// open for write (default mode: ASCII)\nfout.open( filename, FileIO.WRITE );\n\n// test\nif( !fout.good() )\n{\n    cherr <= \"can't open file for writing...\" <= IO.newline();\n    me.exit();\n}\n\n// write some stuff\nfout.write( 1 );\nfout.write( 2 );\nfout.write( \"boo\" );\n\n// close the thing\nfout.close();\n\n// print\n<<< \"file written:\", filename >>>;\n",
                "data": [
                    "https://raw.githubusercontent.com/ccrma/chuck/main/examples/io/write2.txt"
                ]
            }
        },
        {
            "seek.ck": {
                "code": "// default file\nme.sourceDir() + \"jabberwocky.txt\" => string filename;\n\n// look at command line\nif( me.args() > 0 ) me.arg(0) => filename;\n\n// instantiate\nFileIO fio;\n\n// open a file\nfio.open( filename, FileIO.READ );\n\n// ensure it's ok\nif( !fio.good() )\n{\n    cherr <= \"can't open file: \" <= filename <= \" for reading...\" <= IO.nl();\n    me.exit();\n}\n\n// variable to read into\nstring str;\n\n// loop until end\nwhile( fio.more() )\n{\n    chout <= fio.readLine() <= IO.newline();\n}\n\n<<< \"\\n------------\", \"\" >>>;\n<<< \"rewinding...\", \"\" >>>;\n<<< \"------------\\n\", \"\" >>>;\nfio.seek( 0 );\n\n// loop until end\nwhile( fio.more() )\n{\n    chout <= fio.readLine() <= IO.newline();\n}\n\n\n",
                "data": [
                    "https://raw.githubusercontent.com/ccrma/chuck/main/examples/io/jabberwocky.txt"
                ]
            }
        },
        {
            "read-float.ck": {
                "code": "//---------------------------------------------------------------------\n// name: read-float.ck\n// desc: basic example of reading floats using FileIO\n//---------------------------------------------------------------------\n\n// default file\nme.dir() + \"read-float.txt\" => string filename;\n\n// look at command line\nif( me.args() > 0 ) me.arg(0) => filename;\n\n// instantiate\nFileIO fio;\n\n// open a file\nfio.open( filename, FileIO.READ );\n\n// ensure it's ok\nif( !fio.good() )\n{\n    cherr <= \"can't open file: \" <= filename <= \" for reading...\"\n          <= IO.newline();\n    me.exit();\n}\n\n// variable to read into\nfloat val;\n\n// loop until end\nwhile( fio => val )\n{\n    cherr <= val <= IO.newline();\n}\n",
                "data": [
                    "https://raw.githubusercontent.com/ccrma/chuck/main/examples/io/read-float.txt"
                ]
            }
        },
        {
            "chout.ck": {
                "code": "// 'chout' is chuck out, pronounced \"shout\"\n// 'cherr' is chuck err, pronounced \"Cher\"\n\n// output to console on stdout\nchout <= 1 <= \" foo \" <= 5.5 <= IO.newline();\n\n// output to console on stderr\ncherr <= 1 <= \" bar \" <= 5.5 <= IO.newline();\n\n// 'chout' is buffered; use chout.flush() to output immediately\n// 'cherr' prints immediately, flush() or no flush()\n",
                "data": []
            }
        },
        {
            "read-tokens.ck": {
                "code": "//---------------------------------------------------------------------\n// name: read-tokens.ck\n// desc: this example shows how to:\n//   1) open a text file for reading\n//   2) read the file line by line\n//   3) for each line, tokenize it into words (separated by spaces)\n//\n// author: Ge Wang (https://ccrma.stanford.edu/~ge/)\n// date: Winter 2023\n//---------------------------------------------------------------------\n\n// path and name of file to read\nme.dir() + \"jabberwocky.txt\" => string filename;\n// or get filename from command line arguments, if any\nif( me.args() > 0 ) me.arg(0) => filename;\n\n// delay between words (for effect)\n50::ms => dur WORD_T;\n// delay between lines\n800::ms => dur LINE_T;\n\n// instantiate a file IO object\nFileIO fio;\n// a string tokenizer\nStringTokenizer tokenizer;\n// a line of text\nstring line;\n// a word token\nstring word;\n\n// open the file\nfio.open( filename, FileIO.READ );\n\n// ensure it's ok\nif( !fio.good() )\n{\n    cherr <= \"can't open file: \" <= filename <= \" for reading...\"\n          <= IO.newline();\n    me.exit();\n}\n\n// new line\ncherr <= IO.newline();\n\n// loop until end\nwhile( fio.more() )\n{\n    // read current line\n    fio.readLine() => line;\n    // for each line, tokenize\n    tokenizer.set( line );\n    // loop over tokens\n    while( tokenizer.more() )\n    {\n        // get the next word\n        tokenizer.next() => word;\n        // print word followed by a space\n        cherr <= word <= \" \";\n        // delay for effect\n        WORD_T => now;\n    }\n    // done with current line\n    cherr <= IO.newline();\n    // delay for effect\n    LINE_T => now;\n}\n",
                "data": [
                    "https://raw.githubusercontent.com/ccrma/chuck/main/examples/io/jabberwocky.txt"
                ]
            }
        },
        {
            "read-wav-raw.ck": {
                "code": "//---------------------------------------------------------------------\n// name: read-wav-raw.ck\n// desc: example that illustrates manually parsing and rendering a\n//       mono WAV file. This demonstrates using FileIO in binary mode.\n//       FYI in practice, use SndBuf for easier audio file playback!\n// requires: chuck-1.5.0.1 or higher\n//\n// author: Perry R. Cook\n// date: Summer 2023\n// credit \"saigon44.wav\": opening words from /Apocalypse Now/\n//---------------------------------------------------------------------\n\n// warn people what is about to happen\n<<< \"raw mono WAV file reader!!\", \"\" >>>;\n\n// default file \nme.dir() + \"saigon44.wav\" => string filename;\n// look at command line\nif( me.args() > 0 ) me.arg(0) => filename;\n\n// instantiate a file IO object\nFileIO fio;\n\n// open a file for reading in BINARY mode\nfio.open( filename, IO.READ | IO.BINARY );\n// ensure it's ok\nif( !fio.good() )\n{\n    // print error message\n    cherr <= \"can't open file: \" <= filename <= \" for reading...\"\n          <= IO.newline();\n    // bail\n    me.exit();\n}\n\n// variable to read into\nint val;\n// header\n\"0123456789abcdefghijklmnopqrstuvwxyzABCD\" @=> string header;\n\n// .wav header details:\n// struct wavhdr {\n//    char  riff[4];        /* \"RIFF\"                                  */\n//    int   flength;        /* file length in bytes                    */\n//    char  wave[4];        /* \"WAVE\"                                  */\n//    char  fmt[4];         /* \"fmt \"                                  */\n//    int   block_size;     /* in bytes (generally 16)                 */\n//    short format_tag;     /* 1=PCM, 257=Mu-Law, 258=A-Law, 259=ADPCM */\n//    short num_chans;      /* 1=mono, 2=stereo                        */\n//    int   srate;          /* Sampling rate in samples per second     */\n//    int   bytes_per_sec;  /* bytes per second                        */\n//    short bytes_per_samp; /* 2=16-bit mono, 4=16-bit stereo          */\n//    short bits_per_samp;  /* Number of bits per sample               */\n//    char  data[4];        /* \"data\"                                  */\n//    int   dlength;        /* data length in bytes (filelength - 44)  */\n// };\n\n// read in the WAV file header, field by field\n// FYI since chuck-1.5.0.1, in binary mode, readInt() for IO.INT8,\n// IO.INT16, or IO.INT32 by default returns unsigned integers; to read\n// signed integers, call readInt() with IO.SINT8, IO.SINT16, or IO.SINT32\n// e.g., IO.SINT16 is used below when reading signed 16-bits samples\n\n// \"RIFF\"\nfio.readInt( IO.INT8 ) => val; header.setCharAt(0,val);\nfio.readInt( IO.INT8 ) => val; header.setCharAt(1,val);\nfio.readInt( IO.INT8 ) => val; header.setCharAt(2,val);\nfio.readInt( IO.INT8 ) => val; header.setCharAt(3,val);\n// file length\nfio.readInt( IO.INT32 ) => int flength;\n// \"WAVE\"\nfio.readInt( IO.INT8 ) => val; header.setCharAt(8,val);\nfio.readInt( IO.INT8 ) => val; header.setCharAt(9,val);\nfio.readInt( IO.INT8 ) => val; header.setCharAt(10,val);\nfio.readInt( IO.INT8 ) => val; header.setCharAt(11,val);\n// \"fmt \"\nfio.readInt( IO.INT8 ) => val; header.setCharAt(12,val);\nfio.readInt( IO.INT8 ) => val; header.setCharAt(13,val);\nfio.readInt( IO.INT8 ) => val; header.setCharAt(14,val);\nfio.readInt( IO.INT8 ) => val; header.setCharAt(15,val);\n// file info\nfio.readInt( IO.INT32 ) => int blockSize;\nfio.readInt( IO.INT16 ) => int format;\nfio.readInt( IO.INT16 ) => int numChannels;\nfio.readInt( IO.INT32 ) => int sRate;\nfio.readInt( IO.INT32 ) => int bytesPerSecond;\nfio.readInt( IO.INT16 ) => int bytesPerSample;\nfio.readInt( IO.INT16 ) => int bitsPerSample;\n// \"data\"\nfio.readInt( IO.INT8 ) => val; header.setCharAt(36,val);\nfio.readInt( IO.INT8 ) => val; header.setCharAt(37,val);\nfio.readInt( IO.INT8 ) => val; header.setCharAt(38,val);\nfio.readInt( IO.INT8 ) => val; header.setCharAt(39,val);\n// size of data region in bytes\nfio.readInt( IO.INT32 ) => int dLength;\n\n<<< \"***\", header, \"***\" >>>;\n<<< \"---------------------\", \"\" >>>;\n<<< \"File Length  =\", flength >>>;\n<<< \"Block Size   =\", blockSize >>>;\n<<< \"Format       =\", format >>>;\n<<< \"Num Chans    =\", numChannels >>>;\n<<< \"Sample Rate  =\", sRate >>>;\n<<< \"Bytes/Sec    =\", bytesPerSecond >>>;\n<<< \"Bytes/Sample =\", bytesPerSample >>>;\n<<< \"Bits/Sample  =\", bitsPerSample >>>;\n<<< \"Data Length  =\", dLength >>>;\n<<< \"---------------------\", \"\" >>>;\n\n// check\nif( numChannels > 1 )\n{\n    // print error message\n    <<< \"WAV file contains\", numChannels, \"channels...\" >>>;\n    <<< \"this examples only supports mono WAV files...\", \"\" >>>;\n    // bail\n    me.exit();\n}\n\n// render the waveform\nImpulse imp => dac;\n// number of samples\ndLength / bytesPerSample => int numSamples;\n// array\nfloat samples[numSamples];\n// sample number\n0 => int n;\n\n// loop until end\nwhile( n < numSamples )\n// while( fio.more() )\n// (^ this may not always work; WAV files may contain debris beyond data region)\n{\n    // read the next sample: signed 16-bit integer\n    fio.readInt( IO.SINT16 ) => int sample;\n    // map sample value from [-32768,32767] to [-1,1]\n    Math.remap(sample, -32768, 32767, -1, 1) => samples[n++] => imp.next;\n    // print dot every 1000 samples\n    if( n % 1000 == 0 ) {\n        chout <= \".\"; chout.flush();\n    }\n    // print marker every second\n    if( n % sRate == 0 ) {\n        chout <= \"|\"; chout.flush();\n    }\n    \n    // advance one sample\n    samp => now;\n}\n",
                "data": [
                    "https://raw.githubusercontent.com/ccrma/chuck/main/examples/io/saigon44.wav"
                ]
            }
        },
        {
            "read-line.ck": {
                "code": "//---------------------------------------------------------------------\n// name: read-line.ck\n// desc: basic example of reading a line of text using FileIO\n//---------------------------------------------------------------------\n\n// default file\nme.dir() + \"read-line.txt\" => string filename;\n\n// look at command line\nif( me.args() > 0 ) me.arg(0) => filename;\n\n// instantiate\nFileIO fio;\n\n// open a file\nfio.open( filename, FileIO.READ );\n\n// ensure it's ok\nif( !fio.good() )\n{\n    cherr <= \"can't open file: \" <= filename <= \" for reading...\"\n          <= IO.newline();\n    me.exit();\n}\n\n// loop until end\nwhile( fio.more() )\n{\n    chout <= fio.readLine() <= IO.newline();\n}\n",
                "data": [
                    "https://raw.githubusercontent.com/ccrma/chuck/main/examples/io/read-line.txt"
                ]
            }
        },
        {
            "read-str.ck": {
                "code": "// default file\nme.dir() + \"read-str.txt\" => string filename;\n\n// look at command line\nif( me.args() > 0 ) me.arg(0) => filename;\n\n// instantiate\nFileIO fio;\n\n// open a file\nfio.open( filename, FileIO.READ );\n\n// ensure it's ok\nif( !fio.good() )\n{\n    cherr <= \"can't open file: \" <= filename <= \" for reading...\" <= IO.nl();\n    me.exit();\n}\n\n// variable to read into\nstring str;\n\n// loop until end\nwhile( fio => str )\n{\n    chout <= str <= IO.newline();\n}\n",
                "data": [
                    "https://raw.githubusercontent.com/ccrma/chuck/main/examples/io/read-str.txt"
                ]
            }
        }
    ],
    "basic": [
        {
            "blit2.ck": {
                "code": "// patch\nBlit s => ADSR e => JCRev r => dac;\n.5 => s.gain;\n.05 => r.mix;\n\n// set adsr\ne.set( 5::ms, 3::ms, .5, 5::ms );\n\n// an array\n[ 0, 2, 4, 7, 9, 11 ] @=> int hi[];\n\n// infinite time loop\nwhile( true )\n{\n    // frequency\n    Std.mtof( 33 + Math.random2(0,3) * 12 +\n        hi[Math.random2(0,hi.size()-1)] ) => s.freq;\n\n    // harmonics\n    Math.random2( 1, 5 ) => s.harmonics;\n\n    // key on\n    e.keyOn();\n    // advance time\n    120::ms => now;\n    // key off\n    e.keyOff();\n    // advance time\n    5::ms => now;\n}\n",
                "data": []
            }
        },
        {
            "moe++.ck": {
                "code": "// run each stooge, or run three stooges concurrently\n// %> chuck moe++ larry++ curly++\n\n// source to filter to dac\nSndBuf i => BiQuad f => Gain g => dac;\n// second formant\ni => BiQuad f2 => g;\n// third formant\ni => BiQuad f3 => g;\n\n// set the filter's pole radius\n.995 => f.prad; .995 => f2.prad; .995 => f3.prad;\n// set equal gain zeros\n1 => f.eqzs; 1 => f2.eqzs; 1 => f3.eqzs;\n// initialize float variable\n1.5 * 3.14 => float v;\n// set filter gain\n.2 => f.gain; .04 => f2.gain; .01 => f3.gain;\n// load glottal pop\n\"special:glot_pop\" => i.read;\n// play\n1.0 => i.rate;\n\n  \n// infinite time-loop   \nwhile( true )\n{\n    // set the current pos\n    0 => i.pos;\n\n    // sweep the filter resonant frequency\n    660.0 + Math.sin(v)*80.0 => f.pfreq;\n    1780.0 + Math.sin(v*.5)*50.0 => f2.pfreq;\n    2410.0 + Math.sin(v*.25)*150.0 => f3.pfreq;\n\n    // increment v\n    v + .05 => v;\n    // gain\n    0.2 + Math.sin(v)*.2 => g.gain;\n    // advance time\n    (80.0 + Math.sin(v*2.0)*10.0)::ms => now;\n}\n",
                "data": []
            }
        },
        {
            "doh.ck": {
                "code": "// DOH!!!\n\n// the patch \nSndBuf buf => dac;\n// load the file (\"special:\" files are built into chuck)\n\"special:dope\" => buf.read;\n\n// time loop\nwhile( true )\n{\n    // set playback position to beginning\n    0 => buf.pos;\n    // randomize playback rate\n    Math.random2f(.75,1.25) => buf.rate;\n    // randomize time\n    500::ms => now;\n}\n",
                "data": []
            }
        },
        {
            "moe.ck": {
                "code": "// run each stooge, or run three stooges concurrently\n// %> chuck moe larry curly\n\n// impulse to filter to dac\nImpulse i => BiQuad f => dac;\n// set the filter's pole radius\n.99 => f.prad; \n// set equal gain zeros\n1 => f.eqzs;\n// initialize float variable\n0.0 => float v;\n// set filter gain\n.5 => f.gain;\n  \n// infinite time-loop   \nwhile( true )\n{\n    // set the current sample/impulse\n    1.0 => i.next;\n    // sweep the filter resonant frequency\n    Std.fabs(Math.sin(v)) * 4000.0 => f.pfreq;\n    // increment v\n    v + .1 => v;\n    // advance time\n    100::ms => now;\n}\n\n",
                "data": []
            }
        },
        {
            "infnan.ck": {
                "code": "// big number\n1000000000000000000000000000.0 => float n;\n// overflow it\nrepeat( 20 ) n *=> n;\n// test it\n<<< Math.isinf( n ) >>>;\n// bye sanity\n0 *=> n;\n// test it\n<<< Math.isnan( n ) >>>;\n\n// more\n<<< 1.0 / 0.0 => Math.isinf >>>;\n<<< 0.0 / 0.0 => Math.isnan >>>;\n<<< Math.INFINITY, -Math.INFINITY >>>;\n<<< Math.INFINITY => Math.isinf >>>;\n",
                "data": []
            }
        },
        {
            "whole.ck": {
                "code": "// another candidate for least exciting demo\n\n// patch\nSinOsc s => JCRev r => dac;\n.5 => r.gain;\n.075 => r.mix;\n\n// note number\n20 => float note;\n\n// go up to 127\nwhile( note < 128 )\n{\n    // convert MIDI note to hz\n    Std.mtof( note ) => s.freq;\n    // turn down the volume gradually\n    .5 - (note/256.0) => s.gain;\n\n    // move up by whole step\n    note + 2 => note;\n\n    // advance time\n    .125::second => now;\n}\n\n// turn off s\n0 => s.gain;\n// wait a bit\n2::second => now;\n\n",
                "data": []
            }
        },
        {
            "adc.ck": {
                "code": "// mic-in to audio out\n\n// the patch\nadc => Gain g => dac;\n\n// infinite time-loop\nwhile( true )\n{\n    // advance time\n    100::ms => now;\n}\n",
                "data": []
            }
        },
        {
            "foo2.ck": {
                "code": "// bandlimited ugens (Blit, BlitSaw, BlitSquare)\nBlit s => Pan2 p;\np.left => JCRev r1 => dac.left;\np.right => JCRev r2 => dac.right;\n\n// initial settings\n.5 => s.gain;\n.1 => r1.mix;\n.1 => r2.mix;\n\n// an array\n[ 0, 2, 4, 7, 9, 11 ] @=> int hi[];\n\n// set the harmonic\n4 => s.harmonics;\n\n// spork the pan control\nspork ~ dopan();\n\n// infinite time loop\nwhile( true )\n{\n    Std.mtof( 33 + Math.random2(0,3) * 12 +\n        hi[Math.random2(0,hi.size()-1)] ) => s.freq;\n    120::ms => now;\n}\n\n// pan control\nfun void dopan()\n{\n    float t;\n    while( true )\n    {\n        .7 * Math.sin(t) => p.pan;\n        .005 +=> t;\n        10::ms => now;\n    }\n}\n",
                "data": []
            }
        },
        {
            "rec-auto-stereo.ck": {
                "code": "// chuck this with other shreds to record to file\n// example> chuck foo.ck bar.ck rec-auto-stereo.ck\n\n// pull samples from the dac\n// WvOut2 -> stereo operation\ndac => WvOut2 w => blackhole;\n\n// set the prefix, which will prepended to the filename\n// do this if you want the file to appear automatically\n// in another directory.  if this isn't set, the file\n// should appear in the directory you run chuck from\n// with only the date and time.\n\"chuck-session\" => w.autoPrefix;\n\n// this is the output file name\n\"special:auto\" => w.wavFilename;\n// optionally specify bit depth\n// (\"special:auto\", IO.INT24) => w.wavFilename;\n\n// print it out\n<<<\"writing to file: \", w.filename()>>>;\n\n// any gain you want for the output\n.5 => w.fileGain;\n\n// temporary workaround to automatically close file on remove-shred\nnull @=> w;\n\n// infinite time loop...\n// ctrl-c will stop it, or modify to desired duration\nwhile( true ) 1::second => now;\n",
                "data": []
            }
        },
        {
            "sndbuf.ck": {
                "code": "// sound file to load; me.dir() returns location of this file\nme.dir() + \"snare.wav\" => string filename;\n// if there is argument, use it as the filename\nif( me.args() ) me.arg(0) => filename;\n\n// the patch\nSndBuf buf(filename) => dac;\n// can also load the file this way\n// filename => buf.read;\n\n// check if file successfully loaded\nif( !buf.ready() ) me.exit();\n\n// time loop\nwhile( true )\n{\n    // set playback position to beginning\n    0 => buf.pos;\n    // randomize gain\n    Math.random2f(.25,.5) => buf.gain;\n    // randomize rate\n    Math.random2f(.5,1.5) => buf.rate;\n    // advance time\n    100::ms => now;\n}\n",
                "data": [
                    "https://raw.githubusercontent.com/ccrma/chuck/main/examples/data/snare.wav"
                ]
            }
        },
        {
            "whirl.ck": {
                "code": "// sine to dac\nSinOsc s => dac;\n// let's turn down gain, for this can be loud and annoying\n.15 => s.gain;\n\n// infinite time loop\n0.0 => float t;\nwhile( true )\n{\n    // modulate\n    30 + ( Math.sin(t) + 1.0 ) * 10000.0 => s.sfreq;\n    t + .004 => t;\n\n    // advance time\n    1::ms => now;\n}\n",
                "data": []
            }
        },
        {
            "echo.ck": {
                "code": "// feedforward\nadc => Gain g => dac;\n// feedback\ng => Gain feedback => DelayL delay => g;\n\n// set delay parameters\n.75::second => delay.max => delay.delay;\n// set feedback\n.5 => feedback.gain;\n// set effects mix\n.75 => delay.gain;\n\n// infinite time loop\nwhile( true ) 1::second => now;\n\n",
                "data": []
            }
        },
        {
            "foo.ck": {
                "code": "// hello everyone.\n// a chuck is born...\n// its first words:\n\nSinOsc s => JCRev r => dac;\n.2 => s.gain;\n.1 => r.mix;\n\n// an array\n[ 0, 2, 4, 7, 9, 11 ] @=> int hi[];\n\nwhile( true )\n{\n    Std.mtof( 45 + Math.random2(0,3) * 12 +\n        hi[Math.random2(0,hi.size()-1)] ) => s.freq;\n    100::ms => now;\n}\n",
                "data": []
            }
        },
        {
            "ring.ck": {
                "code": "//--------------------------------------------\n// simple ring modulation\n//\n// any ugen has .op:\n// ---\n// -1 pass through the input\n// 0 stop input\n// 1 add inputs (default)\n// 2 subtract from first input\n// 3 multiply inputs\n// 4 divide from first input\n//--------------------------------------------\n\n// the patch\nadc => Gain g => dac;\nSinOsc s => g;\n\n// multiply inputs at g\n3 => g.op;\n\n// presets\n400.0 => s.freq;\n\n// time loop\nwhile( true )\n    1::second => now;\n",
                "data": []
            }
        },
        {
            "imp.ck": {
                "code": "// impulse generator is cool...\n// this demo is not\n\n// connect impulse generator\nImpulse i => dac;\n.5 => i.gain;\n\n// emit impulse every so often\n2000 => int a;\nwhile( 1 )\n{\n    // set the next sample\n    1.0 => i.next;\n\n    // advance time\n    a::samp => now;\n    a - 8 => a; if( a <= 0 ) 2000 => a;\n}\n",
                "data": []
            }
        },
        {
            "envelope.ck": {
                "code": "// run white noise through envelope\nNoise n => Envelope e => dac;\n\n// infinite time-loop\nwhile( true )\n{\n    // random choose rise/fall time\n    Math.random2f(10,500)::ms => dur t => e.duration;\n    // print\n    <<< \"rise/fall:\", t/ms, \"ms\" >>>;\n\n    // key on - start attack\n    e.keyOn();\n    // advance time by 800 ms\n    800::ms => now;\n    // key off - start release\n    e.keyOff();\n    // advance time by 800 ms\n    800::ms => now;\n}\n",
                "data": []
            }
        },
        {
            "func.ck": {
                "code": "8 => int a;\n\nfun int abs( int v )\n{\n    if( v < 0 ) return -v;\n    return v;\n}\n\nfun void args( int y, int b )\n{\n    4 => a;\n    <<<b>>>;\n}\n\nfun float sum( float a, float b )\n{\n    return a + b;\n}\n\nfun void go( int a )\n{\n    <<<abs(a)>>>;\n    if( a == 0 )\n        return;\n\n    go( abs(a)-1 );\n}\n\nint i;\nfor( 0 => i; i < 10; i + 1 => i )\n    go( 1000 );\n<<<abs(-1)>>>;\nargs( 1, 2 );\n<<<sum( 1.0, 2.0 )>>>;\n<<<a>>>;\n\n",
                "data": []
            }
        },
        {
            "chirp.ck": {
                "code": "// po-tweet!\n\n// patch\nSinOsc s => dac;\n// gain\n.4 => s.gain;\n\n// call chirp\nchirp( 127, 20, 1::second );\n\n// call chirp (with tinc)\nchirp( 20, 120, 1.5::second, 100::ms );\n\n// chirp function\nfun void chirp( float src, float target, dur duration )\n{\n    chirp( src, target, duration, 1::ms );\n}\n\n// chirp function (with tinc)\nfun void chirp( float src, float target, dur duration, dur tinc )\n{\n    // initialize freq\n    src => float freq;\n    // find the number of steps\n    duration / tinc => float steps;\n    // find the inc\n    ( target - src ) / steps => float inc;\n    // counter\n    float count;\n\n    // do the actual work over time\n    while( count < steps )\n    {\n        // increment the freq\n        freq + inc => freq;\n        // count\n        1 +=> count;\n\n        // set the freq\n        Std.mtof( freq ) => s.freq;\n\n        // advance time\n        tinc => now;\n    }\n}\n\n",
                "data": []
            }
        },
        {
            "demo1.ck": {
                "code": "// demo1.ck\n// candidate for most trivial demo\n\n0 => int a => int t;\n1 => int b;\n15 => int c;\n\nwhile( c > 0 ) \n{\n    a + b => t;\n    b => a;\n    <<<t => b>>>;\n    c - 1 => c;\n}\n",
                "data": []
            }
        },
        {
            "larry++.ck": {
                "code": "// run each stooge, or run three stooges concurrently\n// %> chuck moe++ larry++ curly++\n\n// impulse to filter to dac\nSndBuf i => BiQuad f => Gain g => JCRev r => dac;\n// second formant\ni => BiQuad f2 => g;\n// third formant\ni => BiQuad f3 => g;\n\n// set the filter's pole radius\n0.800 => f.prad; .995 => f2.prad; .995 => f3.prad;\n// set equal gain zeroes\n1 => f.eqzs; 1 => f2.eqzs; 1 => f3.eqzs;\n// initialize float variable\n0.0 => float v => float v2;\n// set filter gain\n.1 => f.gain; .1 => f2.gain; .01 => f3.gain;\n0.05 => r.mix;\n// load glottal pop\n\"special:glot_pop\" => i.read;\n// play\n1.0 => i.rate;\n  \n// infinite time-loop   \nwhile( true )\n{\n    // set the current sample/impulse\n    0 => i.pos;\n    // sweep the filter resonant frequency\n    250.0 + Math.sin(v*100.0)*20.0 => v2 => f.pfreq;\n    2290.0 + Math.sin(v*200.0)*50.0 => f2.pfreq;\n    3010.0 + Math.sin(v*300.0)*80.0 => f3.pfreq;\n    // increment v\n    v + .05 => v;\n    // gain\n    0.2 + Math.sin(v)*.1 => g.gain;\n    // advance time\n    (1000.0 + Math.random2f(-100.0, 100.0))::ms => now;\n}\n",
                "data": []
            }
        },
        {
            "fm3.ck": {
                "code": "// FM synthesis (using Step instead of .sync == 2; see fm2.ck)\n\n// modulator to carrier\nSinOsc m => SinOsc c => dac;\n// step function, add to modulator output\nStep step => c;\n\n// carrier frequency\n440 => step.next;\n// modulator frequency\n110 => m.freq;\n// index of modulation\n300 => m.gain;\n\n// time-loop\nwhile( true ) 1::second => now;\n",
                "data": []
            }
        },
        {
            "step.ck": {
                "code": "// step gen to dac\nStep s => dac;\n.5 => float v;\n\n// infinite time-loop\nwhile( 1 )\n{\n    // advance time\n    1::ms => now;\n    // set value\n    v => s.next;\n    -v => v;\n}\n",
                "data": []
            }
        },
        {
            "blit.ck": {
                "code": "// patch\nBlit s => JCRev r => dac;\n.5 => s.gain;\n.05 => r.mix;\n\n// an array\n[ 0, 2, 4, 7, 9, 11 ] @=> int hi[];\n// <<< hi.size() >>>;\n// <<< hi[0], hi[1], hi[2], hi[3], hi[4], hi[5] >>>;\n\n// infinite time loop\nwhile( true )\n{\n    // frequency\n    Std.mtof( 33 + Math.random2(0,3) * 12 +\n        hi[Math.random2(0,hi.size()-1)] ) => s.freq;\n\n    // harmonics\n    Math.random2( 1, 5 ) => s.harmonics;\n\n    // advance time\n    120::ms => now;\n}\n",
                "data": []
            }
        },
        {
            "chirp2.ck": {
                "code": "// more chirping...\n\n// patch with envelope and pan\nSinOsc s => Envelope e => Pan2 p => dac;\n// gain\n.5 => s.gain;\n\n// pan hard left\n-1 => p.pan;\n// call chirp\nchirp( 127, 20, 1::second );\n\n// wait for envelope to go down\n10::ms => now;\n// pan hard right\n1 => p.pan;\n// call chirp\nchirp( 20, 120, 1::second, 100::ms );\n\n// wait a second\n1::second => now;\n\n// randomize pan\nMath.random2f( -1, 1 ) => p.pan;\n// call chirp\nchirp( 30, 110, .5::second );\n\n// wait for envelope to go down\n10::ms => now;\n// pan\nMath.random2f( -1, 1 ) => p.pan;\n// call chirp\nchirp( 110, 30, 1::second, 100::ms );\n\n// wait a second\n1::second => now;\n\n\n// chirp function\nfun void chirp( float src, float target, dur duration )\n{\n    // just call the other one with default tinc\n    chirp( src, target, duration, 1::ms );\n}\n\n\n// chirp function (with tinc)\nfun void chirp( float src, float target, dur duration, dur tinc )\n{\n    // initialize freq\n    src => float freq;\n    // find the number of steps\n    duration / tinc => float steps;\n    // find the inc\n    ( target - src ) / steps => float inc;\n    // counter\n    float count;\n    // set env\n    .01 * duration / second => e.time;\n    // open env\n    1 => e.keyOn;\n\n    // do the actual work over time\n    while( count < steps )\n    {\n        // increment the freq\n        freq + inc => freq;\n        // count\n        1 +=> count;\n\n        // set the freq\n        Std.mtof( freq ) => s.freq;\n\n        // advance time\n        tinc => now;\n    }\n\n    // close env\n    1 => e.keyOff;\n}\n\n",
                "data": []
            }
        },
        {
            "oscillatronx.ck": {
                "code": "//------------------------------------------------------------------\n// name: oscillatronx (oscillator demo)\n// desc: playing all of the different types of oscillator UGens\n//       mixing together different timbres to create a sonic texture\n//\n// author: philipd\n//------------------------------------------------------------------\n\n// scale degrees in semi-tones\n[ 0, 2, 4, 7, 9 ] @=> int f[];\n\n// various oscialltors\nSinOsc s => dac;\nSawOsc saw => dac;\nTriOsc tri => dac;\nPulseOsc pul => dac;\nSqrOsc sqr => dac;\n// FM modulator and carrier\nTriOsc trictrl => SinOsc sintri => dac;\n// interpret input as frequency modulation\n2 => sintri.sync;\n100  => trictrl.gain;\n\n// array of Oscs\n[ s, saw, tri, pul, sqr, trictrl ] @=> Osc oscillators[];\n\n// set gains\n0.2 => s.gain;\n0.1 => saw.gain;\n0.1 => tri.gain;\n0.1 => pul.gain;\n0.1 => sqr.gain;\n0.1 => sintri.gain;\n\n// infinite time-loop\nwhile( true )\n{ \n    // randomize\n    Math.random2(0,7) => int select;\n    // clamp (giving more weight to 5)\n    if( select > 5 ) 5 => select;\n    // generate new frequenc value\n    Std.mtof( f[Math.random2( 0, 4 )] + 60 ) => float newnote;\n    // set frequency\n    newnote => oscillators[select].freq;\n    // wait a bit\n    0.25::second => now;\n    // 10 times\n    repeat(10)\n    {\n        Math.random2f( 0.2, 0.8 ) => trictrl.width;\n        // <<< \"trictrl width:\", trictrl.width() >>>;\n        0.05::second => now;\n    }\n}\n",
                "data": []
            }
        },
        {
            "delay.ck": {
                "code": "// patch\nadc => DelayL delay => dac;\n\n// set delay parameters\n.75::second => delay.max => delay.delay;\n\n// infinite time loop\nwhile( true ) 1::second => now;\n\n",
                "data": []
            }
        },
        {
            "bar.ck": {
                "code": "// point of attack for random otf demo\n\nSinOsc s => dac;\n.2 => s.gain;\n\n// an array: add stuff\n[ 0 ] @=> int hi[];\n\nwhile( true )\n{\n    // change parameters here\n    Std.mtof( 45 + Math.random2(0,0) * 12 +\n        hi[Math.random2(0,hi.size()-1)] ) => s.freq;\n\n    // different rate\n    200::ms => now;\n}\n",
                "data": []
            }
        },
        {
            "tick.ck": {
                "code": "// tick tock\n\n// infinite time loop\nwhile( true )\n{\n    // print now in seconds\n    <<< \"tick:\", (now / second), \"seconds\" >>>; \n    1::second => now;\n}\n",
                "data": []
            }
        },
        {
            "demo0.ck": {
                "code": "// demo0.ck\n// basic demo showing time and duration\n\n5::second + now => time later;\n\nwhile( now < later )\n{\n    <<<now>>>;\n    1::second => now;\n}\n\n<<<now>>>;\n",
                "data": []
            }
        },
        {
            "args.ck": {
                "code": "// shows getting command line arguments\n//    (example run: chuck args:1:2:foo)\n\n// print number of args\n<<< \"number of arguments:\", me.args() >>>;\n\n// print each\nfor( int i; i < me.args(); i++ )\n{\n    <<< \"   \", me.arg(i) >>>;\n}\n",
                "data": []
            }
        },
        {
            "larry.ck": {
                "code": "// run each stooge, or run three stooges concurrently\n// %> chuck moe larry curly\n\n// impulse to filter to dac\nImpulse i => BiQuad f => dac;\n// set the filter's pole radius\n.99 => f.prad; \n// set equal gain zeros\n1 => f.eqzs;\n// initialize float variable\n0.0 => float v;\n// set filter gain\n.5 => f.gain;\n  \n// infinite time-loop   \nwhile( true )\n{\n    // set the current sample/impulse\n    1.0 => i.next;\n    // sweep the filter resonant frequency\n    Std.fabs(Math.sin(v)) * 4000.0 => f.pfreq;\n    // increment v\n    v + .1 => v;\n    // advance time\n    99::ms => now;\n}\n\n",
                "data": []
            }
        },
        {
            "fm2.ck": {
                "code": "// basic FM synthesis using SinOsc (2 => .sync; also see fm3.ck)\n\n// modulator to carrier\nSinOsc m => SinOsc c => dac;\n\n// carrier frequency\n440 => c.freq;\n// modulator frequency\n110 => m.freq;\n// index of modulation\n300 => m.gain;\n\n// phase modulation is FM synthesis (sync is 2)\n2 => c.sync;\n\n// time-loop\nwhile( true ) 1::second => now;\n",
                "data": []
            }
        },
        {
            "demo3.ck": {
                "code": "// demo3.ck\n// super lame\n\n// global gain\nGain g => dac;\n// set gain\n.5 => g.gain;\n\n110.0 => float freq;\n6 => int x;\n\n// loop\nwhile( x > 0 )\n{\n    // connect to gain\n    SinOsc s => g;\n    // change frequency\n    freq => s.freq;\n    freq * 2.0 => freq;\n    // decrement x\n    1 -=> x;\n\n    // advance time by 1 second\n    1::second => now;\n    // disconnect the sinosc\n    s =< g;\n}\n",
                "data": []
            }
        },
        {
            "comb.ck": {
                "code": "// a simple comb filter\n// Ge Wang (gewang@cs.princeton.edu)\n\n// feedforward\nImpulse imp => Gain out => dac;\n// feedback\nout => Delay delay => out;\n\n// our radius\n.99999 => float R;\n// our delay order\n500 => float L;\n// set delay\nL::samp => delay.delay;\n// set dissipation factor\nMath.pow( R, L ) => delay.gain;\n\n// fire impulse\n1 => imp.next;\n\n// advance time\n(Math.log(.0001) / Math.log(R))::samp => now;\n",
                "data": []
            }
        },
        {
            "alarm.ck": {
                "code": "// how long\n2::hour => dur T;\n// frequency\n880 => float f;\n\n// remember\nnow => time start;\nnow + T => time later;\n\n// wait\nwhile( now < later )\n{\n    <<< (T - (now - start)) / second, \"left...\" >>>;\n    1::second => now;\n}\n\n// patch\nSinOsc s => JCRev r => dac;\n.025 => r.mix;\nf => s.freq;\n\n// infinite while loop\nwhile( true )\n{\n    // go\n    1.0 => s.gain;\n    300::ms => now;\n    // stop\n    0.0 => s.gain;\n    300::ms => now;\n}\n",
                "data": []
            }
        },
        {
            "zerox.ck": {
                "code": "// step generator, zero crossing detector, dac\nStep s => ZeroX z => dac;\n1.0 => float v;\n\n// infinite time-loop\nwhile( true )\n{\n    // set the step value\n    v => s.next;\n    // change step value\n    -v => v;\n    // advance time\n    100::ms => now;\n}\n",
                "data": []
            }
        },
        {
            "demo2.ck": {
                "code": "// demo2.ck \n// really lame!\n\n// set the global gain\n.1 => dac.gain;\n\n/*\n// connect\nSinOsc a => dac;\n110.0 => a.freq;\n1::second => now;\nSinOsc b => dac;\n220.0 => b.freq;\n1::second => now;\nSinOsc c => dac;\n440.0 => c.freq;\n1::second => now;\nSinOsc d => dac;\n880.0 => d.freq;\n1::second => now;\nSinOsc e => dac;\n1760.0 => e.freq;\n1::second => now;\n*/\n\nSinOsc oscarray[5];\nfor(0 => int i; i<5; i++) {\n\n\toscarray[i] => dac;\n\tMath.pow(2, i) * 110.0 => oscarray[i].freq;\n\n}\n\n/*\n// disconnect\na =< dac;\n1::second => now;\nb =< dac;\n1::second => now;\nc =< dac;\n1::second => now;\nd =< dac;\n1::second => now;\ne =< dac;\n1::second => now;\n*/\n\nfor(0 => int i; i<5; i++) {\n\n\toscarray[i] =< dac;\n\t1::second => now;\n\t\n}\n\n\n\n\n\n\n\n\n\n\n\n\n",
                "data": []
            }
        },
        {
            "wind.ck": {
                "code": "// noise generator, biquad filter, dac (audio output) \nNoise n => BiQuad f => dac;\n// set biquad pole radius\n.99 => f.prad;\n// set biquad gain\n.05 => f.gain;\n// set equal zeros \n1 => f.eqzs;\n// our float\n0.0 => float t;\n\n// infinite time-loop\nwhile( true )\n{\n    // sweep the filter resonant frequency\n    100.0 + Std.fabs(Math.sin(t)) * 15000.0 => f.pfreq;\n    t + .01 => t;\n    // advance time\n    5::ms => now;\n}\n",
                "data": []
            }
        },
        {
            "curly.ck": {
                "code": "// run each stooge, or run three stooges concurrently\n// %> chuck moe larry curly\n\n// impulse to filter to dac\nImpulse i => BiQuad f => dac;\n// set the filter's pole radius\n.99 => f.prad; \n// set equal gain zeros\n1 => f.eqzs;\n// initialize float variable\n0.0 => float v;\n// set filter gain\n.5 => f.gain;\n  \n// infinite time-loop   \nwhile( true )\n{\n    // set the current sample/impulse\n    1.0 => i.next;\n    // sweep the filter resonant frequency\n    Std.fabs(Math.sin(v)) * 800.0 => f.pfreq;\n    // increment v\n    v + .1 => v;\n    // advance time\n    101::ms => now;\n}\n\n",
                "data": []
            }
        },
        {
            "phasor.ck": {
                "code": "//------------------------------------------------------------------------------\n// name: phasor.ck\n// desc: basic demo using the Phasor UGen to do modulate the width of a PulseOsc\n//\n// The phasor linearly ramps from 0 --> 1 every cycle, and rate can be controlled\n// programmatically. Note: this is *not* intended to be a sound-generating UGen!\n// It is more commonly used to modulate other signals or do lookups in a wavetable.\n// For example, in this demo, the phasor signal modulates the PulseOsc width.\n// \n// Although the phasor signal is the shape of a Sawtooth, it performs no anti-aliasing!\n// For a sawtooth shaped signal, use SawOsc instead.\n//\n// author: azaday\n// date: Spring 2023\n//------------------------------------------------------------------------------\nPhasor phasor => blackhole;\nPulseOsc pulseOsc => dac;\n\n// set phasor to ramp from 0-1 at a frequency of 1hz\n1.0 => phasor.freq;\n\n// set pulseOsc frequency\n440.0 => pulseOsc.freq;\n\nwhile (true) {\n    phasor.last() => pulseOsc.width;\n    1::samp => now;\n}\n",
                "data": []
            }
        },
        {
            "fm.ck": {
                "code": "// FM synthesis by hand\n\n// carrier\nSinOsc c => dac;\n// modulator\nSinOsc m => blackhole;\n\n// carrier frequency\n220 => float cf;\n// modulator frequency\n550 => float mf => m.freq;\n// index of modulation\n200 => float index;\n\n// time-loop\nwhile( true )\n{\n    // modulate\n    cf + (index * m.last()) => c.freq;\n    // advance time by 1 samp\n    1::samp => now;\n}\n",
                "data": []
            }
        },
        {
            "adsr.ck": {
                "code": "// name: adsr.ck\n// desc: an ADSR envelope describes how a sound changes over time.\n//       It's often used in music synthesis to control the volume of\n//       a sound. ADSR stands for Attack, Decay, Sustain, and Release.\n//       Each of these terms describes a different part of the sound's\n//       volume over time. In this example, an ADSR is used to shape\n//       a continuous sine wave into individual notes.\n//\n//          /\\\n//         /  \\_____\n//        /         \\\n//       The general shape of a ADSR envelope.\n//\n//       (A)ttack: This is the initial burst of sound when a note is\n//       played. It's how quickly the volume reaches its maximum level.\n//\n//       (D)ecay: After the attack, the sound level will decrease over\n//       time to a lower level. The decay time is how long it takes for\n//       the sound to reach the sustain level.\n//\n//       (S)ustain: This is the steady state of the sound after the\n//       initial attack and decay. The sound remains at a constant level\n//       as long as the note is held down.\n//\n//       (R)elease: When the note is released, the sound level will drop\n//       back down to zero. The release time is how long it takes for the\n//       sound to fade away completely.\n//\n//       for more info on envelopes and ADSRs see:\n//           https://en.wikipedia.org/wiki/Envelope_(music)#ADSR\n\n// our patch\nSinOsc s => ADSR e => dac;\n\n// set A, D, S, and R\ne.set( 10::ms, 8::ms, .5, 500::ms );\n// (note: A, D, R are durations; S is a number between 0 and 1)\n\n// set gain\n.5 => s.gain;\n\n// infinite time-loop\nwhile( true )\n{\n    // choose freq\n    Math.random2( 32, 96 ) => Std.mtof => s.freq;\n\n    // key on: begin ATTACK\n    // (note: ATTACK automatically transitions to DECAY;\n    //        DECAY automatically transitions to SUSTAIN)\n    e.keyOn();\n    // advance time by 500 ms\n    // (note: this is the duration from the\n    //        beginning of ATTACK to the end of SUSTAIN)\n    500::ms => now;\n    // key off; start RELEASE\n    e.keyOff();\n    // allow the RELEASE to ramp down to 0\n    e.releaseTime() => now;\n\n    // advance time by 300 ms (duration until the next sound)\n    300::ms => now;\n}\n",
                "data": []
            }
        },
        {
            "lfo.ck": {
                "code": "// low-frequency oscillator\n\n// sine wave to blackhole (like dac but no sound)\nSinOsc lfo => blackhole;\n// set period (an alternative to .freq)\n1::second => lfo.period;\n\n// infinite time loop\nwhile( true )\n{\n    // print out last value\n    <<< lfo.last(), \"\" >>>;\n    // advance time\n    50::ms => now;\n}\n",
                "data": []
            }
        },
        {
            "wind2.ck": {
                "code": "// noise generator, biquad filter, dac (audio output) \nNoise n => BiQuad f => dac;\n// set biquad pole radius\n.99 => f.prad;\n// set biquad gain\n.05 => f.gain;\n// set equal zeros \n1 => f.eqzs;\n// our float\n0.0 => float t;\n\n// concurrent control\nfun void wind_gain( )\n{\n    0.0 => float g; \n\n    // time loop to ramp up the gain / oscillate\n    while( true )\n    {\n        Std.fabs( Math.sin( g ) ) => n.gain;\n        g + .001 => g;\n        10::ms => now;\n    }\n}\n\n// run wind_gain on anothre shred\nspork ~ wind_gain();\n\n// infinite time-loop\nwhile( true )\n{\n    // sweep the filter resonant frequency\n    100.0 + Std.fabs(Math.sin(t)) * 15000.0 => f.pfreq;\n    t + .01 => t;\n    // advance time\n    100::ms => now;\n}\n",
                "data": []
            }
        },
        {
            "unchuck.ck": {
                "code": "// noise generator, biquad filter, dac (audio output) \nNoise n => BiQuad f => dac;\n// set biquad pole radius\n.99 => f.prad;\n// set biquad gain\n.025 => f.gain;\n// set equal zeros \n1 => f.eqzs;\n// our float\n0.0 => float t;\n\n3::second + now => time later;\n// time-loop\nwhile( now < later )\n{\n    // sweep the filter resonant frequency\n    100.0 + Std.fabs(Math.sin(t)) * 1000.0 => f.pfreq;\n    t + .05 => t;\n    // advance time\n    100::ms => now;\n}\n\n// unlink the ugen f from dac\nf =< dac;\n\n// let more time pass\n3::second => now;\n\n// relink\nf => dac;\n\n// time-loop\n3::second + now => later;\nwhile( now < later )\n{\n    // resume sweep\n    100.0 + Std.fabs(Math.sin(t)) * 1000.0 => f.pfreq;\n    t + .05 => t;\n    // advance time\n    100::ms => now;    \n}\n",
                "data": []
            }
        },
        {
            "pulse.ck": {
                "code": "//------------------------------------------------------------------------------\n// name: pulse.ck\n// desc: basic demo using PulseOsc UGen to do pulse width modulation\n//\n// This UGen defines an oscillator that uses Pulse Width Modulation (PWM), a\n// process that allows for the control of the width of output pulses while\n// keeping the frequency constant. The on/off ratio of the signal is called the\n// \"duty cycle\". A pulse wave may be thought of as a square wave with adjustable\n// time between cycles. A square wave has a duty cycle of 50% -- alternating\n// between \"on\" and \"off\" in equal proportions. A duty cycle of 75% would mean\n// the pulse signal is \"on\" three times as long as it is \"off\" in one cycle.\n// The PulseOsc UGen can be used to create sound, or to control other signals!\n//\n// author: Alex Han\n// date: Spring 2023\n//------------------------------------------------------------------------------\n\n// connect\nPulseOsc pulse => dac;\n// set gain\npulse.gain( .2 );\n// set frequency\npulse.freq( 110 );\n\n// The key characteristic of PulseOsc is the ability to set the pulse width\n// (i.e. duty cycle). When the pulse wave is used to create sound, varying\n// the duty cycle affects the timbre. This demo shows how the timbre changes\n// significantly with small changes to the pulse width.\n\n// time loop\nwhile( true )\n{\n    for( int i; i < 20; i++ )\n    {\n        // .width() takes a float from 0.0 to 1.0\n        pulse.width( .05 * i );\n        // print\n        chout <= \"current duty cycle: \" <= pulse.width();\n        // floating point equality\n        if( Math.equal( pulse.width(), .5) )\n        {chout <= \" <- this is just a square wave!\";}\n        // newline\n        chout <= IO.newline();\n        // next time step\n        .5::second => now;\n    }\n}\n\n// for more PWM fun...\n// 1) smoothly vary the pulse width (using a small time scale)\n// 2) filter the sound (e.g., with LPF)\n",
                "data": []
            }
        },
        {
            "i-robot.ck": {
                "code": "// take me to your leader (talk into the mic)\n// gewang, prc\n\n// our patch - feedforward part\nadc => Gain g => DelayL d => dac;\nadc => Gain g2 => dac;\n// feedback\nd => Gain g3 => d;\n\n// set parameters\n15::ms => d.delay;\n0.05 => g.gain;\n0.05 => g2.gain;\n0.95 => g3.gain;\n\n// time loop\nwhile( true ) 100::ms => now;\n",
                "data": []
            }
        },
        {
            "tick2.ck": {
                "code": "// tick tock\n\n// wait until the start of the next second\nsecond - (now % second) => now;\n\n// infinite time loop\nwhile( true )\n{\n    // print now in seconds\n    <<< \"tick:\", (now / second) $ int, \"seconds\" >>>; \n    1::second => now;\n}\n",
                "data": []
            }
        },
        {
            "curly++.ck": {
                "code": "// run each stooge, or run three stooges concurrently\n// %> chuck moe++ larry++ curly++\n\n// impulse to filter to dac\nSndBuf i => NRev r => dac;\n\n// load glottal ooo\n\"special:glot_ooo\" => i.read;\n// play \n//5.0 => i.rate;\n.1 => r.mix;\n\n0.0 => float v;\n  \n// infinite time-loop   \nwhile( true )\n{\n    // set the current sample/impulse\n    0 => i.pos;\n    // control gain\n    Math.cos(v) => i.gain;\n    // increment v\n    .05 +=> v;\n    // advance time\n    81.0::ms => now;\n}\n\n\n\n\n",
                "data": []
            }
        }
    ],
    "deep": [
        {
            "thx.ck": {
                "code": "//--------------------------------------------------------------------\n// name: thx.ck\n// desc: emulation of the original THX Deep Note\n//       (by Dr. James Andy Moorer)\n//\n// author: Perry R. Cook (https://www.cs.princeton.edu/~prc/)\n//         Ge Wang (https://ccrma.stanford.edu/~ge/)\n//\n// Perry R. Cook (Jan 8, 2007) -- original ChucK version\n// Ge Wang -- modified final chord to align with original Deep Note\n//         -- added beginning \"chaotic\" section\n//         -- time-driven loops (was counter-driven loops)\n//\n// THX resources from /Artful Design/:\n//     https://artful.design/thx/\n//\n// Andy Moorer's personal account\n//.    http://www.jamminpower.org/THX.html\n//\n// -------------------------------------------------------------------\n// Ge, Fall 2017: from Andy Mooorer:\n// -------------------------------------------------------------------\n// OK - I dug out the original program. Here are the frequency\n// bounds of the cluster:\n// #define LOCLUST 40.0\n// #define HICLUST 350.0\n//\n// I had started with them in a more narrow range, but then \n// widened it. With the randomness, they never get anywhere \n// near the limits.  And here are the pitches in the final\n// chord for all 30 voices:\n//\n// double freqs[NOSCS], initialfreqs[NOSCS],\n// finalfreqs[] =\n// { 1800.0, 1800.0, 1800.0,\n//   1500.0, 1500.0,\n//   1200.0, 1200.0, 1200.0, 1200.0,\n//   900.0, 900.0, 900.0, 900.0,\n//   600.0, 600.0, 600.0,\n//   300.0, 300.0, 300.0, 300.0,\n//   150.0, 150.0, 150.0, 150.0,\n//   75.0, 75.0, 75.0\n//   37.5, 37.5, 37.5,\n// };\n//\n// Note that in the final chord, they are detuned a bit by \n// injecting a bit of randomness to make sure they don't fuse\n// totally. Several people have commented that the chord \n// sounds \"bigger\" than an equivalent orchestra or organ \n// chord (like the big chord in the Bm fugue which was my\n// inspiration). I believe this is because of the just \n// temperament of the chord. Moving the thirds and fifths \n// to equal temperament just doesn't have the same impact. \n//\n// Let me know if you have any other questions. I am really \n// excited to see your new book. It looks like great fun!\n// -A\n//--------------------------------------------------------------------\n \n// 30 target frequencies, corresponding to pitches in a big chord:\n// D1,  D2, D3,  D4,  D5,  A5,  D6,   F#6,  A6\n[ 37.5, 75, 150, 300, 600, 900, 1200, 1500, 1800,\n  37.5, 75, 150, 300, 600, 900, 1200, 1500, 1800,\n  37.5, 75, 150, 300, 600, 900, 1200,       1800,\n            150, 300,      900, 1200  \n] @=> float targets[];\n\n// initial frequencies\nfloat initials[30];\n// for the initial \"wavering\" in the steady state\nfloat initialsBase[30];\nfloat randomRates[30];\n\n// parameters (play with these to control timing)\n12.5::second => dur initialHold; // initial steady segment\n6.0::second => dur sweepTime; // duration over which to change freq\n5.5::second => dur targetHold; // duration to hold target chord\n6.0::second => dur decayTime; // duration for reverb tail to decay to 0\n\n// sound objects\nSawOsc saw[30]; // sawtooth waveform (30 of them)\nGain gainL[30]; // left gain (volume)\nGain gainR[30]; // right gain (volume)\n// connect stereo reverberators to output\nNRev reverbL => dac.left;\nNRev reverbR => dac.right;\n// set the amount of reverb\n0.075 => reverbL.mix => reverbR.mix;\n\n// for each sawtooth: connect, compute frequency trajectory\nfor( 0 => int i; i < 30; i++ )\n{\n    // connect sound objects (left channel)\n    saw[i] => gainL[i] => reverbL;\n    // connect sound objects (right channel)\n    saw[i] => gainR[i] => reverbR;\n    // randomize initial frequencies\n    Math.random2f( 160.0, 360.0 ) => initials[i] \n               => initialsBase[i] => saw[i].freq;\n    // initial gain for each sawtooth generator\n    0.1 => saw[i].gain;\n    // randomize gain (volume)\n    Math.random2f( 0.0, 1.0 ) => gainL[i].gain;\n    // right.gain is 1-left.gain -- effectively panning in stereo\n    1.0 - gainL[i].gain() => gainR[i].gain;\n    // rate at which to waver the initial voices\n    Math.random2f(.1,1) => randomRates[i];\n}\n\n// hold steady cluster (initial chaotic random frequencies)\nnow + initialHold => time end;\n// fade in from silence\nwhile( now < end )\n{\n    // percentage (should go from 0 to 1)\n    1 - (end-now) / initialHold => float progress;\n    // for each sawtooth\n    for( 0 => int i; i < 30; i++ ) {\n        // set gradually decaying values to volume\n        0.1 * Math.pow(progress,3) => saw[i].gain;\n        // waver the voices\n        initialsBase[i] + (1.25-progress)*.5*initialsBase[i]*Math.sin(now/second*randomRates[i])\n             => initials[i] => saw[i].freq;\n    }\n    // advance time\n    10::ms => now;\n}\n\n// when to stop\nnow + sweepTime => end;\n// sweep freqs towards target freqs\nwhile( now < end )\n{\n    // percentage (should go from 0 to 1)\n    1 - (end-now)/sweepTime => float progress;\n    // for each sawtooth\n    for( 0 => int i; i < 30; i++ ) {\n        // update frequency by delta, towards target\n        initials[i] + (targets[i]-initials[i])*progress => saw[i].freq;\n    }\n    // advance time\n    10::ms => now;\n}\n\n// at this point: reached target freqs; briefly hold\ntargetHold => now;\n\n// when to stop\nnow + decayTime => end;\n// chord decay (fade to silence)\nwhile( now < end )\n{\n    // percentage (should go from 1 to 0)\n    (end-now) / decayTime => float progress;\n    // for each sawtooth\n    for( 0 => int i; i < 30; i++ ) {\n        // set gradually decaying values to volume\n        0.1 * progress => saw[i].gain;\n    }\n    // advance time\n    10::ms => now;\n}\n\n// wait for reverb tail before ending\n5::second => now;\n",
                "data": []
            }
        },
        {
            "shepard.ck": {
                "code": "//--------------------------------------------------------------------\n// name: shepard.ck\n// desc: continuous shepard-risset tone generator; \n//       ascending but can easily made to descend\n//\n// author: Ge Wang (https://ccrma.stanford.edu/~ge/)\n//   date: spring 2016\n//--------------------------------------------------------------------\n\n// mean for normal intensity curve\n66 => float MU;\n// standard deviation for normal intensity curve\n42 => float SIGMA;\n// normalize to 1.0 at x==MU\n1 / Math.gauss(MU, MU, SIGMA) => float SCALE;\n// increment per unit time (use negative for descending)\n.004 => float INC;\n// unit time (change interval)\n1::ms => dur T;\n\n// starting pitches (in MIDI note numbers, octaves apart)\n[ 12.0, 24, 36, 48, 60, 72, 84, 96, 108 ] @=> float pitches[];\n// number of tones\npitches.size() => int N;\n// bank of tones\nTriOsc tones[N];\n// overall gain\nGain gain => dac; 1.0/N => gain.gain;\n// connect to dac\nfor( int i; i < N; i++ ) { tones[i] => gain; }\n\n// infinite time loop\nwhile( true )\n{\n    for( int i; i < N; i++ )\n    {\n        // set frequency from pitch\n        pitches[i] => Std.mtof => tones[i].freq;\n        // compute loundess for each tone\n        Math.gauss( pitches[i], MU, SIGMA ) * SCALE => float intensity;\n        // map intensity to amplitude\n        intensity*96 => Math.dbtorms => tones[i].gain;\n        // increment pitch\n        INC +=> pitches[i];\n        // wrap (for positive INC)\n        if( pitches[i] > 120 ) 108 -=> pitches[i];\n        // wrap (for negative INC)\n        else if( pitches[i] < 12 ) 108 +=> pitches[i];\n    }\n    \n    // advance time\n    T => now;\n}\n",
                "data": []
            }
        },
        {
            "plu.ck": {
                "code": "// karplus + strong plucked string filter\n// Ge Wang (gewang@cs.princeton.edu)\n\n// feedforward\nNoise imp => OneZero lowpass => dac;\n// feedback\nlowpass => Delay delay => lowpass;\n\n// our radius\n.99999 => float R;\n// our delay order\n500 => float L;\n// set delay\nL::samp => delay.delay;\n// set dissipation factor\nMath.pow( R, L ) => delay.gain;\n// place zero\n-1 => lowpass.zero;\n\n// fire excitation\n1 => imp.gain;\n// for one delay round trip\nL::samp => now;\n// cease fire\n0 => imp.gain;\n\n// advance time\n(Math.log(.0001) / Math.log(R))::samp => now;\n",
                "data": []
            }
        },
        {
            "dtmf.ck": {
                "code": "// name: dtmf.ck\n// desc: dual tone multiple frequency\n//       (can be played into analog phones to place calls)\n// author: Perry Cook\n\nSinOsc row => dac;\nSinOsc col => dac;\n\n// frequencies\n[1209.0, 1336.0, 1477.0] @=> float cols[];\n[697.0, 770.0, 852.0, 941.0] @=> float rows[];\n\n// if you want to look up by number ( 0 - 9, *, # )\nfun int key2col( int key )\n{ if( !key ) return 1; return (key - 1) % 3; }\nfun int key2row( int key )\n{ if( !key ) return 3; return (key - 1) / 3; }\n\n0 => int i;\nint r,c,n;\n\n// go!\nwhile (i < 7) {\n    .5 => row.gain;\n    .5 => col.gain;\n    Math.random2(0,3) => r;\n    Math.random2(0,2) => c;\n    1 + r * 3 + c => n;\n\n    if (n==11) 0 => n;\n    if (n==10) {\n        <<< r , c, \"*\" >>>;\n    }\n    else if (n==12) {\n        <<< r , c, \"#\" >>>;\n    }\n    else\n        <<< r , c, n >>>;\n\n    rows[r] => row.freq;\n    cols[c] => col.freq;\n\n    0.1 :: second => now;\n    0.0 => row.gain;\n    0.0 => col.gain;\n    0.05 :: second => now;\n    i + 1 => i;\n}\n",
                "data": []
            }
        },
        {
            "ks-chord.ck": {
                "code": "//-----------------------------------------------------------------------------\n// name: ks-chord.ck\n// desc: karplus strong comb filter bank\n//\n// authors: Madeline Huberth (mhuberth@ccrma.stanford.edu)\n//          Ge Wang (ge@ccrma.stanford.edu)\n// date: summer 2014\n//       Stanford Center @ Peking University\n//-----------------------------------------------------------------------------\n\n// single voice Karplus Strong chubgraph\nclass KS extends Chugraph\n{\n    // sample rate\n    second / samp => float SRATE;\n    \n    // ugens!\n    DelayA delay;\n    OneZero lowpass;\n    \n    // noise, only for internal use\n    Noise n => delay;\n    // silence so it doesn't play\n    0 => n.gain;\n    \n    // the feedback\n    inlet => delay => lowpass => delay => outlet;\n    // max delay\n    1::second => delay.max;\n    // set lowpass\n    -1 => lowpass.zero;\n    // set feedback attenuation\n    .9 => lowpass.gain;\n\n    // mostly for testing\n    fun void play( float pitch, dur T )\n    {\n        tune( pitch ) => float length;\n        // turn on noise\n        1 => n.gain;\n        // fill delay with length samples\n        length::samp => now;\n        // silence\n        0 => n.gain;\n        // let it play\n        T-length::samp => now;\n    }\n    \n    // tune the fundamental resonance\n    fun float tune( float pitch )\n    {\n        // computes further pitch tuning for higher pitches\n        pitch - 43 => float diff;\n        0 => float adjust;\n        if( diff > 0 ) diff * .0125 => adjust;\n        // compute length\n        computeDelay( Std.mtof(pitch+adjust) ) => float length;\n        // set the delay\n        length::samp => delay.delay;\n        //return\n        return length;\n    }\n    \n    // set feedback attenuation\n    fun float feedback( float att )\n    {\n        // sanity check\n        if( att >= 1 || att < 0 )\n        {\n            <<< \"set feedback value between 0 and 1 (non-inclusive)\" >>>;\n            return lowpass.gain();\n        }\n\n        // set it        \n        att => lowpass.gain;\n        // return\n        return att;\n    }\n    \n    // compute delay from frequency\n    fun float computeDelay( float freq )\n    {\n        // compute delay length from srate and desired freq\n        return SRATE / freq;\n    }\n}\n\n// chord class for KS\nclass KSChord extends Chugraph\n{\n    // array of KS objects    \n    KS chordArray[4];\n    \n    // connect to inlet and outlet of chubgraph\n    for( int i; i < chordArray.size(); i++ ) {\n        inlet => chordArray[i] => outlet;\n    }\n\n    // set feedback    \n    fun float feedback( float att )\n    {\n        // sanith check\n        if( att >= 1 || att < 0 )\n        {\n            <<< \"set feedback value between 0 and 1 (non-inclusive)\" >>>;\n            return att;\n        }\n        \n        // set feedback on each element\n        for( int i; i < chordArray.size(); i++ )\n        {\n            att => chordArray[i].feedback;\n        }\n\n        return att;\n    }\n    \n    // tune 4 objects\n    fun void tune( float pitch1, float pitch2, float pitch3, float pitch4 )\n    {\n        pitch1 => chordArray[0].tune;\n        pitch2 => chordArray[1].tune;\n        pitch3 => chordArray[2].tune;\n        pitch4 => chordArray[3].tune;\n    }\n}\n\n\n// sound to chord to dac\nSndBuf buffy => KSChord object => dac;\n// load a sound\n\"special:dope\" => buffy.read;\n// set feedback\nobject.feedback( .96 );\n\n// offset\n-12 => int x;\n// tune\nobject.tune( 60+x, 64+x, 72+x, 79+x );\n// loop\nwhile( true )\n{\n    // set playhead to beginning\n    0 => buffy.pos;\n    // set rate\n    1 => buffy.rate;\n    // advance time\n    550::ms / buffy.rate() => now;\n}\n",
                "data": []
            }
        },
        {
            "unclap.ck": {
                "code": "// name: unclap.ck\n// desc: configurable \"clapping music\" (Steve Reich)\n// author: Jesus Gollonet (original)\n//         Ge Wang (shreds and glottal pops)\n// date: Summer 2006\n\n// our patch\nSndBuf clapper1 => dac.left;\nSndBuf clapper2 => dac.right;\n\n// load built-in sounds\n\"special:glot_ahh\" => clapper1.read; 3.0 => clapper1.gain;\n\"special:glot_ahh\" => clapper2.read; 3.0 => clapper2.gain;\n\n// the full \"clapping music\" figure\n[.5, .5, 1, .5, 1, 1, .5, 1 ] @=> float seq[];\n\n// length of quarter note\n.4::second => dur quarter;\n// how many measures per shift\n3 => int shift_period;\n// how much to shift by (in quarter notes)\n.5 => float shift_factor;\n\n// one clapper\nfun void clap( SndBuf buffy, int max, float factor )\n{\n    1 => int shifts;\n\n    // infinite time loop\n    for( ; true; shifts++ )\n    {\n        // one measure\n        for( 0 => int count; count < seq.size(); count++ )\n        {\n            // set gain\n            seq[count] * 2 => buffy.gain;\n            // clap!\n            0 => buffy.pos;\n            // let time go by\n            if( !max || shifts < max || count != (seq.size() - 1) )\n                seq[count]::quarter => now;\n            else\n            {\n                <<< \"shift!!!\", \"\" >>>;\n                seq[count]*factor*quarter => now;\n                0 => shifts;\n            }\n        }\n    }\n}\n\n// spork one clapper, shift every shift_period measures\nspork ~ clap( clapper1, shift_period, shift_factor );\n// spork, no shift\nspork ~ clap( clapper2, 0, 0 );\n\n// infinite time loop\nwhile( true ) 1::day => now;\n",
                "data": []
            }
        },
        {
            "chant.ck": {
                "code": "//--------------------------------------------------------------------\n// name: chant.ck\n// desc: chant synthesizer; demonstrates multi-shredded concurrency,\n//       variable rates, source-filter model, and interpolation.\n//\n// This is a classic source-filter model for rudimentary singing\n// synthesis: an impulse train (the \"source\", crudely modeling\n// opening/closing of the glottis in the vocal tract) going through\n// a bank of three formant filters (roughly modeling the filtering\n// by the vocal cavity to induce the perception of different vowels).\n//\n// This example demonstrates an elegant way to implement the above\n// in ChucK, by breaking up the tasks into three concurrent shreds:\n//   1. a main shred selects the next target pitch and formants\n//   2. doImpulse() generates the impulse train; using ChucK's\n//      strongly-timed mechanisms to modulate the impulse train\n//      period to create vibrato\n//   3. doInterpolation() interpolates the period and formants,\n//      to smoothly glide from note to note, vowel to vowel\n//\n// author: Perry R. Cook (2006)\n//         modified by Rebecca Fiebrink and Ge Wang (2007, 2021)\n//         published in ChucK examples 2021\n//--------------------------------------------------------------------\n\n// synthesis patch\nImpulse i => TwoZero t => TwoZero t2 => OnePole p;\n// formant filters\np => TwoPole f1 => Gain g;\np => TwoPole f2 => g;\np => TwoPole f3 => g;\n// reverbs\ng => JCRev r => dac;\ng => JCRev rL => dac.left;\ng => JCRev rR => dac.right;\n// delays\ng => Delay d1 => Gain g1 => r;\ng => Delay d2 => Gain g2 => rL;\ng => Delay d3 => Gain g3 => rR;\n// connect gains to delays\ng1 => d1; g2 => d2; g3 => d3;\n\n// source gain (amplitude of the impulse train)\n0.25 => float sourceGain;\n\n// set filter coefficients\n1.0 => t.b0;  0.0 => t.b1; -1.0 => t.b2;\n1.0 => t2.b0; 0.0 => t2.b1; 1.0 => t2.b2;\n// set gains\n0.1 => g1.gain;\t0.1 => g2.gain;\t0.1 => g3.gain;\n// set reverb mix\n0.025 => r.mix;\n// set delay max and length\n1.5 :: second => d1.max;\n2.0 :: second => d2.max;\n2.8 :: second => d3.max;\n1.41459 :: second => d1.delay;\n1.97511 :: second => d2.delay;\n2.71793 :: second => d3.delay;\n\n// set two pole filter radii and gain\n0.997 => f1.radius; 0.997 => f2.radius; 0.997 => f3.radius;\n1.0 => f1.gain; 0.8 => f2.gain; 0.6 => f3.gain;\n// randomize initial formant frequencies\nMath.random2f( 230.0, 660.0 ) => f1.freq;\nMath.random2f( 800.0, 2300.0 ) => f2.freq;\nMath.random2f( 1700.0, 3000.0 ) => f3.freq;\n\n// variables for interpolating current and target formant frequencies\n400.0 => float f1freq;\n1000.0 => float f2freq;\n2800.0 => float f3freq;\n400.0 => float target_f1freq;\n1000.0 => float target_f2freq;\n2800.0 => float target_f3freq;\n\n// leaky integrator\n0.99 => p.pole;\n1.0 => p.gain;\n\n// variables that control impulse train source\n0.013 => float period;\n0.013 => float targetPeriod;\n0.0 => float modphase;\n0.0001 => float vibratoDepth;\n\n// scale\n[ 0, 1, 5, 7,\n  8, 11, 8, 7,\n  11, 12, 14, 15,\n  19, 17, 20, 24 ] @=> int scale[];\n// names (for printing)\n[ \"ut0\", \"ra0\", \"fa0\", \"ut0\",\n  \"ra0\", \"mi0\", \"ra1\", \"ut1\", \n  \"mi0\", \"ut1\", \"re1\", \"mi1\", \n  \"ut1\", \"fa1\", \"re1\", \"ut2\" ] @=> string names[];\n// current location in scale\n9 => int scalepoint;\n// frequency\nfloat theFreq;\n\n// spork two concurrent child shreds...\nspork ~ doImpulse(); // generate voice source\nspork ~ doInterpolation( 10::ms ); // interpolate pitch and formants\n\n// main shred loop\nwhile( true )\n{\n    // determine new formant targets\n    Math.random2f( 230.0, 660.0 ) => target_f1freq;\n    Math.random2f( 800.0, 2300.0 ) => target_f2freq;\n    Math.random2f( 1700.0, 3000.0 ) => target_f3freq;\n\n    // next pitch (random walk the scale)\n    Math.random2(-1,1) + scalepoint => scalepoint;\n    if( scalepoint < 0 ) 0 => scalepoint;\n    if( scalepoint > 15 ) 15 => scalepoint;\n    // compute the frequency\n    32 + scale[scalepoint] => Std.mtof => theFreq;\n    // print things for fun\n    <<< names[scalepoint], theFreq >>>;\n    // calculate corresponding target period\n    1.0 / theFreq  => targetPeriod;\n\n    // wait until next note\n    Math.random2f( 0.2, 0.9 )::second => now;\n}\n\n// entry point for shred: generate source impulse train\nfun void doImpulse()\n{\n    // infinite time-loop\n    while( true )\n    {\n        // fire impulse\n        sourceGain => i.next;\n        // phase variable\n        modphase + period => modphase;\n        // vibrato depth\n        .0001 => vibratoDepth;\n        // modulate wait time until next impulse: vibrato\n        (period + vibratoDepth*Math.sin(2*pi*modphase*6.0))::second => now;\n    }\n}\n\n// entry point for shred: interpolate period and formant frequencies\nfun void doInterpolation( dur T )\n{\n    // percentage progress per time slice\n    0.10 => float slew;\n    // infinite time-loop\n    while( true )\n    {\n        // go towards target period (pitch)\n        (targetPeriod - period) * slew + period => period;\n        // go towards targat formant frequencies\n        (target_f1freq - f1freq) * slew + f1freq => f1freq => f1.freq;\n        (target_f2freq - f2freq) * slew + f2freq => f2freq => f2.freq;\n        (target_f3freq - f3freq) * slew + f3freq => f3freq => f3.freq;\n\n        // interpolation rate\n        T => now;\n    }\n}\n",
                "data": []
            }
        },
        {
            "plu3.ck": {
                "code": "// tuned plucked string filter\n// Ge Wang (gewang@cs.princeton.edu)\n\n// feedforward\nNoise imp => OneZero lowpass => PoleZero allpass => dac;\n// feedback\nallpass => Delay delay => lowpass;\n\n// our radius\n.99999 => float R;\n// finding our (integer) delay order\nStd.mtof( 36.5 ) => setFreq => float L;\n// set delay\nL::samp => delay.delay;\n// set dissipation factor\nMath.pow( R, L ) => delay.gain;\n// place zero\n-1 => lowpass.zero;\n\n// fire excitation\n1 => imp.gain;\n// for one delay round trip\nL::samp => now;\n// done\n0 => imp.gain;\n\n// advance time\n(Math.log(.0001) / Math.log(R))::samp => now;\n\n// set (fundamental) freq\nfun int setFreq( float freq )\n{\n    // sample rate\n    second / samp => float SR;\n    // omega\n    2 * pi * freq / SR => float omega;\n    // figure total delay needed\n    SR / freq - .5 => float D;\n    // the integer part\n    D $ int => int Di;\n    // the fraction\n    D - Di => float Df;\n    // set allpass using fractional and fundamental\n    polePos( Df, omega ) => allpass.allpass;\n\n    // return integer portion\n    return Di;\n}\n\n// find pole location from delay and omega\nfun float polePos( float D, float omega )\n{\n    // here it is (a la Jaffe & Smith)\n    return Math.sin( (1-D) * omega / 2 ) / \n           Math.sin( (1+D) * omega / 2 );\n}\n",
                "data": []
            }
        },
        {
            "follower.ck": {
                "code": "// SIMPLE ENVELOPE FOLLOWER, by P. Cook\n\n/*\nHi all.  I keep meaning to post to this list about the under-exploited\nfeature that all unit generators have, in that you can cause their inputs\nto multiply rather than add.  As an example, here's a simple power\nenvelope follower that doesn't require sample-level chuck intervention.  A\ngain UG is used to square the incoming A/D signal (try it on your built-in\nmic), then a OnePole UG is used as a \"leaky integrator\" to keep a running\nestimate of the signal power. The main loop wakes up each 100 ms and\nchecks the power, and prints out a message if it's over a certain level. \nYou might need to change the threshold, but you get the idea.\n*/\n\n// patch\nadc => Gain g => OnePole p => blackhole;\n// square the input\nadc => g;\n// multiply\n3 => g.op;\n\n// set pole position\n0.99 => p.pole;\n\n// loop on\nwhile( true )\n{\n    if( p.last() > 0.01 )\n    {\n        <<< \"BANG!!\" >>>;\n        80::ms => now;\n    }\n    20::ms => now;\n}\n",
                "data": []
            }
        },
        {
            "plu2.ck": {
                "code": "// plucked string filter, different excitation\n// Ge Wang (gewang@cs.princeton.edu)\n\n// feedforward\nSndBuf buffy => PoleZero block => OneZero lowpass => dac;\n// feedback\nlowpass => Delay delay => lowpass;\n\n// our radius\n.99999 => float R;\n// our delay order\n250 => float L;\n// set delay\nL::samp => delay.delay;\n// set dissipation factor\nMath.pow( R, L ) => delay.gain;\n// take out DC and neighborhood\n.999 => block.blockZero;\n// place zero\n-1 => lowpass.zero;\n\n// fire excitation (try other sounds too)\n\"special:mand1\" => buffy.read;\n\n// advance time\n(Math.log(.0001) / Math.log(R))::samp => now;\n",
                "data": []
            }
        },
        {
            "say-chu.ck": {
                "code": "// Fairly silly program to synthesize the\n// word \"chuck\" in ChucK.  Perry Cook, Nov. 2007\n\nTwoPole r[3];\t// Resonators\nNoise n => Envelope ne => r[0] => TwoZero z => Gain gain => dac;\nn => r[1] => z; n => r[2] => z; \nImpulse i => Envelope ie => OnePole o => r[0]; o => r[1]; o => r[2];\n0.99 => o.pole; 10.0 => o.gain; 1.0 => z.b0; 0.0 => z.b1; -1.0 => z.b2;\n\n// louder\n4.0 => gain.gain;\n\n// say\ndoCh();\n1 => int notDone;\ndoUhh();\ndoKay();\n\nfun void doUhh()  {\n    0.1=>ie.time;\n    0.0 => n.gain;\n    600.0 => r[0].freq; 0.995 => r[0].radius; 1.0 => r[0].gain;\n    1500.0 => r[1].freq; 0.995 => r[1].radius; 0.5 => r[1].gain;\n    3900.0 => r[2].freq; 0.99 => r[2].radius; 0.2 => r[2].gain;\n    spork ~ doimpulse();\n    0.4 => i.gain;\n    1.0 => i.gain;\n    1 => ie.keyOn;\n    0.1 :: second => now;\n    1 => ie.keyOff;\n    0.1 :: second => now;\n    0 => notDone;\n}\n\nfun void doCh()  {\n    <<< \"Ch\" >>>;\n    0.03=>ne.time;\n    1900.0 => r[0].freq; 0.99 => r[0].radius; 1.0 => r[0].gain;\n    2700.0 => r[1].freq; 0.99 => r[1].radius; 0.7 => r[1].gain;\n    3200.0 => r[2].freq; 0.99 => r[2].radius; 0.8 => r[2].gain;\n    0.0 => i.gain;\n    0.02 => n.gain;\n    1=>ne.keyOn;0.03 :: second => now;\n    1=>ne.keyOff;0.03 :: second => now;\n}\n\nfun void doKay()  {\n    <<< \"kK\" >>>;\n    0.0 => i.gain;\n    0.05 :: second => now;\n    0.005=>ne.time;\n    0.007 => n.gain;\n    380.0 => r[0].freq; 0.99 => r[0].radius; 0.7 => r[0].gain;\n    1700.0 => r[1].freq; 0.99 => r[1].radius; 1.0 => r[1].gain;\n    4500.0 => r[2].freq; 0.99 => r[2].radius; 0.7 => r[2].gain;\n    1 => ne.keyOn; 0.005 :: second => now;\n    1 => ne.keyOff;0.01=>ne.time; 0.01 :: second => now;\n}\n\nfun void doimpulse()  {\n    150.0 => float freq;\n    <<< \"uhh\" >>>;\n    while (notDone)  {\n        1.0 => i.next;\n        (1.0 / freq) :: second => now;    \n        freq * 0.98 => freq;\n    }\n}\n",
                "data": []
            }
        },
        {
            "dither.ck": {
                "code": "// dither.ck\n// demo of dithering\n//\n// can use any UGen as source in play_with_dither()\n// qbits : number of bits to quantize to\n// do_dither : whether to dither\n//\n// gewang\n\n// patch\nImpulse imp => dac;\n\n// sine wave generator\nSinOsc s => blackhole;\n220 => s.freq;\n\n// go\nplay_with_dither( s, 2::second, 6, false );\nplay_with_dither( s, 2::second, 6, true );\n.5::second => now;\n\nplay_with_dither( s, 2::second, 5, false );\nplay_with_dither( s, 2::second, 5, true );\n.5::second => now;\n\nplay_with_dither( s, 2::second, 4, false );\nplay_with_dither( s, 2::second, 4, true );\n.5::second => now;\n\n// dither\nfun void play_with_dither( UGen src, dur T, int qbits, int do_dither )\n{\n    // sanity check\n    if( qbits <= 0 || qbits > 24 )\n    {\n        <<< \"quantization bits out of range (1-24)\", \"\" >>>;\n        return;\n    }\n\n    // loop\n    float sample;\n    int quantized;\n    (1 << 24) => int max;\n    while( T > 0::second )\n    {\n        // get the last sample\n        src.last() => sample;\n        // quantize it\n        if( do_dither ) // dither\n            ((sample + Math.random2f(0,Math.pow(2,-qbits))) * max) $ int => quantized;\n        else // no dither\n            (sample * max) $ int => quantized;\n        \n        // throw away extra resolution\n        quantized >> (24-qbits) << (24-qbits) => quantized;\n        // cast it back for playback\n        (quantized $ float) / max => imp.next;\n        // advance time\n        1::samp => now;\n        // decrement\n        1::samp -=> T;\n    }\n}\n\n",
                "data": []
            }
        }
    ],
    "stk": [
        {
            "blowhole2.ck": {
                "code": "// patch\nBlowHole hole => dac;\n\n// scale\n[0, 2, 4, 7, 9, 11] @=> int scale[];\n\n// infinite time loop\nwhile( true )\n{\n  // change parameters\n  if( Math.random2f(0,1) > .75 )\n  {\n    Math.random2f( 0, 128 ) => float stiffness;\n    Math.random2f( 0, 128 ) => float noisegain;\n    Math.random2f( 0, 128 ) => float tonehole;\n    Math.random2f( 0, 128 ) => float register;\n    Math.random2f( 0, 128 ) => float pressure;\n\n    <<< \"going...\", \"\" >>>;\n    <<< \"reed stiffness:\", stiffness, \"/ 128.0\" >>>;\n    <<< \"noise gain:\", noisegain, \"/ 128.0\" >>>;\n    <<< \"tonehole state:\", tonehole, \"/ 128.0\" >>>;\n    <<< \"register state:\", register, \"/ 128.0\" >>>;\n    <<< \"breath pressue:\", pressure, \"/ 128.0\" >>>;\n\n    // reed stiffness\n    hole.controlChange( 2, stiffness );\n    // noise gain\n    hole.controlChange( 4, noisegain );\n    // tonehole state\n    hole.controlChange( 11, tonehole );\n    // register state\n    hole.controlChange( 1, register );\n    // breath pressue\n    hole.controlChange( 128, pressure );\n  }\n\n  // set freq\n  scale[Math.random2(0,scale.size()-1)] => int note;\n  33 + Math.random2(0,4)*12 + note => Std.mtof => hole.freq;\n  <<< \"note: \", Std.ftom( hole.freq() ) >>>;\n\n  // go\n  .8 => hole.noteOn;\n\n  // advance time\n  1::second => now;\n}\n",
                "data": []
            }
        },
        {
            "mand-o-matic-simple.ck": {
                "code": "//---------------|\n// mand-o-matic! (simplified version)\n// by: Ge Wang (ge@ccrma.stanford.edu)\n//     Perry R. Cook (prc@cs.princeton.edu)\n//------------------|\n\n// our patch\nMandolin mand => JCRev r => dac;\n// set the gain\n.95 => r.gain;\n// set the reverb mix\n.05 => r.mix;\n\n// scale\n[ 0, 2, 4, 7, 9 ] @=> int scale[];\n\n// our main loop\nwhile( true )\n{\n    // position\n    Math.random2f( 0.2, 0.8 ) => mand.pluckPos;\n    // frequency...\n    scale[Math.random2(0,scale.size()-1)] => int freq;\n    45 + Math.random2(0,3)*12 + freq => Std.mtof => mand.freq;\n    // pluck it!\n    Math.random2f( 0.2, 0.9 ) => mand.pluck;\n    \n    // how much to wait\n    if( Math.random2f(0,1) > .95 ) // long note\n    { 500::ms => now; }\n    else if( Math.random2f(0,1) > .95 ) // short\n    { 250::ms => now; }\n    else if( Math.random2f(0,1) > .05 ) // shorter\n    { .125::second => now; }\n    else // trill\n    {\n        1 => int i => int pick_dir;\n        // how many times\n        4 * Math.random2( 1, 5 ) => int pick;\n        0.0 => float pluck;\n        0.7 / pick => float inc;\n        // time loop\n        for( ; i < pick; i++ )\n        {\n            75::ms => now;\n            Math.random2f(.2,.3) + i*inc => pluck;\n            pluck + -.2 * pick_dir => mand.pluck;\n            // simulate pluck direction\n            !pick_dir => pick_dir;\n        }\n        // let time pass for final pluck\n        75::ms => now;\n    }\n}\n",
                "data": []
            }
        },
        {
            "bowed2.ck": {
                "code": "// patch\nBowed bow => dac;\n\n// scale\n[0, 2, 4, 7, 8, 11] @=> int scale[];\n\n// infinite time loop\nwhile( true )\n{\n    Math.random2f( 0, 128 ) => float pressure;\n    Math.random2f( 0, 128 ) => float position;\n    Math.random2f( 0, 128 ) => float vibratofreq;\n    Math.random2f( 0, 128 ) => float vibratogain;\n    Math.random2f( 0, 128 ) => float volume;\n\n    <<< \"---\", \"\" >>>;\n    <<< \"bow pressure:\", pressure >>>;\n    <<< \"bow position:\", position >>>;\n    <<< \"vibrato freq:\", vibratofreq >>>;\n    <<< \"vibrato gain:\", vibratogain >>>;\n    <<< \"volume:\", volume >>>;\n\n    // bow pressure\n    bow.controlChange( 2, pressure );\n    // bow position\n    bow.controlChange( 4, position );\n    // vibrato freq\n    bow.controlChange( 11, vibratofreq );\n    // vibrato gain\n    bow.controlChange( 1, vibratogain );\n    // volume\n    bow.controlChange( 128, volume );\n\n    // set freq\n    scale[Math.random2(0,scale.size()-1)] + 57 => Std.mtof => bow.freq;\n    // go\n    .8 => bow.noteOn;\n\n    // advance time\n    Math.random2f(.8, 2)::second => now;\n}\n",
                "data": []
            }
        },
        {
            "bowed.ck": {
                "code": "// patch\nBowed bow => dac;\n\n// scale\n[0, 2, 4, 7, 8, 11] @=> int scale[];\n\n// infinite time loop\nwhile( true )\n{\n    // set\n    Math.random2f( 0, 1 ) => bow.bowPressure;\n    Math.random2f( 0, 1 ) => bow.bowPosition;\n    Math.random2f( 0, 12 ) => bow.vibratoFreq;\n    Math.random2f( 0, 1 ) => bow.vibratoGain;\n    Math.random2f( 0, 1 ) => bow.volume;\n\n    // print\n    <<< \"---\", \"\" >>>;\n    <<< \"bow pressure:\", bow.bowPressure() >>>;\n    <<< \"bow position:\", bow.bowPosition() >>>;\n    <<< \"vibrato freq:\", bow.vibratoFreq() >>>;\n    <<< \"vibrato gain:\", bow.vibratoGain() >>>;\n    <<< \"volume:\", bow.volume() >>>;\n\n    // set freq\n    scale[Math.random2(0,scale.size()-1)] + 57 => Std.mtof => bow.freq;\n    // go\n    .8 => bow.noteOn;\n\n    // advance time\n    Math.random2f(.8, 2)::second => now;\n}\n",
                "data": []
            }
        },
        {
            "blowbotl.ck": {
                "code": "// STK BlowBotl\n\n// patch\nBlowBotl bottle => dac;\n\n// scale\n[0, 2, 4, 7, 8, 11] @=> int scale[];\n\n// infinite time loop\nwhile( true )\n{\n    // ding!\n    Math.random2f( 0, 1 ) => bottle.noiseGain;\n    Math.random2f( 0, 12 ) => bottle.vibratoFreq;\n    Math.random2f( 0, 1 ) => bottle.vibratoGain;\n    Math.random2f( 0, 1 ) => bottle.volume;\n\n    // print\n    <<< \"---\", \"\" >>>;\n    <<< \"noise gain:\", bottle.noiseGain() >>>;\n    <<< \"vibrato freq:\", bottle.vibratoFreq() >>>;\n    <<< \"vibrato gain:\", bottle.vibratoGain() >>>;\n    <<< \"volume:\", bottle.volume() >>>;\n\n    // set freq\n    scale[Math.random2(0,scale.size()-1)] + 57 => Std.mtof => bottle.freq;\n    // go\n    .8 => bottle.noteOn;\n\n    // advance time\n    1::second => now;\n}\n",
                "data": []
            }
        },
        {
            "frenchrn-algo2.ck": {
                "code": "// name: frenchrn-algo2.ck\n// desc: FM 4 Operator (TX81Z Algorithm 2) French Horn Demo\n//\n// author: Perry R. Cook\n// date: June 2021, for REPAIRATHON 2021\n//       needs chuck 1.4.1.0 or above\n\n// patch\nFrencHrn f => NRev r => dac;\n// turn down the volume a bit\n.5 => r.gain;\n// reverb mix\n0.07 => r.mix;\n\n// to learn more about FrencHrn, uncomment this:\n// f.help();\n\n36 => Std.mtof => f.freq; // Play an unually low note\n1 => f.noteOn;  second => now;\n1 => f.noteOff;  second => now;\n\n// Test the controllers\n<<< f.controlOne(), f.controlTwo() >>>;\narpeg();\n\n1.0 => f.controlOne;  1.0 => f.controlTwo;\n<<< f.controlOne(), f.controlTwo() >>>;\narpeg();\n\n0.0 => f.controlTwo;\n<<< f.controlOne(), f.controlTwo() >>>;\narpeg();\n\n0.0 => f.controlOne;  1.0 => f.controlTwo;\n<<< f.controlOne(), f.controlTwo() >>>;\narpeg();\n\n//  Now play a proper French Horn solo\n0.5 => f.controlOne; 0.8 => f.controlTwo;\n\n// PBDSL:  Perry's Bizarre Demo Score Language //\n// Integer part is MIDI note#\n// Fractional part is duration\n// If only fractional, then it's a rest duration\n// Negative cause slur or hold (no notOn rearticulation)\n// if MIDI note illegal (>127) then it's vibrato \n[60.2,0.1,65.2,0.05,67.2,0.05,68.7,-69.3,0.1,\n 60.2,0.05,65.25,67.25,68.7,-69.3,0.1,\n 60.2,65.2,67.2,68.4,69.4,71.25,72.2,74.2,72.2,69.2,67.2,65.3,60.3,57.3,53.4,0.2,48.4,0.4,41.9,600.0,-41.9,1] @=> float notes[];\n\n0.0 => float lastNote;\nfor (int i; i < notes.cap()-1; i++) {\n    Std.abs(Std.ftoi(notes[i])) => int note;\n    if (Std.fabs(notes[i]) < 1.0) {\n        Std.fabs(notes[i])::second => now;\n    }\n    else if (notes[i] > 128.0) { // illegal note# = vibrato amt * 10000\n        notes[i]/10000.0 => f.lfoDepth;\n        <<< \"Vibrato!!\", f.lfoDepth() >>>;\n    }\n    else {\n        Std.mtof(note) => f.freq;\n        if (notes[i] > 0.0) {\n            <<< \"New Note:\", note >>>;\n            1 => f.noteOn;\n        }\n        0.8*(Std.fabs(notes[i])-note)::second => now;\n        if (notes[i+1] < 128 & notes[i+1] > 0.0) {\n            1 => f.noteOff;\n        }\n        else <<< \"Slur!\", \"or Hold\" >>> ;\n        0.2*(Std.fabs(notes[i])-note)::second => now;\n    }\n}\n\n// let ring...\n2*second => now;\n\nfun void arpeg() {\n    Std.mtof(48) => f.freq;\n    1 => f.noteOn; second => now; 1 => f.noteOff; 0.2*second => now;\n    Std.mtof(52) => f.freq;\n    1 => f.noteOn; second => now; 1 => f.noteOff; 0.2*second => now;\n    Std.mtof(55) => f.freq;\n    1 => f.noteOn; second => now; 1 => f.noteOff; 0.2*second => now;\n    Std.mtof(60) => f.freq;\n    1 => f.noteOn; second => now; 1 => f.noteOff; 0.2*second => now;\n}\n",
                "data": []
            }
        },
        {
            "mode-o-matic.ck": {
                "code": "//---------------|\n// modal demo\n// based off of mand-o-matic ( master plan ) \n// by : philipd \n// by: Ge Wang (gewang@cs.princeton.edu)\n//     Perry R. Cook (prc@cs.princeton.edu)\n//------------------|\n// our patch\n\nModalBar modey => JCRev r => Echo a => Echo b => Echo c => dac;\n\n// set the gain\n.95 => r.gain;\n// set the reverb mix\n.05 => r.mix;\n// set max delay for echo\n1000::ms => a.max => b.max => c.max;\n// set delay for echo\n750::ms => a.delay => b.delay => c.delay;\n// set the initial effect mix\n0.0 => a.mix => b.mix => c.mix;\n\n<<< \"preset:\", modey.preset() >>>;\n\n// shred to modulate the mix\nfun void echo_Shred( )\n{ \n    0.0 => float decider => float mix => float old => float inc;\n\n    // time loop\n    while( true )\n    {\n        Math.random2f( 0, 1 ) => decider;\n        if( decider < .35 ) 0.0 => mix;\n        else if( decider < .55 ) .08 => mix;\n        else if( decider < .8 ) .5 => mix;\n        else .15 => mix;\n\n        // find the increment\n        (mix-old)/1000.0 => inc; 1000 => int n;\n        // time loop\n        while( n-- )\n        {\n            // set the mix for a, b, c\n            old + inc => old => a.mix => b.mix => c.mix;\n            1::ms => now;\n        }\n        // remember the old\n        mix => old;\n        // let time pass until the next iteration\n        Math.random2(2,6)::second => now;\n    }\n}\n\n// let echo shred go\nspork ~ echo_Shred();\n\n// scale\n[ 0, 2, 4, 7, 9, 11 ] @=> int scale[];\n\n// our main loop\nwhile( true )\n{\n    // presets\n    // note: Math.randomf() returns value between 0 and 1\n    if( Math.randomf() > 0.9 )\n    {\n        Math.random2( 0, 8 ) => modey.preset;\n        <<< \"preset:\", modey.preset() >>>;\n    }\n\n    // position\n    Math.random2f( 0.2, 0.8 ) => modey.strikePosition;\n    // frequency...\n    scale[Math.random2(0,scale.size()-1)] => int freq;\n    Std.mtof( 45 + Math.random2(0,4)*12 + freq ) => modey.freq;\n\n    // pluck it!\n    Math.random2f( 0.2, 0.6 ) => modey.strike;\n\n    // note: Math.randomf() returns value between 0 and 1\n    if( Math.randomf() > 0.8 )\n    { 500::ms => now; }\n    else if( Math.randomf() > .925 )\n    { 250::ms => now; }\n    else if( Math.randomf() > .05 )\n    { .125::second => now; }\n    else\n    {\n        1 => int i => int pick_dir;\n        // how many times\n        4 * Math.random2( 1, 5 ) => int pick;\n        0.0 => float pluck;\n        0.65 / pick => float inc;\n        // time loop\n        for( ; i < pick; i++ )\n        {\n            75::ms => now;\n            Math.random2f(.2,.3) + i*inc => pluck;\n            pluck => modey.stickHardness;\n            pluck + -.2 * pick_dir => modey.strike;\n            // simulate pluck direction\n            !pick_dir => pick_dir;\n        }\n        // let time pass for final pluck\n        75::ms => now;\n    }\n}\n",
                "data": []
            }
        },
        {
            "modalbar2.ck": {
                "code": "// STK ModalBar\n\n// patch\nModalBar bar => dac;\n\n// scale\n[0, 2, 4, 7, 8, 11] @=> int scale[];\n\n// infinite time loop\nwhile( true )\n{\n    // ding!\n    Math.random2( 0, 8 ) => int preset;\n    Math.random2f( 0, 128 ) => float stickHardness;\n    Math.random2f( 0, 128 ) => float strikePosition;\n    Math.random2f( 0, 128 ) => float vibratoGain;\n    Math.random2f( 0, 128 ) => float vibratoFreq;\n    Math.random2f( 0, 128 ) => float volume;\n    Math.random2f( 64, 128 ) => float directGain;\n    Math.random2f( 64, 128 ) => float masterGain;\n\n    bar.controlChange( 2, stickHardness );\n    bar.controlChange( 4, strikePosition );\n    bar.controlChange( 11, vibratoGain );\n    bar.controlChange( 7, vibratoFreq );\n    bar.controlChange( 1, directGain);\n    bar.controlChange( 128, volume );\n    bar.controlChange( 16, preset );\n\n    <<< \"---\", \"\" >>>;\n    <<< \"preset:\", preset >>>;\n    <<< \"stick hardness:\", stickHardness, \"/ 128.0\" >>>;\n    <<< \"strike position:\", strikePosition, \"/ 128.0\" >>>;\n    <<< \"vibrato gain:\", vibratoGain, \"/ 128.0\" >>>;\n    <<< \"vibrato freq:\", vibratoFreq, \"/ 128.0\" >>>;\n    <<< \"volume:\", volume, \"/ 128.0\" >>>;\n    <<< \"direct gain:\", directGain, \"/ 128.0\" >>>;\n    <<< \"master gain:\", masterGain, \"/ 128.0\" >>>;\n\n    // set freq\n\tscale[Math.random2(0,scale.size()-1)] => int winner;\n    57 + Math.random2(0,2)*12 + winner => Std.mtof => bar.freq;\n    // go\n    .8 => bar.noteOn;\n\n    // advance time\n    .5::second => now;\n}\n",
                "data": []
            }
        },
        {
            "subnoise-audio.ck": {
                "code": "//------------------------------------------------------------------------------\n// name: subnoise_audio.ck\n// desc: demo showcasing the subnoise UGen as a white noise audio signal\n// \n// SubNoise generates a random value between [-1, 1] every `rate` audio ticks.\n// You can get/set the rate in code via the .rate() method.\n// This example doubles the subnoise rate every second, up to a max of \n// 2^12 = 4096 ticks. \n// Notice how as `rate` increases, the audio becomes increasingly distorted\n// and lowpassed, becase we are emulating downsampling the original white noise.\n//\n// author: azaday\n// date: Spring 2023\n//------------------------------------------------------------------------------\nSubNoise sn => dac;\n1 => sn.rate;\n\nrepeat (12) {\n    <<< \"subnoise rate: \" + sn.rate() >>>;\n    sn.rate() * 2 => sn.rate;\n    1::second => now;\n}\n",
                "data": []
            }
        },
        {
            "rhodey.ck": {
                "code": "// more music for replicants\n\n// patch\nRhodey voc => JCRev r => Echo a => Echo b => Echo c => dac;\n\n220.0 => voc.freq;\n0.8 => voc.gain;\n.8 => r.gain;\n.2 => r.mix;\n1000::ms => a.max => b.max => c.max;\n750::ms => a.delay => b.delay => c.delay;\n.50 => a.mix => b.mix => c.mix;\n\n// shred to modulate the mix\nfun void vecho_Shred( )\n{\n    0.0 => float decider;\n    0.0 => float mix;\n    0.0 => float old;\n    0.0 => float inc;\n    0 => int n;\n\n    // time loop\n    while( true )\n    {\n        Math.random2f( 0, 1 ) => decider;\n        if( decider < .3 ) 0.0 => mix;\n        else if( decider < .6 ) .08 => mix;\n        else if( decider < .8 ) .5 => mix;\n        else .15 => mix;\n\n        // find the increment\n        (mix-old)/1000.0 => inc;\n        1000 => n;\n        while( n-- )\n        {\n            old + inc => old;\n            old => a.mix => b.mix => c.mix;\n            1::ms => now;\n        }\n        mix => old;\n        Math.random2(2,6)::second => now;\n    }\n}\n\n\n// let echo shred go\nspork ~ vecho_Shred();\n\n// scale\n[ 0, 2, 4, 7, 9 ] @=> int scale[];\n\n// our main loop\nwhile( true )\n{ \n    // pentatonic\n    scale[Math.random2(0,scale.size()-1)] => int freq;\n\n    Std.mtof( ( 33 + Math.random2(0,1) * 12 + freq ) ) => voc.freq;\n    Math.random2f( 0.6, 0.8 ) => voc.noteOn;\n\n    // note: Math.randomf() returns value between 0 and 1\n    if( Math.randomf() > 0.85 )\n    { 1000::ms => now; }\n    else if( Math.randomf() > .85 )\n    { 500::ms => now; }\n    else if( Math.randomf() > .1 )\n    { .250::second => now; }\n    else\n    {\n        0 => int i;\n        2 * Math.random2( 1, 3 ) => int pick;\n        0 => int pick_dir;\n        0.0 => float pluck;\n\n        for( ; i < pick; i++ )\n        {\n            Math.random2f(.4,.6) + i*.035 => pluck;\n            pluck + -0.02 * (i * pick_dir) => voc.noteOn;\n            !pick_dir => pick_dir;\n            250::ms => now;\n        }\n    }\n}\n",
                "data": []
            }
        },
        {
            "mand-o-matic.ck": {
                "code": "//---------------|\n// mand-o-matic!\n// by: Ge Wang (gewang@cs.princeton.edu)\n//     Perry R. Cook (prc@cs.princeton.edu)\n//------------------|\n\n// our patch\nMandolin mand => JCRev r => Echo a => Echo b => Echo c => dac;\n// set the gain\n.95 => r.gain;\n// set the reverb mix\n.05 => r.mix;\n// set max delay for echo\n1000::ms => a.max => b.max => c.max;\n// set delay for echo\n750::ms => a.delay => b.delay => c.delay;\n// set the initial effect mix\n0.0 => a.mix => b.mix => c.mix;\n\n// scale\n[ 0, 2, 4, 7, 9 ] @=> int scale[];\n\n// shred to modulate the mix\nfun void echo_Shred( )\n{\n    0.0 => float decider => float mix => float old => float inc;\n\n    // time loop\n    while( true )\n    {\n        Math.random2f( 0, 1 ) => decider;\n        if( decider < .35 ) 0.0 => mix;\n        else if( decider < .55 ) .08 => mix;\n        else if( decider < .8 ) .5 => mix;\n        else .15 => mix;\n\n        // find the increment\n        (mix-old)/1000.0 => inc; 1000 => int n;\n        // time loop\n        while( n-- )\n        {\n            // set the mix for a, b, c\n            old + inc => old => a.mix => b.mix => c.mix;\n            1::ms => now;\n        }\n        // remember the old\n        mix => old;\n        // let time pass until the next iteration\n        Math.random2(2,6)::second => now;\n    }\n}\n\n// let echo shred go\nspork ~ echo_Shred();\n\n// our main loop\nwhile( true )\n{\n    // position\n    Math.random2f( 0.2, 0.8 ) => mand.pluckPos;\n    // frequency...\n    scale[Math.random2(0,scale.size()-1)] => int freq;\n    220.0 * Math.pow( 1.05946, (Math.random2(0,2)*12) + freq ) => mand.freq;\n    // pluck it!\n    Math.random2f( 0.2, 0.9 ) => mand.pluck;\n\n    // note: Math.randomf() returns value between 0 and 1\n    if( Math.randomf() > 0.9 )\n    { 500::ms => now; }\n    else if( Math.randomf() > .925 )\n    { 250::ms => now; }\n    else if( Math.randomf() > .05 )\n    { .125::second => now; }\n    else\n    {\n        1 => int i => int pick_dir;\n        // how many times\n        4 * Math.random2( 1, 5 ) => int pick;\n        0.0 => float pluck;\n        0.7 / pick => float inc;\n        // time loop\n        for( ; i < pick; i++ )\n        {\n            75::ms => now;\n            Math.random2f(.2,.3) + i*inc => pluck;\n            pluck + -.2 * pick_dir => mand.pluck;\n            // simulate pluck direction\n            !pick_dir => pick_dir;\n        }\n        // let time pass for final pluck\n        75::ms => now;\n    }\n}\n",
                "data": []
            }
        },
        {
            "moog.ck": {
                "code": "// STK ModalBar\n\n// patch\nMoog moog => dac;\n\n// scale\n[0, 2, 4, 7, 8, 11] @=> int scale[];\n\n// infinite time loop\nwhile( true )\n{\n    // ding!\n    Math.random2f( 0, 1 ) => moog.filterQ;\n    Math.random2f( 0, 1 ) => moog.filterSweepRate;\n    Math.random2f( 0, 12 ) => moog.lfoSpeed;\n    Math.random2f( 0, 1 ) => moog.lfoDepth;\n    Math.random2f( 0, 1 ) => moog.volume;\n\n    // print\n    <<< \"---\", \"\" >>>;\n    <<< \"filterQ\", moog.filterQ() >>>;\n    <<< \"filter sweep rate:\", moog.filterSweepRate() >>>;\n    <<< \"lfo speed:\", moog.lfoSpeed() >>>;\n    <<< \"lfo depth:\", moog.lfoDepth() >>>;\n    <<< \"volume:\", moog.volume() >>>;\n\n    // set freq\n    scale[Math.random2(0,scale.size()-1)] => int winner;\n    57 + Math.random2(0,2)*12 + winner => Std.mtof => moog.freq;\n\n    // go\n    .8 => moog.noteOn;\n\n    // advance time\n    .5::second => now;\n}\n",
                "data": []
            }
        },
        {
            "wurley2.ck": {
                "code": "// even more music for replicants\n\n// patch\nWurley voc=> JCRev r => Echo a => Echo b => Echo c => dac;\n\n// initial settings\n220.0 => voc.freq;\n0.95 => voc.gain;\n.8 => r.gain;\n.1 => r.mix;\n1000::ms => a.max => b.max => c.max;\n750::ms => a.delay => b.delay => c.delay;\n.50 => a.mix => b.mix => c.mix;\n\n// shred to modulate the mix\nfun void vecho_Shred( )\n{\n    0.0 => float decider;\n    0.0 => float mix;\n    0.0 => float old;\n    0.0 => float inc;\n    0 => int n;\n\n    // time loop\n    while( true )\n    {\n        Math.random2f(0.0,1.0) => decider;\n        if( decider < .3 ) 0.0 => mix;\n        else if( decider < .6 ) .08 => mix;\n        else if( decider < .8 ) .5 => mix;\n        else .15 => mix;\n\n        // find the increment\n        (mix-old)/1000.0 => inc;\n        1000 => n;\n        while( --n )\n        {\n            old + inc => old;\n            old => a.mix => b.mix => c.mix;\n            1::ms => now;\n        }\n        mix => old;\n        Math.random2(2,6)::second => now;\n    }\n}\n\n// let echo shred go\nspork ~ vecho_Shred();\n\n// scale\n[ 0, 3, 7, 8, 11 ] @=> int scale[];\n\n// our main time loop\nwhile( true )\n{\n    // scale\n    scale[Math.random2(0,scale.size()-1)] => int freq;\n    Std.mtof( ( 45 + Math.random2(0,1) * 12 + freq ) ) => voc.freq;\n    Math.random2f( 0.6, 0.8 ) => voc.noteOn;\n\n    // note: Math.randomf() return values between 0 and 1\n    if( Math.randomf() > 0.85 )\n    { 1000::ms => now; }\n    else if( Math.randomf() > .85 )\n    { 500::ms => now; }\n    else if( Math.randomf() > .1 )\n    { .250::second => now; }\n    else\n    {\n        0 => int i;\n        2 * Math.random2( 1, 3 ) => int pick;\n        0 => int pick_dir;\n        0.0 => float pluck;\n\n        for( ; i < pick; i++ )\n        {\n            Math.random2f(.4,.6) + i*.035 => pluck;\n            pluck + 0.03 * (i * pick_dir) => voc.noteOn;\n            !pick_dir => pick_dir;\n            250::ms => now;\n        }\n    }\n}\n",
                "data": []
            }
        },
        {
            "stif-o-karp.ck": {
                "code": "//---------------|\n// karp-o-matic!\n// by: Ge Wang (gewang@cs.princeton.edu)\n//     Perry R. Cook (prc@cs.princeton.edu)\n//------------------|\n\n// our patch\nStifKarp karp => JCRev r => Echo a => Echo b => Echo c => dac;\n// set the gain\n.95 => r.gain;\n// set the reverb mix\n.02 => r.mix;\n// set max delay for echo\n1000::ms => a.max => b.max => c.max;\n// set delay for echo\n750::ms => a.delay => b.delay => c.delay;\n// set the initial effect mix\n0.0 => a.mix => b.mix => c.mix;\n\n// shred to modulate the mix\nfun void echo_Shred( )\n{\n    0.0 => float decider => float mix => float old => float inc;\n\n    // time loop\n    while( true )\n    {\n        Math.random2f(0.0,1.0) => decider;\n        if( decider < .35 ) 0.0 => mix;\n        else if( decider < .55 ) .08 => mix;\n        else if( decider < .8 ) .5 => mix;\n        else .15 => mix;\n\n        // find the increment\n        (mix-old)/1000.0 => inc; 1000 => int n;\n        // time loop\n        while( n-- )\n        {\n            // set the mix for a, b, c\n            old + inc => old => a.mix => b.mix => c.mix;\n            1::ms => now;\n        }\n        // remember the old\n        mix => old;\n        // let time pass until the next iteration\n        Math.random2(2,6)::second => now;\n    }\n}\n\n// let echo shred go\nspork ~ echo_Shred();\n\n// scale\n[ 0, 2, 4, 7, 9 ] @=> int scale[];\n\n// our main loop\nwhile( true )\n{\n    // position\n    Math.random2f( 0.2, 0.8 ) => karp.pickupPosition;\n    // frequency...\n    scale[Math.random2(0,scale.size()-1)] => int freq;\n    220.0 * Math.pow( 1.05946, (Math.random2(0,2)*12)\n                      +freq ) => karp.freq;\n    // pluck it!\n    0.0 => karp.stretch;\n    Math.random2f( 0.2, 0.9 ) => karp.pluck;\n\n    // note: Math.randomf() return value between 0 and 1\n    if( Math.randomf() > 0.9 )\n    { 500::ms => now; }\n    else if( Math.randomf() > .925 )\n    { 250::ms => now; }\n    else if( Math.randomf() > .05 )\n    { .125::second => now; }\n    else\n    {\n        1 => int i => int pick_dir;\n        // how many times\n        4 * Math.random2( 1, 5 ) => int pick;\n        0.0 => float pluck;\n        0.7 / pick => float inc;\n        // time loop\n        for( ; i < pick; i++ )\n        {\n            75::ms => now;\n            Math.random2f(.2,.3) + i*inc => pluck;\n            i * 0.025 => karp.stretch;\n            pluck + -.2 * pick_dir => karp.pluck;\n            // simulate pluck direction\n            !pick_dir => pick_dir;\n        }\n        // let time pass for final pluck\n        75::ms => now;\n    }\n}\n",
                "data": []
            }
        },
        {
            "modalbar.ck": {
                "code": "// STK ModalBar\n\n// patch\nModalBar bar => dac;\n\n// scale\n[0, 2, 4, 7, 8, 11] @=> int scale[];\n\n// infinite time loop\nwhile( true )\n{\n    // ding!\n    Math.random2( 0, 8 ) => bar.preset;\n    Math.random2f( 0, 1 ) => bar.stickHardness;\n    Math.random2f( 0, 1 ) => bar.strikePosition;\n    Math.random2f( 0, 1 ) => bar.vibratoGain;\n    Math.random2f( 0, 60 ) => bar.vibratoFreq;\n    Math.random2f( 0, 1 ) => bar.volume;\n    Math.random2f( .5, 1 ) => bar.directGain;\n    Math.random2f( .5, 1 ) => bar.masterGain;\n\n    // print\n    <<< \"---\", \"\" >>>;\n    <<< \"preset:\", bar.preset() >>>;\n    <<< \"stick hardness:\", bar.stickHardness() >>>;\n    <<< \"strike position:\", bar.strikePosition() >>>;\n    <<< \"vibrato gain:\", bar.vibratoGain() >>>;\n    <<< \"vibrato freq:\", bar.vibratoFreq() >>>;\n    <<< \"volume:\", bar.volume() >>>;\n    <<< \"direct gain:\", bar.directGain() >>>;\n    <<< \"master gain:\", bar.masterGain() >>>;\n\n    // set freq\n\tscale[Math.random2(0,scale.size()-1)] => int winner;\n    57 + Math.random2(0,2)*12 + winner => Std.mtof => bar.freq;\n    // go\n    .8 => bar.noteOn;\n\n    // advance time\n    .5::second => now;\n}\n",
                "data": []
            }
        },
        {
            "shake-cycle.ck": {
                "code": "// shake-cycle.ck : effects abuse\n// author: Adam Tindale\n\n// the patch\n// Shakers s => Chorus c1 => JCRev rev => Chorus c2 => Chorus c3 =>dac;\nShakers s => dac;\n\n0 => s.which;\n1 => s.gain;\n100 => float theTime;\n\nwhile( true )\n{\n    1.0 => s.noteOn;\n    theTime::ms => now;\n\n    1.0 => s.noteOff;\n    theTime::ms => now;   \n\n    ( s.which() + 1 ) % 20 => s.which;\n    Math.random2f( 20, 140 ) => theTime;\n}\n",
                "data": []
            }
        },
        {
            "honkeytonk-algo3.ck": {
                "code": "// name: hevymetl-acoustic-algo3.ck\n// desc: how to turn HnkyTonk (Algorithm 3) into an acoustic guitar!!\n//       now you can transcribe almost directly from a TX81 Patch!!!\n//\n// author: Perry R. Cook\n// date: June 2021, for REPAIRATHON 2021\n//       needs chuck 1.4.1.0 or above\n\nHnkyTonk g; // instance for shorthand, you'll see...\nHnkyTonk guit[6];\nNRev r => dac;  \n0.15 => r.gain; 0.07 => r.mix;\n\n[0,0,0,0] @=> int waveForms[];\n[97,71,77,81] @=> int opGains[];\n[1.0,3.0,3.02,8.0] @=> float ratios[];\n[31,28,31,31] @=> int attacks[];\n[18,6,10,9] @=> int decays[];\n[14,1,0,0] @=> int sustains[]; // 15,0,0,0 ???\n[8,8,9,6] @=> int releases[];\n\nfor( int i; i < 6; i++ )\n{\n    guit[i] => r;\n\n    for( int op; op < 4; op++ )\n    {\n        guit[i].opWave( op,1 );  // sine waves all\n        guit[i].opGain( op,g.getFMTableGain(opGains[op]) );\n        guit[i].opADSR( op,\tg.getFMTableTime(attacks[op]),\n                            g.getFMTableTime(decays[op]),\n                            g.getFMTableSusLevel(sustains[op]),\n                            g.getFMTableTime(releases[op]) );\n        guit[i].opRatio( op,ratios[op] );    \n        guit[i].lfoDepth( 0.0 );\n    }\n}\n\n[38,45,50,55,59,64] @=> int DTuning[];\n[38,45,50,57,62,66] @=> int DMaj[];\n[40,47,52,55,59,64] @=> int Emi[];\n\nslowStrum(DTuning, 0.8);\nsecond * 1 => now;\nallOff();\nsecond/2 => now;\n\n0.2::second => dur E;\nfor( int i; i < 4; i++ )\n{\n    spork ~ fastStrum(Emi,1.0); 2*E => now;\n    fastUp(Emi,0.95); E/4 => now; allOff(); 3*E/4 => now; \n    spork ~ fastStrum(Emi,0.97); 2*E => now;\n    fastUp(Emi,0.8); E/4 => now; allOff(); 3*E/4 => now; \n    spork ~ fastStrum(Emi,0.95); 2*E => now;\n    fastUp(Emi,0.9); E/4 => now; allOff(); 3*E/4 => now; \n    spork ~ fastStrum(Emi,0.93); 2*E => now;\n    fastUp(Emi,0.9); E/4 => now; allOff(); 3*E/4 => now; \n    spork ~ fastStrum(DMaj,1.0); E => now; allOff(); E => now;\n    spork ~ fastStrum(DMaj,0.9); E => now;\n    if (maybe) { allOff(); }\n    else { spork ~ fastStrum(DMaj,0.8); }\n    E => now;\n}\n\nslowStrum(Emi,0.8);\n2*second => now;\nallOff();\nsecond => now;\n\nfun void allOff() {\n    for (int i; i < 6; i++) 1 => guit[i].noteOff;\n}\n\nfun void slowStrum( int chord[], float vel) {\n    for (int i; i < 6; i++) {\n        Std.mtof(chord[i]) => guit[i].freq;\n        vel => guit[i].noteOn;\n        Math.random2f(0.05,0.15)::second => now;\n    }\n}\n\nfun void fastStrum( int chord[], float vel) {\n    for (int i; i < 6; i++) {\n        Std.mtof(chord[i]) => guit[i].freq;\n        vel => guit[i].noteOn;\n        Math.random2f(0.005,0.02)::second => now;\n    }\n}\n\nfun void fastUp( int chord[], float vel) {\n    for (int i; i < 6; i++) {\n        Std.mtof(chord[5-i]) => guit[5-i].freq;\n        vel => guit[5-i].noteOn;\n        // Math.random2f(0.001,0.005)::second => now;\n    }\n}\n\n",
                "data": []
            }
        },
        {
            "mandolin.ck": {
                "code": "// STK Mandolin\n\n// patch\nMandolin m => JCRev r => dac;\n.75 => r.gain;\n.025 => r.mix;\n\n// our notes\n[ 61, 63, 65, 66, 68, 66, 65, 63 ] @=> int notes[];\n\n// infinite time-loop\nwhile( true )\n{\n    // set\n    Math.random2f( 0, 1 ) => m.bodySize;\n    Math.random2f( 0, 1 ) => m.pluckPos;\n    // Math.random2f( 0, 1 ) => m.stringDamping;\n    // Math.random2f( 0, 1 ) => m.stringDetune;\n\n    // print\n    <<< \"---\", \"\" >>>;\n    <<< \"body size:\", m.bodySize() >>>;\n    <<< \"pluck position:\", m.pluckPos() >>>;\n    <<< \"string damping:\", m.stringDamping() >>>;\n    <<< \"string detune:\", m.stringDetune() >>>;\n\n    // factor\n    Math.random2f( 1, 4 ) => float factor;\n\n    for( int i; i < notes.size(); i++ )\n    {\n        play( Math.random2(0,2)*12 + notes[i], Math.random2f( .6, .9 ) );\n        100::ms * factor => now;\n    }\n}\n\n// basic play function (add more arguments as needed)\nfun void play( float note, float velocity )\n{\n    // start the note\n    Std.mtof( note ) => m.freq;\n    velocity => m.pluck;\n}\n",
                "data": []
            }
        },
        {
            "bandedwg2.ck": {
                "code": "// STK BandedWG\n\n// patch\nBandedWG bwg => dac;\n\n// scale\n[0, 2, 4, 7, 8, 11] @=> int scale[];\n\n// infinite time loop\nwhile( true )\n{\n    // ding!\n    Math.random2f( 0, 1 ) => bwg.pluck;\n    Math.random2f( 0, 128 ) => float bowPressure;\n    Math.random2f( 0, 128 ) => float bowMotion;\n    Math.random2f( 0, 128 ) => float strikePosition;\n    Math.random2f( 0, 128 ) => float vibratoFreq;\n    Math.random2f( 0, 128 ) => float gain;\n    Math.random2f( 0, 128 ) => float bowVelocity;\n    Math.random2f( 0, 128 ) => float setStriking;\n    Math.random2f( 0, 3 ) => float preset;\n\n    Math.random2f( 0, 1) => bwg.bowRate;\n\n    bwg.controlChange( 2, bowPressure);\n    bwg.controlChange( 4, bowMotion);\n    bwg.controlChange( 8, strikePosition);\n    bwg.controlChange( 11, vibratoFreq);\n    bwg.controlChange( 1, gain);\n    bwg.controlChange( 128, bowVelocity);\n    bwg.controlChange( 64, setStriking);\n\t\n    <<< \"---\", \"\" >>>;\n    <<< \"strike position:\", bwg.strikePosition() >>>;\n    <<< \"bow rate:\", bwg.bowRate() >>>;\n    <<< \"bow Pressure:\", bwg.bowPressure() >>>;\n\n    // set freq\n    scale[Math.random2(0,scale.size()-1)] => int winner;\n    57 + Math.random2(0,2)*12 + winner => Std.mtof => bwg.freq;\n    // go\n    .8 => bwg.noteOn;\n\n    // advance time\n    1::second => now;\n    1.0 => bwg.noteOff;\n    .5::second => now;\n\n    <<< \"pluck -> bow\", \"\" >>>;\n\n    .8 => bwg.startBowing;\n    1::second => now;\n    1.0 => bwg.stopBowing;\n\n    <<< \"--\", \"\" >>>;\n    bwg.controlChange(16, Math.random2(0, 3));\n\n    <<< \"preset:\", bwg.preset() >>>;    \n    <<< \"strike position:\", bwg.strikePosition() >>>;\n    <<< \"bow rate:\", bwg.bowRate() >>>;\n    <<< \"bow Pressure:\", bwg.bowPressure() >>>;\n\n    // set freq\n    57 + Math.random2(0,2)*12 + winner => Std.mtof => bwg.freq;\n    // go\n    .8 => bwg.noteOn;\n\n    // advance time\n    1::second => now;\n    1.0 => bwg.noteOff;\n    .5::second => now;\n\n    <<< \"pluck -> bow\", \"\" >>>;\n\n    .8 => bwg.startBowing;\n    1::second => now;\n    1.0 => bwg.stopBowing;\n}\n",
                "data": []
            }
        },
        {
            "sitar.ck": {
                "code": "// patch\nSitar sit => PRCRev r => dac;\n.05 => r.mix;\n\n// time loop\nwhile( true )\n{\n    // freq\n    Math.random2( 0, 11 ) => float winner;\n    Std.mtof( 57 + Math.random2(0,3) * 12 + winner ) => sit.freq;\n\n    // pluck!\n    Math.random2f( 0.4, 0.9 ) => sit.noteOn;\n\n    // advance time\n    // note: Math.randomf() returns value between 0 and 1\n    if( Math.randomf() > .5 ) {\n        .5::second => now;\n    } else { \n        0.25::second => now;\n    }\n}\n",
                "data": []
            }
        },
        {
            "wurley3.ck": {
                "code": "// polyphonic wurley's\n// (also see ../midi/polyfony.ck for more polyfony)\n\n// the size of the array should be the max number of wurlies\n// you want to play simultaneously, at any point.\nWurley wurlies[3];\n// variable to remember the last one played\nint which;\n\n// patch\nGain g => dac;\n.4 => g.gain;\n// connect the wurlies\nfor( int i; i < wurlies.size(); i++ )\n    wurlies[i] => g;\n\n// our notes\n[ 61, 63, 65, 66, 68 ] @=> int notes[];\n\n// infinite time-loop\nwhile( true )\n{\n    for( int i; i < notes.size(); i++ )\n    {\n        play( notes[i], Math.random2f( .3, .9 ) );\n        300::ms => now;\n    }\n}\n\n// basic play function (add more arguments as needed)\nfun void play( float note, float velocity )\n{\n    // first figure which to play\n    // round robin may work\n    ( which + 1 ) % wurlies.size() => which;\n\n    // start the note\n    Std.mtof( note ) => wurlies[which].freq;\n    velocity => wurlies[which].noteOn;\n}\n",
                "data": []
            }
        },
        {
            "clarinet.ck": {
                "code": "// STK Clarinet\n// (also see examples/event/polyfony2.ck)\n\n// patch\nClarinet clair => JCRev r => dac;\n.75 => r.gain;\n.1 => r.mix;\n\n// our notes\n[ 61, 63, 65, 66, 68, 66, 65, 63, 61 ] @=> int notes[];\n\n// infinite time-loop\nwhile( true )\n{\n    // clear\n    clair.clear( 1.0 );\n\n    // set\n    Math.random2f( 0, 1 ) => clair.reed;\n    Math.random2f( 0, 1 ) => clair.noiseGain;\n    Math.random2f( 0, 12 ) => clair.vibratoFreq;\n    Math.random2f( 0, 1 ) => clair.vibratoGain;\n    Math.random2f( 0, 1 ) => clair.pressure;\n\n    // print\n    <<< \"---\", \"\" >>>;\n    <<< \"reed stiffness:\", clair.reed() >>>;\n    <<< \"noise gain:\", clair.noiseGain() >>>;\n    <<< \"vibrato freq:\", clair.vibratoFreq() >>>;\n    <<< \"vibrato gain:\", clair.vibratoGain() >>>;\n    <<< \"breath pressure:\", clair.pressure() >>>;\n\n    for( int i; i < notes.size(); i++ )\n    {\n        play( 12 + notes[i], Math.random2f( .6, .9 ) );\n        300::ms => now;\n    }\n}\n\n// basic play function (add more arguments as needed)\nfun void play( float note, float velocity )\n{\n    // start the note\n    Std.mtof( note ) => clair.freq;\n    velocity => clair.noteOn;\n}\n",
                "data": []
            }
        },
        {
            "shake-o-matic.ck": {
                "code": "//---------------|\n// shake-o-matic!\n// by: Ge Wang (gewang@cs.princeton.edu)\n//     Perry R. Cook (prc@cs.princeton.edu)\n//------------------|\n\n// our patch\nShakers shake => JCRev r => dac;\n// set the gain\n//.95 => r.gain;\n// set the reverb mix\n.025 => r.mix;\n\n// our main loop\nwhile( true )\n{\n    // frequency..\n    // note: Math.randomf() returns value between 0 and 1\n    if( Math.randomf() > 0.625 )\n    {\n        Math.random2( 0, 22 ) => shake.which;\n        Std.mtof( Math.random2f( 0.0, 128.0 ) ) => shake.freq;\n        Math.random2f( 0, 128 ) => shake.objects;\n        <<< \"instrument #:\", shake.which(), shake.freq(), shake.objects() >>>;\n    }\n\n    // shake it!\n    Math.random2f( 0.8, 1.3 ) => shake.noteOn;\n\n    // note: Math.randomf() returns value between 0 and 1\n    if( Math.randomf() > 0.9 )\n    { 500::ms => now; }\n    else if( Math.randomf() > .925 )\n    { 250::ms => now; }\n    else if( Math.randomf() > .05 )\n    { .125::second => now; }\n    else\n    {\n        1 => int i => int pick_dir;\n        // how many times\n        4 * Math.random2( 1, 5 ) => int pick;\n        0.0 => float pluck;\n        0.7 / pick => float inc;\n        // time loop\n        for( ; i < pick; i++ )\n        {\n            75::ms => now;\n            Math.random2f(.2,.3) + i*inc => pluck;\n            pluck + -.2 * pick_dir => shake.noteOn;\n            // simulate pluck direction\n            !pick_dir => pick_dir;\n        }\n\n        // let time pass for final shake\n        75::ms => now;\n    }\n}\n",
                "data": []
            }
        },
        {
            "moog2.ck": {
                "code": "// STK ModalBar\n\n// patch\nMoog moog => dac;\n\n// scale\n[0, 2, 4, 7, 8, 11] @=> int scale[];\n\n// infinite time loop\nwhile( true )\n{\n    // ding!\n    Math.random2f( 0, 128 ) => float filterQ;\n    Math.random2f( 0, 128 ) => float filterSweep;\n    Math.random2f( 0, 128 ) => float vol;\n    Math.random2f( 0, 128 ) => float vibratoFreq;\n    Math.random2f( 0, 128 ) => float vibratoGain;\n\n    moog.controlChange( 2, filterQ);\n    moog.controlChange( 4, filterSweep);\n    moog.controlChange( 11, vibratoFreq);\n    moog.controlChange( 1, vibratoGain);\n    moog.controlChange( 128, vol);\n\n    <<< \"---\", \"\" >>>;\n    <<< \"filterQ\", moog.filterQ() >>>;\n    <<< \"filter sweep rate:\", moog.filterSweepRate() >>>;\n    <<< \"mod speed:\", moog.lfoSpeed() >>>;\n    <<< \"mod depth:\", moog.lfoDepth() >>>;\n    <<< \"volume:\", moog.volume() >>>;\n    <<< \"vibrato freq:\", moog.vibratoFreq() >>>;\n    <<< \"vibrato gain:\", moog.vibratoGain() >>>;\n\n    // set freq\n    scale[Math.random2(0,scale.size()-1)] => int winner;\n    57 + Math.random2(0,2)*12 + winner => Std.mtof => moog.freq;\n    // go\n    .8 => moog.noteOn;\n\n    // advance time\n    .5::second => now;\n}\n",
                "data": []
            }
        },
        {
            "mode-o-test.ck": {
                "code": "//---------------|\n// modal demo\n// by: Ge Wang (gewang@cs.princeton.edu)\n//     Perry R. Cook (prc@cs.princeton.edu)\n//------------------|\n\n// our patch\nModalBar modey => JCRev r => dac;\n\n// set the gain\n.95 => r.gain;\n// set the reverb mix\n.1 => r.mix;\n\n// scale\n[ 0, 2, 4, 7, 9, 11 ] @=> int scale[];\n\nint which;\n// our main loop\nwhile( true )\n{\n    // cycle through\n    ( which + 1 ) % 9 => which;\n    which => modey.preset;\n\n    // frequency...\n    scale[Math.random2(0,scale.size()-1)] => int freq;\n    Math.mtof( 33 + (Math.random2(0,3)*12) + freq ) => modey.freq;\n\n    // velocity\n    Math.random2f( 0.4, 0.8 ) => float v;\n\n    <<< \"playing:\", which, \"freq:\", Std.ftom(modey.freq()) $ int, \"vel:\", v >>>;\n\n    repeat( 4 )\n    {\n        // position\n        Math.random2f( 0.2, 0.8 ) => float p => modey.strikePosition;\n        // strike it!\n        v => modey.strike;\n        // print\n        <<< \"    strike position:\", p >>>;\n        // advance time\n        250::ms => now;\n    }\n}\n",
                "data": []
            }
        },
        {
            "honkeytonk-algo1.ck": {
                "code": "// name: honkeytonk-algo1.ck\n// desc: ALL NEW! HonkyTonk 4op FM (TX81Z Algorithm 1)\n//       This Algorithm can also do PumpOrgn, NylonGuit, others\n//       See nylon-guitar-algo1.ck for how to do this\n//\n// author: Perry R. Cook\n// date: June 2021, for REPAIRATHON 2021\n//       needs chuck 1.4.1.0 or above\n\n// to learn more about HnkyTonk, uncomment this:\n// HnkyTonk.help();\n\n// ugens!\nHnkyTonk h[8];\nPan2 p[8];\nChorus c[2] => NRev r[2] => dac;\n// turn volume down a bit\n0.33 => r[0].gain => r[1].gain;\n0.07 => c[0].mix;\n0.07 => c[1].mix;\n0.04 => r[0].mix;\n0.04 => r[1].mix;\n\nfor (int i; i < 8; i++) {\n    h[i] => p[i] => c;\n    -0.4 + 0.2*i => p[i].pan;\n    Math.random2f(6.95,7.05) => h[i].lfoSpeed;\n    0.04 => h[i].lfoDepth;\n}\n\nStd.mtof(36) => h[0].freq;\nStd.mtof(41) => h[1].freq;\nStd.mtof(53) => h[2].freq;\nStd.mtof(57) => h[3].freq;\nStd.mtof(60) => h[4].freq;\n\n[69,72,74,76,77,81] @=> int melody[];\n\n// triplets (bass 1, bass 2, repeats)\n// must contain 3-multiple of elements\n[41, 48, 4,\n 41, 48, 4,\n 38, 50, 2,\n 34, 53, 2]@=> int bass[];\n\n// bass counter\n0 => int n;\n// drop amount\n0 => int drop;\n// start with bass line\nbassLine( bass[0], bass[1], 4 );\n\n// play melody concurrently over...\nspork ~ doMelody();\n// ... the bass line\nwhile( true )\n{\n    // play current chord\n    bassLine( bass[n*3] + drop, bass[n*3+1], bass[n*3+2] );\n    // increment counter\n    n++;\n    // reset drop\n    0 => drop;\n    // end of cycle? (if yes, start over but with a drop)\n    if( n >= bass.size()/3 ) { 0 => n; -12 => drop; }\n}\n\nfun void doMelody()\n{\n    while( true )\n    {\n        Std.mtof(melody[Math.random2(0,5)]) => h[5].freq;\n        Math.random2f(.75,1) => h[5].noteOn;\n        if (maybe*maybe) {\n            Std.mtof(melody[Math.random2(0,5)]) => h[6].freq;\n            Math.random2f(.5,.75) => h[6].noteOn;\n        }\n        Math.random2(1,3)*second/8 => now;\n    }\n}\n\nfun void bassLine( int note1, int note2, int thisManyTimes )\n{\n    // set thumb1 note\n    Std.mtof(note1) => h[1].freq;\n    // repeat\n    repeat( thisManyTimes )\n    {\n        1 => h[1].noteOn;\n        second/2 => now;\n        .75 => h[2].noteOn;\n        .75 => h[3].noteOn;\n        .75 => h[4].noteOn;\n        second/2 => now;\n        if (maybe*maybe) \n            Std.mtof(note2) => h[0].freq;\n        else\n            Std.mtof(note2-12) => h[0].freq;\n        1 => h[0].noteOn;\n        second/2 => now;\n        .75 => h[2].noteOn;\n        .75 => h[3].noteOn;\n        .75 => h[4].noteOn;\n        second/2 => now;\n    }\n}\n",
                "data": []
            }
        },
        {
            "voic-o-form.ck": {
                "code": "// music for replicants\n\n// patch\nVoicForm voc=> JCRev r => Echo a => Echo b => Echo c => dac;\n\n// settings\n220.0 => voc.freq;\n0.95 => voc.gain;\n.8 => r.gain;\n.2 => r.mix;\n1000::ms => a.max => b.max => c.max;\n750::ms => a.delay => b.delay => c.delay;\n.50 => a.mix => b.mix => c.mix;\n\n// shred to modulate the mix\nfun void vecho_Shred( )\n{\n    0.0 => float decider;\n    0.0 => float mix;\n    0.0 => float old;\n    0.0 => float inc;\n    0 => int n;\n\n    // time loop\n    while( true )\n    {\n        Math.random2f(0.0,1.0) => decider;\n        if( decider < .3 ) 0.0 => mix;\n        else if( decider < .6 ) .08 => mix;\n        else if( decider < .8 ) .5 => mix;\n        else .15 => mix;\n\n        // find the increment\n        (mix-old)/1000.0 => inc;\n        1000 => n;\n        while( n-- )\n        {\n            old + inc => old;\n            if( old < 0 ) 0 => old;\n            old => a.mix => b.mix => c.mix;\n            1::ms => now;\n        }\n        mix => old;\n        Math.random2(2,6)::second => now;\n    }\n}\n\n// let echo shred go\nspork ~ vecho_Shred();\n0.5 => voc.loudness;\n0.01 => voc.vibratoGain;\n\n// scale\n[ 0, 2, 4, 7, 9 ] @=> int scale[];\n\n// our main time loop\nwhile( true )\n{\n    2 * Math.random2( 0,2 ) => int bphon;\n    bphon => voc.phonemeNum;\n    Math.random2f( 0.6, 0.8 ) => voc.noteOn;\n\n    // note: Math.randomf() returns value between 0 and 1\n    if( Math.randomf() > 0.85 )\n    { 1000::ms => now; }\n    else if( Math.randomf() > .85 )\n    { 500::ms => now; }\n    else if( Math.randomf() > .1 )\n    { .250::second => now; }\n    else\n    {\n        0 => int i;\n        4 * Math.random2( 1, 4 ) => int pick;\n        0 => int pick_dir;\n        0.0 => float pluck;\n\n\tfor( ; i < pick; i++ )\n        {\n\t    bphon + 1 * pick_dir => voc.phonemeNum;\n            Math.random2f(.4,.6) + i*.035 => pluck;\n            pluck + 0.0 * pick_dir => voc.noteOn;\n            !pick_dir => pick_dir;\n            250::ms => now;\n        }\n    }\n\n    // pentatonic\n    scale[Math.random2(0,scale.size()-1)] => int freq;\n    Std.mtof( ( 45 + Math.random2(0,2) * 12 + freq ) ) => voc.freq;\n}\n",
                "data": []
            }
        },
        {
            "krstlchr-algo7.ck": {
                "code": "// name: krstlchr.ck\n// desc: KrystlChr (Krystal Choir) 4-Op FM Demo (TX81Z Algorithm 7)\n//\n// author: Perry R. Cook\n// date: June 2021, for REPAIRATHON 2021\n//       needs chuck 1.4.1.0 or above\n\n// array of krystal choir instruments\nKrstlChr c[7];\n// to learn more about KrstlChr, uncomment this:\n// KrstlChr.help();\n\nPan2 p[7];\nNRev r[2] => dac;\n// connect up\nfor (int i; i < 7; i++) {\n   c[i] => p[i] => r;\n   -1.0 + 0.333*i => p[i].pan;\n   Math.random2f(2.5,4.0) => c[i].lfoSpeed; // different modulations\n}\n\n// turn down the volum... for safety\n0.12 => r[0].gain => r[1].gain; \n\n[48, 55, 60, 65, 72, 79, 81] @=> int chord1[];\n[46, 56, 63, 67, 70, 82, 89] @=> int chord2[];\n\n<<< \"Play some nice open chords...\", \"\" >>>;\nrollChord(chord1); second => now;\nallOff(); second => now;\nrollChord(chord2); second => now;\nallOff(); second => now;\nStd.mtof(50) => c[3].freq;\n1 => c[3].noteOn; second => now;\n    \n<<< \"Then loop on random open circle of 4ths notes...\", \"\" >>>;\nwhile( true )\n{\n    Math.random2(0,6) => int which;\n    c[which].noteOff;\n    Math.random2(0,6) => which;\n    Math.random2(0,10)*5 => int space;\n    Std.mtof(38+space) => c[which].freq;\n    if (maybe) \n        1 => c[which].noteOff;\n    else\n        1 => c[which].noteOn;\n    second => now;\n}\n\nfun void rollChord( int chord[] )\n{\n    for( int i; i < 7; i++ )\n    {\n        Std.mtof(chord[i]) => c[i].freq;\n        1 => c[i].noteOn;\n        Math.random2f(0.1,0.3)::second => now;\n    }\n}\n\nfun void allOff()\n{\n    for (int i; i < 7; i++) 1 => c[i].noteOff;\n}\n",
                "data": []
            }
        },
        {
            "brass.ck": {
                "code": "// patch\nBrass brass => JCRev r => dac;\n.75 => r.gain;\n.05 => r.mix;\n\n// our notes\n[ 61, 63, 65, 66, 68 ] @=> int notes[];\n\n// infinite time-loop\nwhile( true )\n{\n    // set\n    Math.random2f( 0, 1 ) => brass.lip;\n    Math.random2f( 0, 1 ) => brass.slide;\n    Math.random2f( 0, 12 ) => brass.vibratoFreq;\n    Math.random2f( 0, 1 ) => brass.vibratoGain;\n    Math.random2f( 0, 1 ) => brass.volume;\n\n    // print\n    <<< \"---\", \"\" >>>;\n    <<< \"lip tension:\", brass.lip() >>>;\n    <<< \"slide length:\", brass.slide() >>>;\n    <<< \"vibrato freq:\", brass.vibratoFreq() >>>;\n    <<< \"vibrato gain:\", brass.vibratoGain() >>>;\n    <<< \"volume:\", brass.volume() >>>;\n\n    for( int i; i < notes.size(); i++ )\n    {\n        play( 12 + notes[i], Math.random2f( .6, .9 ) );\n        300::ms => now;\n    }\n}\n\n// basic play function (add more arguments as needed)\nfun void play( float note, float velocity )\n{\n    // start the note\n    Std.mtof( note ) => brass.freq;\n    velocity => brass.noteOn;\n}\n",
                "data": []
            }
        },
        {
            "subnoise-control.ck": {
                "code": "//------------------------------------------------------------------------------\n// name: subnoise_control.ck\n// desc: demo showcasing the subnoise UGen as a control signal to modulate\n//       the frequency of a SinOsc\n// \n// SubNoise generates a random value between [-1, 1] every `rate` audio ticks.\n// You can get/set the rate in code via the .rate() method.\n// This example showcases uses SubNoise to randomly change the frequency of a\n// SinOsc every half-second.\n//\n// author: azaday\n// date: Spring 2023\n//------------------------------------------------------------------------------\nSubNoise sn => blackhole;\nSinOsc osc => dac;\n\n// tell subnoise to only change its output every half second \n.5::second => dur period;\n(period/samp) $ int   => sn.rate;\n<<< \"setting subnoise rate: \" + sn.rate() >>>;\n\nrepeat (10) {\n    // remap subnoise sample from [-1, 1] to an osc frequency in [220, 880]hz\n    Math.remap(sn.last(), -1.0, 1.0, 220.0, 880.0) => osc.freq;\n    <<< \"remapping osc frequency to: \" + osc.freq() >>>;\n    period => now;\n}\n",
                "data": []
            }
        },
        {
            "rhodey-song.ck": {
                "code": "// name: rhodey-song.ck\n// desc: Rhodey 4-Operator FM (TX81Z Algorithm 5) Demo\n//       An homage to Gil Scott Heron's \"Winter in America\"\n//\n// author: Perry R. Cook\n// date: June 2021\n// note: needs chuck 1.4.1.0 or above\n\n// to learn more about Rhodey, uncomment this:\n// Rhodey.help();\n\nRhodey r[5];\nNRev rev[2] => dac; 0.05 => rev[0].mix; 0.05 => rev[1].mix;\nRhodey solo => rev;\nPan2 p[2]; p[0] => rev[0]; p[1] => rev[1];\nDelay d[2]; rev[0] => d[0] => d[1] => rev[1]; \n0.7 => d[0].gain => d[1].gain;\nsecond => d[0].max => d[0].delay => d[1].max => d[1].delay;\nSinOsc panner => blackhole;\n1 => panner.freq;\nr[0] => p[0]; r[1] => p[0]; \nr[2] => p[1]; r[3] => p[1]; r[4] => p[0]; r[4] => p[1];\nfor (int i; i < r.cap(); i++) {\n    1 => r[i].lfoSpeed;\n    0.0 => r[i].lfoDepth;\n    r[i].opAM(0,0.4);\n    r[i].opAM(2,0.4);\n    r[i].opADSR(0, 0.001, 3.50, 0.0, 0.04);\n    r[i].opADSR(2, 0.001, 3.00, 0.0, 0.04);\n}\n\n// spork panner on its own shred   \nspork ~ doPan();\n\n//  Some chords.  We don't use all here\n[41, 56, 60, 63, 67] @=> int Fmi9[];\n[36, 55, 58, 62, 65] @=> int BfMajC[];\n[34, 56, 60, 63, 67] @=> int AfMaj7Bf[];\n[43, 53, 58, 62, 65] @=> int Gmi7[];\n[62, 66, 69, 74] @=> int DMaj[];\n[59, 62, 66, 68] @=> int Bmi6[];\n[55, 59, 62, 66] @=> int GMaj7[];\n[59, 62, 66, 71] @=> int Bmi[];\n[62, 66, 69, 73] @=> int D7[];\n[62, 66, 69, 74] @=> int DFs[];\n\nsecond/2 => dur Q; Q/2 => dur E; E/2 => dur S;\n\nwhile( true )\n{\n    Std.mtof(72) => solo.freq; 0.8 => solo.noteOn; 2.5*Q => now;\n    Std.mtof(70) => solo.freq; 0.9 => solo.noteOn; E => now;\n    Std.mtof(68) => solo.freq; 0.7 => solo.noteOn; Q+S => now;\n    spork ~ rollChord(Fmi9, 0.9); 4*second => now;\n    Std.mtof(65) => solo.freq; 0.6 => solo.noteOn; E => now;\n    Std.mtof(68) => solo.freq; 0.9 => solo.noteOn; 1.5*E => now;\n    Std.mtof(65) => solo.freq; 0.7 => solo.noteOn; E/2 => now;\n    Std.mtof(70) => solo.freq; 0.9 => solo.noteOn; \n    spork ~ rollChord(BfMajC, 0.9);\n    Q+S => now;\n    Std.mtof(63) => solo.freq; 0.6 => solo.noteOn; E => now;\n    Std.mtof(65) => solo.freq; 0.7 => solo.noteOn; Q+S => now;\n    4*second => now;\n    Std.mtof(65) => solo.freq; 0.6 => solo.noteOn; E => now;\n    Std.mtof(68) => solo.freq; 0.9 => solo.noteOn; E => now;\n    Std.mtof(70) => solo.freq; 0.7 => solo.noteOn; E => now;\n    Std.mtof(72) => solo.freq; 0.9 => solo.noteOn; \n    spork ~ rollChord(Fmi9, 0.9);\n    4*second => now;\n    Std.mtof(65) => solo.freq; 0.6 => solo.noteOn; E => now;\n    Std.mtof(68) => solo.freq; 0.9 => solo.noteOn; E => now;\n    Std.mtof(65) => solo.freq; 0.7 => solo.noteOn; E => now;\n    Std.mtof(70) => solo.freq; 0.9 => solo.noteOn; \n    spork ~ rollChord(BfMajC, 0.9); 4*second => now;\n\n    Std.mtof(65) => solo.freq; 0.6 => solo.noteOn; E => now;\n    Std.mtof(68) => solo.freq; 0.9 => solo.noteOn; E => now;\n    Std.mtof(65) => solo.freq; 0.7 => solo.noteOn; E => now;\n    Std.mtof(70) => solo.freq; 0.7 => solo.noteOn; E => now;\n    Std.mtof(72) => solo.freq; 0.9 => solo.noteOn; \n    spork ~ rollChord(Fmi9, 0.9); Q => now;\n    Std.mtof(75) => solo.freq; 0.9 => solo.noteOn; E/2 => now;\n    Std.mtof(77) => solo.freq; 0.9 => solo.noteOn; E/2 => now;\n    Std.mtof(80) => solo.freq; 1.0 => solo.noteOn; \n    4*second => now;\n    Std.mtof(65) => solo.freq; 0.6 => solo.noteOn; E => now;\n    Std.mtof(68) => solo.freq; 0.9 => solo.noteOn; 1.5*E => now;\n    Std.mtof(77) => solo.freq; 0.7 => solo.noteOn; E/2 => now;\n    Std.mtof(82) => solo.freq; 0.9 => solo.noteOn; \n    spork ~ rollChord(BfMajC, 0.9);\n    4*second => now;\n\n    Std.mtof(72) => solo.freq; 0.8 => solo.noteOn; Q => now;\n    Std.mtof(75) => solo.freq; 0.9 => solo.noteOn; E => now;\n    Std.mtof(72) => solo.freq; 0.8 => solo.noteOn; E => now;\n    Std.mtof(75) => solo.freq; 0.9 => solo.noteOn; E/2 => now;\n    Std.mtof(72) => solo.freq; 0.8 => solo.noteOn; E => now;\n    spork ~ rollChord(AfMaj7Bf, 0.9);\n    4*second => now;\n    \n    Std.mtof(65) => solo.freq; 0.6 => solo.noteOn; E => now;\n    Std.mtof(63) => solo.freq; 0.6 => solo.noteOn; E => now;\n    Std.mtof(53) => solo.freq; 1.0 => solo.noteOn;\n    spork ~ rollChord(Gmi7, 0.9);\n    6*second => now;\n}\n\n\nfun void chord(int chord[], float vel) {\n    for (int i; i < chord.cap(); i++) {\n        Std.mtof(chord[i]) => r[i].freq;\n        vel => r[i].noteOn;\n    }\n}\n\nfun void rollChord(int chord[], float vel) {\n    for (int i; i < chord.cap(); i++) {\n        Std.mtof(chord[i]) => r[i].freq;\n        vel => r[i].noteOn;\n        Math.random2f(0.01,0.08)::second => now;\n    }\n}\n\nfun void doPan() {\n    while( true ) {\n        1.0 - panner.last() => float temp;\n        temp => p[0].pan;\n        1.0 - temp => p[1].pan;\n        ms => now;\n    }\n}\n",
                "data": []
            }
        },
        {
            "blowhole.ck": {
                "code": "// patch\nBlowHole hole => dac;\n\n// scale\n[0, 2, 4, 7, 9, 11] @=> int scale[];\n\n<<< \"reed stiffness:\", hole.reed() >>>;\n<<< \"noise gain:\", hole.noiseGain() >>>;\n<<< \"tonehole state:\", hole.tonehole() >>>;\n<<< \"register state:\", hole.vent() >>>;\n<<< \"breath pressure:\", hole.pressure() >>>;\n\n// infinite time loop\nwhile( true )\n{\n  // change parameters\n  if( Math.random2f(0,1) > .75 )\n  {\n    Math.random2f( 0, 1 ) => hole.reed;\n    Math.random2f( 0, 1 ) => hole.noiseGain;\n    Math.random2f( 0, 1 ) => hole.tonehole;\n    Math.random2f( 0, 1 ) => hole.vent;\n    Math.random2f( 0, 1 ) => hole.pressure;\n\n    // print\n    <<< \"going...\", \"\" >>>;\n    <<< \"reed stiffness:\", hole.reed() >>>;\n    <<< \"noise gain:\", hole.noiseGain() >>>;\n    <<< \"tonehole state:\", hole.tonehole() >>>;\n    <<< \"register state:\", hole.vent() >>>;\n    <<< \"breath pressure:\", hole.pressure() >>>;\n  }\n\n  // set freq\n  scale[Math.random2(0,scale.size()-1)] => int note;\n  33 + Math.random2(0,4)*12 + note => Std.mtof => hole.freq;\n  <<< \"note: \", Std.ftom( hole.freq() ) >>>;\n\n  // go\n  .8 => hole.noteOn;\n\n  // advance time\n  1::second => now;\n}\n",
                "data": []
            }
        },
        {
            "brass2.ck": {
                "code": "// patch\nBrass brass => JCRev r => dac;\n.75 => r.gain;\n.05 => r.mix;\n\n// our notes\n[ 61, 63, 65, 66, 68 ] @=> int notes[];\n\n// infinite time-loop\nwhile( true )\n{\n    Math.random2f( 64, 128 ) => float tension;\n    Math.random2f( 0, 128 ) => float length;\n    Math.random2f( 0, 128 ) => float vibratofreq;\n    Math.random2f( 0, 128 ) => float vibratogain;\n    Math.random2f( 64, 128 ) => float volume;\n\n    <<< \"---\", \"\" >>>;\n    <<< \"lip tension:\", tension >>>;\n    <<< \"slide length:\", length >>>;\n    <<< \"vibrato freq:\", vibratofreq >>>;\n    <<< \"vibrato gain:\", vibratogain >>>;\n    <<< \"volume:\", volume >>>;\n\n    // lip tension\n    brass.controlChange( 2, tension );\n    // slide length\n    brass.controlChange( 4, length );\n    // vibrato freq\n    brass.controlChange( 11, vibratofreq );\n    // vibrato gain\n    brass.controlChange( 1, vibratogain );\n    // volume\n    brass.controlChange( 128, volume );\n\n    for( int i; i < notes.size(); i++ )\n    {\n        play( 12 + notes[i], Math.random2f( .6, .9 ) );\n        300::ms => now;\n    }\n}\n\n// basic play function (add more arguments as needed)\nfun void play( float note, float velocity )\n{\n    // start the note\n    Std.mtof( note ) => brass.freq;\n    velocity => brass.noteOn;\n}\n",
                "data": []
            }
        },
        {
            "blowbotl2.ck": {
                "code": "// STK BlowBotl; using classic STK controlChange\n// (also see blowbotl.ck)\n\n// patch\nBlowBotl bottle => dac;\n\n// scale\n[0, 2, 4, 7, 8, 11] @=> int scale[];\n\n// infinite time loop\nwhile( true )\n{\n    Math.random2f( 0, 128 ) => float noisegain;\n    Math.random2f( 0, 128 ) => float vibratofreq;\n    Math.random2f( 0, 128 ) => float vibratogain;\n    Math.random2f( 0, 128 ) => float volume;\n\n    <<< \"---\", \"\" >>>;\n    <<< \"noise gain:\", noisegain, \"/ 128.0\" >>>;\n    <<< \"vibrato freq:\", vibratofreq, \"/ 128.0\" >>>;\n    <<< \"vibrato gain:\", vibratogain, \"/ 128.0\" >>>;\n    <<< \"volume:\", volume, \"/ 128.0\" >>>;\n\n    // noise gain\n    bottle.controlChange( 4, noisegain );\n    // vibrato freq\n    bottle.controlChange( 11, vibratofreq );\n    // vibrato gain\n    bottle.controlChange( 1, vibratogain );\n    // volume\n    bottle.controlChange( 128, volume );\n\n    // set freq\n    scale[Math.random2(0,scale.size()-1)] + 57 => Std.mtof => bottle.freq;\n    // go\n    .8 => bottle.noteOn;\n\n    // advance time\n    1::second => now;\n}\n",
                "data": []
            }
        },
        {
            "clarinet2.ck": {
                "code": "// STK Clarinet\n// (also see examples/event/polyfony2.ck)\n\n// patch\nClarinet clair => JCRev r => dac;\n.75 => r.gain;\n.1 => r.mix;\n\n// our notes\n[ 61, 63, 65, 66, 68, 66, 65, 63, 61 ] @=> int notes[];\n\n// infinite time-loop\nwhile( true )\n{\n    Math.random2f( 64, 128 ) => float stiffness;\n    Math.random2f( 0, 128 ) => float noisegain;\n    Math.random2f( 0, 128 ) => float vibratofreq;\n    Math.random2f( 0, 128 ) => float vibratogain;\n    Math.random2f( 64, 128 ) => float pressure;\n\n    <<< \"---\", \"\" >>>;\n    <<< \"reed stiffness:\", stiffness >>>;\n    <<< \"noise gain:\", noisegain >>>;\n    <<< \"vibrato freq:\", vibratofreq >>>;\n    <<< \"vibrato gain:\", vibratogain >>>;\n    <<< \"breath pressure:\", pressure >>>;\n\n    // clear\n    clair.clear( 1.0 );\n\n    // reed stiffness\n    clair.controlChange( 2, stiffness );\n    // noise gain\n    clair.controlChange( 4, noisegain );\n    // vibrato freq\n    clair.controlChange( 11, vibratofreq );\n    // vibrato gain\n    clair.controlChange( 1, vibratogain );\n    // breath pressure\n    clair.controlChange( 128, pressure );\n\n    for( int i; i < notes.size(); i++ )\n    {\n        play( 12 + notes[i], Math.random2f( .6, .9 ) );\n        300::ms => now;\n    }\n}\n\n// basic play function (add more arguments as needed)\nfun void play( float note, float velocity )\n{\n    // start the note\n    Std.mtof( note ) => clair.freq;\n    velocity => clair.noteOn;\n}\n",
                "data": []
            }
        },
        {
            "bandedwg.ck": {
                "code": "// STK BandedWG\n\n// patch\nBandedWG bwg => dac;\n\n// scale\n[0, 2, 4, 7, 8, 11] @=> int scale[];\n\n// infinite time loop\nwhile( true )\n{\n    // ding!\n    Math.random2f( 0, 1 ) => bwg.bowRate;\n    Math.random2f( 0, 1 ) => bwg.bowPressure;\n    Math.random2f( 0, 1 ) => bwg.strikePosition;\n    Math.random2( 0, 3 ) => bwg.preset;\n\n    // set freq\n    scale[Math.random2(0,scale.size()-1)] => int winner;\n    57 + Math.random2(0,2)*12 + winner => Std.mtof => bwg.freq;\n\n    // print some parameters\n    <<< \"---\", \"\" >>>;\n    <<< \"preset:\", bwg.preset() >>>;    \n    <<< \"bow rate:\", bwg.bowRate() >>>;\n    <<< \"bow Pressure:\", bwg.bowPressure() >>>;\n    <<< \"strike position:\", bwg.strikePosition() >>>;\n    <<< \"frequency:\", bwg.freq() >>>;\n    <<< \"---\", \"\" >>>;\n\n    <<< \"bow -> pluck\", \"\" >>>;\n    Math.random2f( .5, 1 ) => bwg.pluck;\n    // advance time\n    2::second => now;\n\n    <<< \"pluck -> bow\", \"\" >>>;\n    .8 => bwg.startBowing;\n    Math.random2f(2,4)::second => now;\n    1.0 => bwg.stopBowing;\n    1::second => now;\n}\n",
                "data": []
            }
        },
        {
            "modulate.ck": {
                "code": "// patch into gain\nSinOsc s => Gain g => dac;\nModulate mod => g;\n\n// multiply\n3 => g.op;\n\n// set freq\n220 => s.freq;\n\n// set rate in hz\nmod.vibratoRate( 6.0 );\n// set gain\nmod.vibratoGain( .2 );\n// set random gain\nmod.randomGain( .1 );\n\n// infinite time loop\nwhile( true )\n{\n    10::second => now;\n}\n",
                "data": []
            }
        },
        {
            "band-o-matic.ck": {
                "code": "// banded waveguide sample\n\n// the patch\nBandedWG band => JCRev r => dac;\n\n// presets\n0.95 => band.gain;\n1 => band.preset;\nStd.mtof( ( 21 + Math.random2(0,3) * 12 + 7 ) ) => band.freq;\n.8 => r.gain;\n.1 => r.mix;\n\n// scale\n[ 0, 2, 4, 7, 9 ] @=> int scale[];\n\n// our main time loop\nwhile( true )\n{\n    Math.random2f( 0.1, 0.9 ) => band.bowRate;\n    Math.random2f( 0.2, 0.35 ) => band.bowPressure;\n    Math.random2f( 0.6, 0.8 ) => band.startBowing;\n\n    // note: Math.randomf() returns value between 0 and 1\n    if( Math.randomf() > 0.85 )\n    { 1000::ms => now; }\n    else if( Math.randomf() > .85 )\n    { 500::ms => now; }\n    else if( Math.randomf() > 0.6 )\n    { .250::second => now; }\n    else\n    {\n        0 => int i;\n        4 * Math.random2( 1, 4 ) => int pick;\n        0 => int pick_dir;\n        0.0 => float pluck;\n        Math.random2f( 50.0, 200.0 ) => float d;\n\n        for( ; i < pick; 1 +=> i )\n        {\n            Math.random2f(.4,.6) + i*.35/pick => pluck;\n            pluck + 0.1 * pick_dir => band.pluck;\n            !pick_dir => pick_dir;\n            d::ms => now;\n        }\n    }\n\n    // note: Math.randomf() returns value bewteen 0 and 1\n    if( Math.randomf() > 0.2 )\n    { \n        1::second => now;\n        0.001 => band.stopBowing;\n        0.5::second *  Math.random2(1,3) => now;\n\n        // scale\n        scale[Math.random2(0, scale.size()-1)] => int freq;\n        Std.mtof( 21 + Math.random2(0,5) * 12 + freq ) => band.freq;\n        // note: Math.randomf() returns value between 0 and 1\n        if( Math.randomf() > 0.85 ) \n            Math.random2(0,3) => band.preset;\n    }\n}\n",
                "data": []
            }
        },
        {
            "moogie.ck": {
                "code": "// STK Moog\n// by: phil\n\nMoog mog => dac;\n440.0 => mog.freq;\n0.0 => float t;\n\nfun void varmod()\n{\n    while ( true )\n    {\n        0.5 + 0.4 *  Math.sin( t * 0.1 ) => mog.modDepth;\t\n        0.5 + 0.4 *  Math.sin( t * 0.2 ) => mog.modSpeed;\t\n        0.5 + 0.4 *  Math.sin( t * 0.3 ) => mog.filterQ;\t\n        0.5 + 0.4 *  Math.sin( t * 0.4 ) => mog.filterSweepRate;\t\n        10::ms => now;\n        t + 0.01 => t;\n    }\n}\n\nfun void atouch( float imp)\n{\n    imp => float atouch;\n    while ( atouch >= 0.0 )\n    {\n        atouch => mog.afterTouch;\n        atouch - 0.05 => atouch;\n        10::ms => now;\n    }\n}\n\n// spork varmod shred\nspork ~varmod();\n\n0.0 => float vel;\nwhile ( true )\n{\n    // Math.random2f ( 440.0, 880.0 ) => mog.freq;\n    278.43 => mog.freq;\n    Math.random2f(0.5, 0.8) => vel;\n    vel  => mog.noteOn;\n    spork ~ atouch(vel);\n    // note: Math.randomf() returns value between 0 and 1\n    if ( Math.randomf() > 0.65 ) { 1::second => now; }\n    else { 0.5::second => now; }\n}\n",
                "data": []
            }
        },
        {
            "flute.ck": {
                "code": "// STK Flute\n\n// patch\nFlute flute => PoleZero f => JCRev r => dac;\n.75 => r.gain;\n.05 => r.mix;\n.99 => f.blockZero;\n\n// our notes\n[ 61, 63, 65, 66, 68 ] @=> int notes[];\n\n// infinite time-loop\nwhile( true )\n{\n    // clear\n    flute.clear( 1.0 );\n\n    // set\n    Math.random2f( 0, 1 ) => flute.jetDelay;\n    Math.random2f( 0, 1 ) => flute.jetReflection;\n    Math.random2f( 0, 1 ) => flute.endReflection;\n    Math.random2f( 0, 1 ) => flute.noiseGain;\n    Math.random2f( 0, 12 ) => flute.vibratoFreq;\n    Math.random2f( 0, 1 ) => flute.vibratoGain;\n    Math.random2f( 0, 1 ) => flute.pressure;\n\n    // print\n    <<< \"---\", \"\" >>>;\n    <<< \"jetDelay:\", flute.jetDelay() >>>;\n    <<< \"jetReflection:\", flute.jetReflection() >>>;\n    <<< \"endReflection:\", flute.endReflection() >>>;\n    <<< \"noiseGain:\", flute.noiseGain() >>>;\n    <<< \"vibratoFreq:\", flute.vibratoFreq() >>>;\n    <<< \"vibratoGain:\", flute.vibratoGain() >>>;\n    <<< \"breath pressure:\", flute.pressure() >>>;\n\n    // factor\n    Math.random2f( .75, 2 ) => float factor;\n\n    for( int i; i < notes.size(); i++ )\n    {\n        play( 12 + notes[i], Math.random2f( .6, .9 ) );\n        300::ms * factor => now;\n    }\n}\n\n// basic play function (add more arguments as needed)\nfun void play( float note, float velocity )\n{\n    // start the note\n    Std.mtof( note ) => flute.freq;\n    velocity => flute.noteOn;\n}\n",
                "data": []
            }
        },
        {
            "hevymetl-dance-now.ck": {
                "code": "//-----------------------------------------------------------------------------\n// name: hevymetl-dance-now.ck\n// desc: riff from \"Everybody Dance Now\"\n//       created using FM Synthesis, for \"Everybody SLOrk Now!\"\n//\n// author: Ge Wang (https://ccrma.stanford.edu/~ge/)\n// date: Spring 2022\n//\n// original: inspired by \"Gonna Make You Sweat (Everybody Dance Now)\"\n//           C+C Music Factory\n//\n// code notes:\n//   * OFFSET: pitch of third note in power chord (try 0, -12, 12)\n//   * DO_ECHO: set to 0 for clean chords; 1 for feedback echo\n//   * USE_ENV: controls the attack; set to 0 for hevymetl attack\n//-----------------------------------------------------------------------------\n// note: want to learn more about HevyMetl? uncomment following line:\n// HevyMetl.help();\n//-----------------------------------------------------------------------------\n\n// quarter note duration\n0.2615::second => dur R;\n// detune (\"Everybody Dance Now\" in Bb + somewhat sharper)\n.3 => float TUNE;\n// pitch of third note in power chord (try 0, -12, 12)\n0  => int OFFSET;\n// controls the attack; set to 0 for hevymetl attack\n1 => int USE_ENV;\n// set to 0 for clean chords; 1 for feedback echo\n1 => int DO_ECHO;\n\n// patch\nHevyMetl h[3];\n// high pass (for echoes)\nHPF hpf[3];\n// reverb\nNRev r => dac; .5 => dac.gain;\n// reverb mix\n0.0 => r.mix;\n// feedback delay\nDelay d => r;\nd => Gain feedback => d;\n// delay\nR => d.max => d.delay;\n// delay gain\n0.4 => d.gain;\n// feedback\n0.15 => feedback.gain;\n\n// FM operator envelope indices\n[31,31,31,31] @=> int attacks[]; // [18,14,15,15] from patch\n[31,31,31,31] @=> int decays[];  // [31,31,26,31] from patch\n[15,15,15,10] @=> int sustains[]; // [15,15,13,15] from patch\n[31,31,31,31] @=> int releases[]; // [8,8,8,8] from patch\n\n// connect\nfor( int i; i < 3; i++ )\n{\n    h[i] => r;\n    // set delay\n    h[i] => hpf[i] => d;\n    // set high pass\n    600 => hpf[i].freq;\n    \n    // LFO depth\n    0.0 => h[i].lfoDepth;\n    \n    if( USE_ENV)\n    {\n        // ops\n        for( 0=>int op; op < 4; op++ )\n        {\n            h[i].opADSR( op,\n            h[i].getFMTableTime(attacks[op]),\n            h[i].getFMTableTime(decays[op]),\n            h[i].getFMTableSusLevel(sustains[op]),\n            h[i].getFMTableTime(releases[op]) );\n        }\n    }\n}\n\n// time loop\nwhile( true )\n{\n    // echo gain\n    DO_ECHO * .5 => d.gain;\n    \n    // do it\n    playChord( 46, 53, 46+OFFSET, .8, R );\n    2*R => now;\n    playChord( 46, 53, 46+OFFSET, .8, R );\n    1*R => now;\n    playChord( 41, 48, 41+OFFSET, 1.0, R*.8 ); .2*R => now;\n    R/2+0*R => now;\n    playChord( 44, 51, 44+OFFSET, .9, R*.8 ); .2*R => now;\n    R/2+0*R => now;\n}\n\nfun void playChord( int a, int b, int c, float vel, dur D )\n{\n    // set the pitches\n    Std.mtof(a+TUNE) => h[0].freq;\n    Std.mtof(b+TUNE) => h[1].freq;\n    Std.mtof(c+TUNE) => h[2].freq;\n    \n    // note on\n    for( 0 => int i; i < 3; i++ )\n    { vel => h[i].noteOn; }\n    // sound\n    0.85*(D) => now;\n    \n    // note off\n    for( 0 => int i; i < 3; i++ )\n    { 1 => h[i].noteOff; }\n    // let ring\n    0.15*(D) => now;\n}\n",
                "data": []
            }
        },
        {
            "hevymetl-trumpet-algo3.ck": {
                "code": "// name: hevymetl-trumpet-algo3.ck\n// desc: demo of how to turn HevyMetl (Algorithm 3) into an FM Trumpet!!\n//       now you can transcribe (somewhat) directly from a TX81 Patch!!!\n//\n// author: Perry R. Cook\n// date: June 2021, for REPAIRATHON 2021\n//       needs chuck 1.4.1.0 or above\n\n\n// patch\nHevyMetl t => NRev r => dac;\n// reverb mix\n0.06 => r.mix;\n\n// want to learn more about HevyMetl? uncomment this:\n// t.help();\n\n// FM\n[1,6,6,1] @=> int waveForms[];\n[99,85,74,99] @=> int opGains[]; // [93,75,54,81] from patch\n[1.0,1.0,2.9,1.0] @=> float ratios[];\n[15,14,15,15] @=> int attacks[]; // [18,14,15,15] from patch\n[31,20,26,14] @=> int decays[];  // [31,31,26,31] from patch\n[15,10,13,15] @=> int sustains[]; // [15,15,13,15] from patch\n[10,10,10,10] @=> int releases[]; // [8,8,8,8] from patch\n\n// ops\nfor( int op; op < 4; op++ )\n{\n    t.opWave( op, waveForms[op] );  // sine waves all\n    t.opGain( op, t.getFMTableGain(opGains[op]) );\n    t.opADSR( op, t.getFMTableTime(attacks[op]),\n                  t.getFMTableTime(decays[op]),\n                  t.getFMTableSusLevel(sustains[op]),\n                  t.getFMTableTime(releases[op]) );\n    t.opRatio( op, ratios[op] );\n}\n\n// t.setOpGain(1,0.0);\nt.op4Feedback(0.5);\n\n// our notes\n[ 64, 62, 67, 69, 74, 71, 69, 74, 71, 67, 72, 69, 67] @=> int notes[];\n[2, 2, 2, 1, 1, 2, 1, 1, 2, 2, 2, 2, 9] @=> int durs[];\n\n0.005 => t.lfoDepth;\n\nfor( 0 => int i; i < notes.cap(); i++ )\n{\n    Std.mtof( 14 + notes[i] ) => t.freq;\n    0.7 => t.noteOn;\n    if (i == notes.cap()-1) 0.05 => t.lfoDepth;\n    (0.2 * durs[i]) :: second => now;\n    1.0 => t.noteOff;\n    (0.1 * durs[i]) :: second => now;\n}\n",
                "data": []
            }
        },
        {
            "saxofony.ck": {
                "code": "// STK Saxofony\n\n// patch\nSaxofony sax => JCRev r => dac;\n.5 => r.gain;\n.05 => r.mix;\n\n// our notes\n[ 61, 63, 65, 66, 68 ] @=> int notes[];\n\n// infinite time-loop\nwhile( true )\n{\n    // set\n    Math.random2f( 0, 1 ) => sax.stiffness;\n    Math.random2f( 0, 1 ) => sax.aperture;\n    Math.random2f( 0, 1 ) => sax.noiseGain;\n    Math.random2f( 0, 1 ) => sax.blowPosition;\n    Math.random2f( 0, 12 ) => sax.vibratoFreq;\n    Math.random2f( 0, 1 ) => sax.vibratoGain;\n    Math.random2f( 0, 1 ) => sax.pressure;\n\n    // print\n    <<< \"---\", \"\" >>>;\n    <<< \"stiffness:\", sax.stiffness() >>>;\n    <<< \"aperture:\", sax.aperture() >>>;\n    <<< \"noiseGain:\", sax.noiseGain() >>>;\n    <<< \"blowPosition:\", sax.blowPosition() >>>;\n    <<< \"vibratoFreq:\", sax.vibratoFreq() >>>;\n    <<< \"vibratoGain:\", sax.vibratoGain() >>>;\n    <<< \"pressure:\", sax.pressure() >>>;\n\n    // factor\n    Math.random2f( .75, 2 ) => float factor;\n\n    for( int i; i < notes.size(); i++ )\n    {\n        play( 12 + notes[i], Math.random2f( .6, .9 ) );\n        300::ms * factor => now;\n    }\n}\n\n// basic play function (add more arguments as needed)\nfun void play( float note, float velocity )\n{\n    // start the note\n    Std.mtof( note ) => sax.freq;\n    velocity => sax.noteOn;\n}\n",
                "data": []
            }
        },
        {
            "hevymetl-algo3.ck": {
                "code": "// name: hevymetl-algo3.ck\n// desc: demo of STK FM HevyMetl (Algorithm 3)\n// \n// name: Perry R. Cook\n// date: June 2021, for REPAIRATHON 2021\n\n// patch\nHevyMetl h => NRev r => dac;\n// reverb mix\n0.05 => r.mix;\n// set delay\nh => Delay d => d => r; \n// quarter note length\n0.25::second => dur T;\n// delay\n4*T => d.max => d.delay;\n// feedback gain\n0.25 => d.gain;\n\n// time loop\nwhile( true )\n{\n    // LFO depth\n    0.0 => h.lfoDepth;\n    \n    // play notes\n    playNote( 66,2*T );\n    playNote( 66,T );\n    playNote( 66,T );\n    playNote( 67,T );\n    playNote( 67,3*T );\n    playNote( 64,T );\n    \n    // from time to time...\n    if( maybe*maybe ) playNote(64+2*Math.random2(0,5),2*T);\n    else playNote(64,2*T);\n    \n    playNote(66,5*T);\n    \n    riff();\n}\n\nfun void playNote( int note, dur dure )\n{\n    Std.mtof(note) => h.freq;\n    1 => h.noteOn; \n    0.9*(dure) => now;\n    1 => h.noteOff;\n    0.1*(dure) => now;\n}\n\nfun void riff()\n{\n    [74,69,66,72,67,62,71,67,62,69] @=> int notes[];\n    [1,1,1,2,1,1,2,1,1,5] @=> int durs[];\n    for (int i; i < notes.cap(); i++)\n    {\n        Std.mtof(notes[i]) => h.freq;\n        1 => h.noteOn;\n        if (i == notes.cap()-1) 0.3 => h.lfoDepth;\n        durs[i]*T => now;\n    }\n    1 => h.noteOff;\n}\n",
                "data": []
            }
        },
        {
            "wurley.ck": {
                "code": "// even more music for replicants\n\n// patch\nWurley voc=> JCRev r => dac;\n\n// initial settings\n220.0 => voc.freq;\n0.95 => voc.gain;\n.8 => r.gain;\n.1 => r.mix;\n\n// scale\n[ 0, 3, 7, 8, 11 ] @=> int scale[];\n\n// our main time loop\nwhile( true )\n{\n    // scale\n    scale[Math.random2(0,scale.size()-1)] => int freq;\n    Std.mtof( ( 45 + Math.random2(0,1) * 12 + freq ) ) => voc.freq;\n    Math.random2f( 0.6, 0.8 ) => voc.noteOn;\n\n    // note: Math.randomf() returns value between 0 and 1\n    if( Math.randomf() > 0.9 )\n    {\n        // 1000::ms => now;\n        repeat( 100 )\n        {\n            voc.freq() * 1.01 => voc.freq;\n            10::ms => now;\n        }\n    }\n    else if( Math.randomf() > .75 )\n    {\n        // 500::ms => now;\n        repeat( 50 )\n        {\n            voc.freq() * .99 => voc.freq;\n            10::ms => now;\n        }\n    }\n    else if( Math.randomf() > .1 )\n    {\n        250::ms => now;\n\n    }\n    else\n    {\n        0 => int i;\n        2 * Math.random2( 1, 3 ) => int pick;\n        0 => int pick_dir;\n        0.0 => float pluck;\n\n        for( ; i < pick; i++ )\n        {\n            Math.random2f(.4,.6) + i*.035 => pluck;\n            pluck + 0.03 * (i * pick_dir) => voc.noteOn;\n            !pick_dir => pick_dir;\n            250::ms => now;\n        }\n    }\n}\n",
                "data": []
            }
        },
        {
            "stifkarp.ck": {
                "code": "// STK StifKarp\n\n// patch\nStifKarp m => NRev r => dac;\n.75 => r.gain;\n.02 => r.mix;\n\n// our notes\n[ 61, 63, 65, 66, 68, 66, 65, 63 ] @=> int notes[];\n\n// infinite time-loop\nwhile( true )\n{\n    Math.random2f( 0, 1 ) => m.pickupPosition;\n    Math.random2f( 0, 1 ) => m.sustain;\n    Math.random2f( 0, 1 ) => m.stretch;\n\n    <<< \"---\", \"\" >>>;\n    <<< \"pickup:\", m.pickupPosition() >>>;\n    <<< \"sustain:\", m.sustain() >>>;\n    <<< \"stretch:\", m.stretch() >>>;\n\n    // factor\n    Math.random2f( 1, 4 ) => float factor;\n\n    for( int i; i < notes.size(); i++ )\n    {\n        play( Math.random2(0,2)*12 + notes[i], Math.random2f( .6, .9 ) );\n        100::ms * factor => now;\n    }\n}\n\n// basic play function (add more arguments as needed)\nfun void play( float note, float velocity )\n{\n    // start the note\n    Std.mtof( note ) => m.freq;\n    velocity => m.pluck;\n}\n",
                "data": []
            }
        }
    ],
    "math": [
        {
            "int-dist.ck": {
                "code": "// name: int-dist.ck\n// desc: testing int random distribution over range\n\n// how many buckets\n10 => int N;\n\n// buckets\nint count[N];\n\n// how many times\nrepeat( 100000 )\n{\n    // which bucket?\n    count[Math.random2(0,N-1)]++;\n}\n\n// go over buckets\nfor( int i; i < N; i++ )\n{\n    // print bucket contents\n    cherr <= count[i] <= IO.nl();\n}",
                "data": []
            }
        },
        {
            "map.ck": {
                "code": "// name: map.ck\n// desc: mapping a number in one range to a second range, using\n//       Math.map( float value, float x1, float x2,\n//                              float y1, float y2 )\n//\n// version: need chuck-1.5.0.0 or higher\n//\n// NOTE: Math.map(...) allows 'value' to be outside range [x1,x2]\n//       whereas Math.map2(...) clamps 'value' to range [x1,x2]\n//\n// uncomment this line to print Math library API\n// Math.help();\n//\n// author: Ge Wang\n// date: Spring 2023\n\n// map 2.5 from [2,4] to [0,1]\n<<< Math.map( 2.5, 2, 4, 0, 1 ), \"\" >>>;\n// map 5 from [1,10] to [-1,1]\n<<< Math.map( 5, 1, 10, -1, 1 ), \"\" >>>;\n// map 5 from [10,1] to [-1,1]\n<<< Math.map( 5, 10, 1, -1, 1 ), \"\" >>>;\n// map 1 from [2,3] to [0,100]\n<<< Math.map( 1, 2, 3, 0, 100 ), \"(not clamped)\" >>>;\n// clampf() and map()\n<<< Math.map2( Math.clampf(1,2,3), 2, 3, 0, 100 ), \"(clamped using Math.clampf())\" >>>;\n// same as Math.map2()\n<<< Math.map2( 1, 2, 3, 0, 100 ), \"(clamped using Math.map2())\" >>>;\n",
                "data": []
            }
        },
        {
            "maybe.ck": {
                "code": "// name: maybe.ck\n// desc: can't decide? flip a coin with `maybe`!\n//       NOTE: `maybe` evaluates to true with 50% probility\n//\n// author: Ge Wang\n// date: 2023, in an age of uncertainty\n\n// what to eat? feel free to re-run this program\nif( maybe ) <<< \"get Chinese!\", \"\" >>>;\n       else <<< \"             order Mexican!\", \"\" >>>;\n",
                "data": []
            }
        },
        {
            "math-help.ck": {
                "code": "// name: help-math.ck\n// desc: there are many functions in the Math class library\n//       run this file to print the current Math API\n\n// print\nMath.help();",
                "data": []
            }
        },
        {
            "randomize.ck": {
                "code": "//-------------------------------------------------------------------\n// name: randomize()\n// desc: random number generation example...\n//       to show the effects of alternating between\n//       1) explicitly seeding the random number generator (RNG)\n//       -- AND --\n//       2) implicitly seeding the RNG with a practially\n//          unpredicable seed\n//\n// requires: chuck-1.5.0.4 or higher\n//\n// author: Ge Wang (https://ccrma.stanford.edu/~ge/)\n// date: Summer 2023\n//-------------------------------------------------------------------\n\n// explicit seed\n10513 => int EXPLICIT_SEED;\n// how many to print each round\n8 => int HOW_MANY;\n// how long to wait between each number\n100::ms => dur T;\n\nfun void generate( int howMany, dur T, int indents )\n{\n    int i;\n    repeat(howMany)\n    {\n        T => now;\n        repeat(indents) cherr <= \" \";\n        <<< ++i, Math.random2(1,100) >>>;\n    }\n}\n\nwhile( true )\n{\n    // explicit seeding\n    <<< \"--------------------------------------\", \"\" >>>;\n    <<< \"seeding RNG with\", EXPLICIT_SEED, \"SAME EACH TIME!\" >>>;\n    <<< \"--------------------------------------\", \"\" >>>;\n    Math.srandom( EXPLICIT_SEED );\n    // generate\n    generate( HOW_MANY, T, 0 );\n\n    // wait a bit\n    5*T => now;    \n    \n    <<< \"********************\", \"\" >>>;\n    <<< \"SHAKING THINGS UP!!!\", \"\" >>>;\n    <<< \"********************\", \"\" >>>;\n    Math.randomize();\n    // generate\n    generate( HOW_MANY, T, 16 );\n\n    // wait a bit\n    5*T => now;    \n}\n",
                "data": []
            }
        }
    ],
    "time": [
        {
            "time_types.ck": {
                "code": "// 05.ck : time, now, duration\n\n// time + duration\nnow + 5::second => time later;\n\n// time loop\nwhile( now < later )\n{\n    // print out the time\n    <<<now>>>;\n    // advance time\n    1::second => now;\n}\n\n<<<\"success\">>>;\n",
                "data": []
            }
        },
        {
            "time_operations.ck": {
                "code": "// ...\n\n// store the current time\nnow => time t1; \n\n//value to duration\n0.5::second => dur d; \n<<<\"one\">>>;\n//now waits for that duration \nd => now;\n<<<\"two\">>>;\n\n//define new duration\nd * 4.0 => dur four_d; \n\n//wait again. \nfour_d => now;\n<<<\"three\">>>;\n\nnow => time t2;\n\nt2 - t1 => dur span;\n<<<\"total\">>>;\n<<<span>>>;\n<<<\"relative\">>>;\n<<<span / d>>>;\n\n",
                "data": []
            }
        }
    ],
    "special": [
        {
            "LiSa-track3.ck": {
                "code": "//--------------------------------------------------------------------\n// name: LiSa-track3.ck\n// desc: Live sampling utilities for ChucK\n//       demonstrate using track == 1 mode with LiSa\n//\n// author: Dan Trueman, 2007\n//\n// when track == 1, the input is used to control playback position\n// input [0,1] will control playback position within loop marks\n// input values less than zero are multiplied by -1, so it is\n// possible to use audio signals [-1, 1] to control playback position,\n// as in waveshaping\n//--------------------------------------------------------------------\n\n// signal chain; record a sine wave, play it back\nSinOsc s => LiSa loopme => dac;\n// frequency\n440 => s.freq;\n\n// alloc LiSa memory\n6::second => loopme.duration;\n1000::ms => loopme.loopEndRec;\n1000::ms => loopme.loopEnd;\n\n// set recording ramp time\nloopme.recRamp( 50::ms );\n// retain some while loop recording\nloopme.feedback( 0.99 ); \n\n// start recording input\nloopme.record( 1 );\n// 1 sec later, this time DON'T stop recording....\n1000::ms => now;\n\n// set track mode to 1, where the input chooses playback position\n1 => loopme.track;\n// this time don't change the freq; scan through zippy quick\nloopme.play( 1 );\nloopme.gain( 0.02 );\n\n// advance time for 5 seconds\n5000::ms => now;\n// ramp down\nloopme.rampDown( 250::ms );\n// wait\n500::ms => now;\n\n// pretty farking scary\n// bye bye\n",
                "data": []
            }
        },
        {
            "readme-LiSa2.ck": {
                "code": "//--------------------------------------------------------------------\n// name: readme-LiSa2.ck\n// desc: Live Sampling (LiSa) utilities for ChucK\n//\n// author: Dan Trueman\n// date: 2007\n//\n// to run (in command line chuck):\n//     %> chuck readme-LiSa2.ck\n//\n// to run (in miniAudicle):\n//     (just run it!)\n//--------------------------------------------------------------------\n// LiSa allows for multiple voice playback from a live-sampled buffer.\n// Useful for granular sampling (a la [munger~] from PeRColate) and\n// looping (a la LoopLoop, Jamman, Echoplex, etc....). The methods\n// are overloaded, taking a \"voice\" number as a first arg. if no\n// voice number is specified, LiSa assumes 0 => voice.\n//\n// Below is a simple example to show how to crossfade two voices.\n// See also the LiSa_munger examples for other approaches.\n//\n// Below the example find a (lengthy) command summary.\n//--------------------------------------------------------------------\n\n// signal chain; record a sine wave, play it back\nSinOsc s => Envelope e => LiSa10 loopme => dac;\n// direct\ns => e => dac;\n// set frequency\n440. => s.freq;\n// set gain\n0.25 => s.gain;\n\n// print channel info\n<<< \"LiSa channels:\", loopme.channels() >>>;\n\n// allocate memory in LiSa\n6::second => loopme.duration;\n\n// play s for a bit\n500::ms => now;\n\n// sweep the freq for fun\nEnvelope pitchmod => blackhole;\npitchmod.duration( 2000::ms );\npitchmod.value( s.freq() );\npitchmod.target( 880.0 );\n\n// confirm that the length of the buffer is what you expect\n<<< \"buffer duration = \", loopme.duration() / second >>>;\n\n// set times for recording fade in/out and sample loop length\n100::ms => dur recfadetime;\n1000::ms => dur mylooplen;\n// set envelope duration\ne.duration( recfadetime );\n\n// print\n<<< \"start recording input into LiSa...\", \"\" >>>;\n// start recording input; record 1 seconds worth\nloopme.record(1);\n// open envelope (can also do without the Envelope and use\n// loopme.recramp(dur) to set a recording ramp)\ne.keyOn();\n\n// calcuate later\nnow + (mylooplen - recfadetime) => time later;\n// go until now is later (or later)\nwhile(now < later)\n{\n    // set frequency\n    pitchmod.value() => s.freq;\n    // advance time\n    10::ms => now;\n}\n// close envelope\ne.keyOff();\n// let fade time pass\nrecfadetime => now;\n// print\n<<< \"stop recording input into LiSa...\", \"\" >>>;\n// stop recording input\nloopme.record(0);\n\n// disconnect direct input...\ns =< dac;\n// print\n<<< \"disconnect sine and hanging out...\", \"\" >>>;\n// and hang out for a bit\n1000::ms => now;\n\n// now, manipulate the sample\n// get a voicenumber; note that this voice won't actually be\n// reserved until you play it\nloopme.getVoice() => int voice1;\n\n// we'll play voice 1 forward; then crossfade with voice 2 backwards\n// set gain\nloopme.voiceGain( voice1, .5 );\n// set pan (hard left channel)\nloopme.pan( voice1, 0 );\n// play voice 1\nloopme.play( voice1, 1 );\n// print\n<<< \"playing LiSa voice 1 ( id:\", voice1, \")\" >>>;\n// let time pass\n(mylooplen - recfadetime) => now;\n\n// just as voice 1 is going to fade, bring in voice 2\nloopme.getVoice() => int voice2;\n// set play rate to go backwards\nloopme.rate( voice2, -1.0 );\n// set play head at the end\nloopme.playPos( voice2, mylooplen ); \n// set gain\nloopme.voiceGain( voice2, 0.5 );\n// set pan (hard right channel)\nloopme.pan( voice2, 1 );\n// play\nloopme.play( voice2, 1 );\n// print\n<<< \"playing LiSa voice 2 ( id:\", voice2, \")\" >>>;\n\n// wait until voice 1 had finished fading...\nrecfadetime => now;\n// turn off voice 1\nloopme.play( voice1, 0 );\n// print\n<<< \"stopping LiSa voice 1...\", \"\" >>>;\n\n// wait for voice 2 to finish\n1000::ms => now;\n\n// print\n<<< \"program ending...\", \"\" >>>;\n\n//--------------------------------------------------------------------\n// LiSa Command Summary:\n//\n//  mylisa.duration(dur); required -- sets max length of buffer\n//  mylisa.duration(); returns max length of buffer\n//  mylisa.record(1/0); turn on/off recording into buffer\n//  mylisa.getVoice() => voice (int); returns first free voice number\n//  mylisa.maxVoices(int); sets maximum # of allowable voices\n//  mylisa.play(voice, 1/0); turn on/off play for particular voice\n//  mylisa.rampUp(voice, dur); turn on play for voice with ramp\n//  mylisa.rampDown(voice, dur); ramp down voice and then turn off play\n//  mylisa.rate(voice, float); sets play rate for \"voice\"\n//  mylisa.playPos(voice, dur); sets playback position for \"voice\" within buffer\n//  mylisa.playPos(voice); returns playback position for \"voice\"\n//  mylisa.recordPos(dur); sets record position\n//  mylisa.recordPos(); gets record position\n//  mylisa.recRamp(dur); sets ramping for the edges of the record buffer\n//  mylisa.loopStart(dur, voice); sets loopstart point for \"voice\"\n//  mylisa.loopStart(voice); get loopstart\n//  mylisa.loopEnd(voice, dur); sets loopend point for \"voice\"\n//  mylisa.loopEnd(voice); gets loopend\n//  mylisa.loop(voice, 1/0); turn on/off looping for \"voice\"\n//  mylisa.loop(voice); get looping state\n//  mylisa.bi(voice, 1/0); turn on/off bidirectional looping for \"voice\"\n//  mylisa.bi(voice); get bi state\n//  mylisa.voiceGain(voice, float); sets gain \"voice\"\n//  mylisa.voiceGain(voice); gets gain for \"voice\"\n//  mylisa.loopEndRec(dur); set looping end point for recording\n//  mylisa.loopEndRec(); get ...\n//  mylisa.feedback(float); set feedback amount [0,1] for recording\n//  mylisa.feedback(); get...\n//  mylisa.clear(); clear recording buffer\n//  mylisa.pan(); returns pan value of voice 0\n//  mylisa.pan(float where); pans voice 0 where can be [0., 7.], to place voice across LiSa's 8 outputs\n//  mylisa.pan(int voice); returns pan value of voice\n//  mylisa.pan(int voice, float where); pans specified voice where can be [0., 7.], to place voice across LiSa's 8 outputs\n//\n// Note that that LiSa defaults to mono;\n// As of chuck 1.4.1.0 multi-channel LiSas can be instantiated\n// using the following UGens:\n//   LiSa2 (stereo)\n//   LiSa4 (quad),\n//   LiSa6 (6-channel, laptop orchestra edition)\n//   LiSa8 (8-channel),\n//   LiSa10 (10-channel, for compatibility)\n//   LiSa16 (16-channel)\n// The outputs of these LiSas can be sent to a multichannel dac, or\n// simply to other ugens, if it is desirable to process the channels\n// in different ways. These multiple channels are available\n// regardless of whether the dac is running > 2 chans. LiSaX's\n// multi-channel output can be manually connected through .chan(n).\n//\n// All of these commands should work without the \"voice\" arg;\n// 0 => voice will be assumed see online documentation for most\n// up-do-date listing...\n//--------------------------------------------------------------------\n",
                "data": []
            }
        },
        {
            "Gen10-test.ck": {
                "code": "// gen10 sinusoidal lookup table\n// ported to ChucK from rtcmix by dan trueman\n// see luke's page: http://www.music.columbia.edu/cmix/makegens.html#05\n\nPhasor drive => Gen10 g10 => dac;\n\n// can also lookup table values directly:\n//     g10.lookup(index);\n//     with index:[0,1]\n\n// load up the coeffs; amplitudes for successive partials\ng10.coefs( [1., 0.5, 0.3, 0.2] );\n\n// set frequency for reading through table\ndrive.freq(440.);\n\n// infinite time loop\nwhile (true)\n{\n    // advance time\n    500::ms => now;\n    // nothing needed to do, so lets look\n    // up some random parts of the table!\n    <<< g10.lookup( Math.random2f(0,1) ) >>>;\n}\n",
                "data": []
            }
        },
        {
            "LiSa-track2.ck": {
                "code": "//--------------------------------------------------------------------\n// name: LiSa-track2.ck\n// desc: Live sampling utilities for ChucK\n//       demonstrate using track == 1 mode with LiSa\n//\n// author: Dan Trueman, 2007\n//\n// when track == 1, the input is used to control playback position\n// input [0,1] will control playback position within loop marks input\n// values less than zero are multiplied by -1, so it is possible to\n// use audio signals [-1, 1] to control playback position, as in\n// waveshaping\n//--------------------------------------------------------------------\n// signal chain; record a sine wave, play it back\nSinOsc s => LiSa loopme => dac;\n// frequency\n440 => s.freq;\n// gain\n0.25 => s.gain;\n\n// alloc memory\n6::second => loopme.duration;\n1000::ms => loopme.loopEndRec;\n1000::ms => loopme.loopEnd;\n\n// set recording ramp time\nloopme.recRamp(50::ms);\n\n// start recording input\nloopme.record(1);\n// wait for a second\n1000::ms => now;\n// stop recording input\nloopme.record(0);\n\n// set track mode to 1, where the input chooses playback position\n1 => loopme.track;\n// set frequency\n0.5 => s.freq;\n// need to reset gain if we want to get the full loop length\n1 => s.gain;\n// set lisa gain\nloopme.gain( 0.75 );\n// play\nloopme.play( 1 );\n\n// advance time for 5 seconds\n5000::ms => now;\n// ramp down\nloopme.rampDown( 250::ms );\n// wait\n500::ms => now;\n\n// bye bye\n",
                "data": []
            }
        },
        {
            "LiSa-munger3.ck": {
                "code": "//--------------------------------------------------------------------\n// name: LiSa-munger3.ck\n// desc: Live sampling utilities for ChucK\n//\n// author: Dan Trueman, 2007\n//\n// These three example files demonstrate a couple ways to approach\n// granular sampling with ChucK and LiSa. All are modeled after the\n// munger~ from PeRColate. One of the cool things about doing this\n// in ChucK is that there is a lot more ready flexibility in\n// designing grain playback patterns; rolling one's own idiosyncratic\n// munger is a lot easier.\n//\n// Example 3 (below) uses the same structure as Example 2, but\n// replicates the groovy tune munging from the original munger~\n// helppatch (with pitch transposition filtering and all!).\n//--------------------------------------------------------------------\n\n// oscillator as source\nSinOsc s => dac;\ns.freq( 440 );\ns.gain( 0.25 );\n\n// play the munger song!\nEnvelope fsmooth => blackhole;\nspork ~ playtune(250::ms);\nspork ~ smoothtune(20::ms);\n\n// transposition table\n[0, 4, 7, -2, 12, 15] @=> int pitchtable[];\n\n// use three buffers to avoid clicks\nLiSa lisa[3];\n// allocated buffer size -- remains static\n1::second => dur bufferlen;\n// portion of the buffer size to use -- can vary\n0.1::second => dur reclooplen;\n// indices for rec and play buffers\n0 => int recbuf;\n2 => int playbuf;\n\n// go through each LiSa\nfor( 0 => int i; i < lisa.size(); i++ )\n{\n    // set LiSa params\n    lisa[i].duration(bufferlen);\n    lisa[i].loopEndRec(reclooplen);\n    lisa[i].maxVoices(30);\n    lisa[i].clear();\n    lisa[i].gain(0.2);\n    // if you want to retain earlier passes through the recording buff when loop recording:\n    // lisa[i].feedback(0.5); \n    // ramp at extremes of record buffer while recording\n    lisa[i].recRamp(20::ms);\n    lisa[i].record( false );\n    // connect s to each LiSa    \n    s => lisa[i] => dac;\n}\n\n// start recording in the recbuf LiSa\nlisa[recbuf].record( true );\n\n// create grains, rotate record and play bufs as needed\n// shouldn't click as long as the grainlen < bufferlen\nwhile( true )\n{\n    // will update record and playbufs to use every reclooplen\n    now + reclooplen => time later;\n\n    // toss some grains\n    while( now < later )\n    {\n        Math.random2f(0, 6) $ int => int newpitch; // choose a transposition from the table\n        Std.mtof(pitchtable[newpitch] + 60)/Std.mtof(60) => float newrate;\n        Math.random2f(50, 100) * 1::ms => dur newdur; // create a random duration for the grain\n\n        // spork off a grain!\n        spork ~ getgrain( playbuf, newdur, 20::ms, 20::ms, newrate );\n\n        // wait a bit.... then do it again, until we reach reclooplen\n        5::ms => now;\n    }\n\n    // rotate the record LiSa\n    lisa[recbuf++].record( false );\n    if( recbuf == lisa.size() ) 0 => recbuf;\n    lisa[recbuf].record( true );\n\n    // rotate the play LiSa\n    playbuf++;\n    if( playbuf == lisa.size() ) 0 => playbuf;\n}\n\n// for sporking grains; can do lots of different stuff here -- just one example here\nfun void getgrain(int which, dur grainlen, dur rampup, dur rampdown, float rate)\n{\n    // get an available voice\n    lisa[which].getVoice() => int newvoice;\n    \n    // make sure we got a valid voice\n    if( newvoice > -1 )\n    {\n        // set play rate\n        lisa[which].rate(newvoice, rate);\n        // set play position\n        lisa[which].playPos(newvoice, Math.random2f(0,1) * reclooplen);\n        // set ramp up duration\n        lisa[which].rampUp(newvoice, rampup);\n        // wait for grain length (minus the ramp-up and -down)\n        (grainlen - (rampup + rampdown)) => now;\n        // set ramp down duration\n        lisa[which].rampDown(newvoice, rampdown);\n        // for ramp down duration\n        rampdown => now;\n    }\n}\n\n// the munger song lives! thanks to luke dubois....\nfun void playtune( dur notelen )\n{       \n    // notes\n    [45, 45, 57, 57, 45, 57, 57, 47, 55, 47, 59, 60, 60, 57, 57, 57] @=> int notes[];\n    // note counter\n    0 => int notectr;\n\n    // set frequency to first note\n    Std.mtof(notes[0]) => fsmooth.value => s.freq;\n\n    // infinite time-loop\n    while( true )\n    {\n        // set frequency target\n        Std.mtof(notes[notectr++] + 12) => fsmooth.target;\n        // wrap note counter if reach end\n        if(notectr == notes.size()) 0 => notectr;\n        // wait for note length\n        notelen => now;\n    }\n}\n\n// smooth note to note\nfun void smoothtune( dur smoothtime )\n{\n    // set smooth duration\n    fsmooth.duration( smoothtime );\n    while( true )\n    {\n        fsmooth.value() => s.freq;\n        1::ms => now;\n    }\n}\n",
                "data": []
            }
        },
        {
            "Dyno-compress.ck": {
                "code": "//--------------------------------------|\n// Dyno demo 2: \"Compressor? I didn't even touch 'er!\"\n// Takes a silly little plucked string demo and runs it through a \n// compressor to enhance sustain. (Ostensibly.) Note that there \n// are many other (better) reasons to use compressors.\n//\n// authors: Matt Hoffman (mdhoffma at cs.princeton.edu)\n//--------------------------------------|\n\n// plucked string, dynamics processor, reverb, dac.\nStifKarp m => Dyno d => JCRev r => dac;\n\n// set reverb params\n0.75 => r.gain;\n0.01 => r.mix;\n\n// set dyno to default compress mode\nd.compress();\n// set release time to be quite long to enhance sustain\n2000::ms => d.releaseTime;\n// set threshold to be a bit lower for more pronounced effect.\n0.2 => d.thresh;\n// set slope (in dB) above the threshold to 1/3 of what it would naturally be\n0.33 => d.slopeAbove;\n// compensate for the gain reduction\n2 => d.gain;\n\n// set plucked string params\n0.1 => m.pickupPosition;\n0.0 => m.sustain;\n0.0 => m.stretch;\n\n// go\nwhile(true)\n{\n\t// play a random note\n\tStd.mtof( Math.random2(60, 90) ) => m.freq;\n\n    // twice\n    repeat( 2 )\n    {\n        // say whether this pluck is compressed or not\n        if(d.op() < 0)\n            <<< \"uncompressed\" >>>;\n        else\n            <<< \"compressed\" >>>;\n        \n        0.5 => m.pluck;\n        2000::ms => now;\n        \n        // make the next note compressed if this one wasn't, or vice versa\n        -d.op() => d.op;\n    }\n}\n",
                "data": []
            }
        },
        {
            "Gen9-test.ck": {
                "code": "// gen9 inharmonic sinusoidal lookup table\n// ported to ChucK from rtcmix by dan trueman\n// see luke's page: http://www.music.columbia.edu/cmix/makegens.html\n\n// patch\nPhasor drive => Gen9 g9 => dac;\n\n// can also lookup table values directly:\n//     g9.lookup(index);\n//     with index:[0,1]\n\n// load up the coeffs\n// these are in triplets:\n//     harmonic partial ratio, amplitude, phase\n//     see the RTcmix page: \n//     http://www.music.columbia.edu/cmc/Rtcmix/docs/scorefile/gen9.html\n//     for nice documentation of this gen\n[1., 1., 0.,   2, 0.5, 90.,   3., 0.2, 180.] => g9.coefs;\n// [1., 1., 0.] => g9.coefs; // a simple one\n\n// make it quiet\n0.1 => g9.gain;\n\n// set frequency for reading through table\ndrive.freq( 440. );\n\n// create an envelope to scan through the table values\n// so we can look at them as well as hear them\nEnvelope e => blackhole;\ne.duration(10000::ms);\n0. => e.value;\ne.keyOn();\n\n// yay\nwhile (true)\n{\n    // print\n    <<< e.value(), g9.lookup(e.value()) >>>;\n\n    // end\n    if( e.value() == 1. ) break;\n\n    // advance time\n    10::ms => now;\n}\n",
                "data": []
            }
        },
        {
            "readme-GenX.ck": {
                "code": "//-----------------------------------------------------------------------------\n// name: readme-GenX.ck\n// desc: old and new lookup table utilities for ChucK\n//\n// author: Dan Trueman, 2007\n//\n// These utilities bring the familiar lookup table capabilities of the MusicX\n// languages to ChucK. They all create an internal lookup table given various\n// parameters set by the user. This table can then be read at the audio rate\n// (with Phasor, for example, or any other source) or simply read with .value()\n// calls. \n//\n// A simple example for gen10 is included here. gen10 creates a table of \n// harmonically related sinusoids; the user sets the relative weights of the\n// harmonics with an array of floats. The phasor UG creates a continuous \n// lookup value between 0 and 1 (values less than 0 are multiplied by -1, so \n// SinOsc and other [-1,1] sources can be used as well).\n//\n// All of these other than WarpTable were ported from RTcmix (thanks rtcmix folks!).\n//-----------------------------------------------------------------------------\n\n// patch\nPhasor drive => Gen10 g10 => dac;\n// can also lookup table values directly:\n//     g10.lookup(index);\n//     with index:[0,1]\n\n// load up the coeffs; amplitudes for successive partials\ng10.coefs( [1., 0.5, 0.3, 0.2] );\n\n// set frequency for reading through table\ndrive.freq( 440. );\n\n// go\nwhile( true ) { 1::day => now; }\n\n//-----------------------------------------------------------------------------\n\n/*\nthe GenX library includes:\n\ngen5: exponential line segment table generator (probably superceded by CurveTable)\ngen7: line segment table generator (probably superceded by CurveTable)\ngen9: inharmonic sinusoidal lookup table with ratio and phase control\ngen10: sinusoidal lookup table *without* ratio and phase control (only partial amp control)\ngen17: chebyshev polynomial lookup table\nCurveTable: flexible Curve/Line segment table generator\nWarpTable: end-constrained mapping table, useful for control signal conditioning\n*/\n",
                "data": []
            }
        },
        {
            "LiSa-munger2.ck": {
                "code": "//--------------------------------------------------------------------\n// name: LiSa-munger2.ck\n// desc: Live sampling utilities for ChucK\n//\n// author: Dan Trueman, 2007\n//\n// These three example files demonstrate a couple ways to approach\n// granular sampling with ChucK and LiSa. All are modeled after the\n// munger~ from PeRColate. One of the cool things about doing this\n// in ChucK is that there is a lot more ready flexibility in\n// designing grain playback patterns; rolling one's own idiosyncratic\n// munger is a lot easier. \n//\n// Example 2 (below) demonstrates the rotating buffer approach used\n// in the munger~; see after the code for an explanation of this\n// approach. presumably someone smarter than me will dream up a more\n// elegant technique. \n//--------------------------------------------------------------------\n\n// oscillator as source\n// fun scary sounds!!!\nSinOsc s => dac;\n// set frequency\ns.freq( 440 );\n// set gain\ns.gain( 0.25 );\n\n// modulate\nSinOsc freqmod => blackhole;\n// modulation frequency\nfreqmod.freq( 0.1 );\n\n// use three LiSas\nLiSa lisa[3];\n// buffer length\n1::second => dur bufferlen;\n0 => int recbuf;\n2 => int playbuf;\n\n// LiSa params\nfor( 0 => int i; i < 3; i++ )\n{\n    lisa[i].duration( bufferlen );\n    lisa[i].maxVoices( 30 );\n    lisa[i].clear();\n    lisa[i].gain( 0.1 );\n    lisa[i].feedback( 0.5 );\n    lisa[i].recRamp( 20::ms );\n    lisa[i].record( false );\n    // connect s to each LiSa\n    s => lisa[i] => dac;\n}\n\n// start recording in the recbuf LiSa\nlisa[recbuf].record( true );\n\n// create grains, rotate record and play bufs as needed\n// shouldn't click as long as the grainlen < bufferlen\nwhile( true )\n{\n    // compute later time\n    now + bufferlen => time later;\n\n    // toss some grains\n    while( now < later )\n    {\n        // new rate and duration\n        Math.random2f(0.5, 2.5) => float newrate;\n        Math.random2f(250, 600)::ms => dur newdur;\n\n        // spork a grain!\n        spork ~ getgrain(playbuf, newdur, 20::ms, 20::ms, newrate);\n        // freq\n        freqmod.last() * 400. + 800. => s.freq;\n        // advance time\n        10::ms => now;\n    }\n\n    // rotate the record LiSa\n    lisa[recbuf++].record( false );\n    if( recbuf == 3 ) 0 => recbuf;\n    lisa[recbuf].record( true );\n\n    // rotate the play LiSa\n    playbuf++;\n    if( playbuf == 3 ) 0 => playbuf;\n}\n\n// sporkee: a grain!\nfun void getgrain( int which, dur grainlen, dur rampup, dur rampdown, float rate )\n{\n    // get an available voice\n    lisa[which].getVoice() => int newvoice;\n\n    // make sure we got a valid voice   \n    if( newvoice > -1 )\n    {\n        // set play rate\n        lisa[which].rate(newvoice, rate);\n        // set play position\n        lisa[which].playPos(newvoice, Math.random2f(0,1) * bufferlen);\n        // set ramp up duration\n        lisa[which].rampUp(newvoice, rampup);\n        // wait for grain length (minus the ramp-up and -down)\n        (grainlen - (rampup + rampdown)) => now;\n        // set ramp down duration\n        lisa[which].rampDown(newvoice, rampdown);\n        // for ramp down duration\n        rampdown => now;\n    }\n}\n\n/*--------------------------------------------------------------------\nRotating Buffer Explanation (from the munger~ source code) \n\nthe munger~ (and scrubber~) use a rotating three-buffer scheme for\ncreating clickless grains.  basically, you don't want to be recording\nnew data anywhere in the buffer where a grain might be playing. so,\nwe divide the buffer into three equal parts (B1, B2, B3). at the\noutset, let's say:\n\nB1 = the recording buffer part (RB)\nB2 = a part where nothing is happening (QB, for Quiet Buffer)\nB3 = a part where grains are playing from (PB)\n\nlet's say each part is N samples long. after we have recorded N\nsample into B1, we rotate the functionality, so now:\n\nB1 = PB\nB2 = RB\nB3 = QB\n\nwhy?\n\nas long as the grains are guaranteed to be no longer than N samples\n(adjusted for playback rate) we are assured that none of them will\nhave clicks due to recording discontinuities. we need the Quiet\nBuffer because when the rotation happens, there may still be grains\nplaying in what was the PB and is now the QB.\n\nso, this is a bit cumbersome, but it works. the code here is super\nduper ugly -- i was learning to code and working out this scheme on\nthe fly, and the code reflects that, but it does work.\n--------------------------------------------------------------------*/\n",
                "data": []
            }
        },
        {
            "GenX-WarpTable-test.ck": {
                "code": "// WarpTable: end-constrained mapping table\n//\n// created originally for the PLOrk Utilities by dan trueman\n// ported to ChucK by dan trueman, 2007.\n//\n// this table is mostly useful for conditioning control signals\n// it is end-constrained in that an input of 0 always yields 0\n// and an output of 1 always yields 1 \n//\n//     WarpTable.value(0) => 0 always\n//     WarpTable.value(1) => 1 always\n//\n// expects input [0,1], generates output [0,1]\n//\n// what happens in between is what is interesting....\n//\n// WarpTable is useful for mapping sensors and focusing\n// attention on:\n//     --either extreme (asymmetrical warping)\n//     --both extremes (symmetrical warping)\n//     --central values (also symmetrical warping)\n//\n// the first coefficient sets the asymmetrical warping value\n//     --asym = 1. => linear\n//     --asym > 1. => exponential (focusing resolution on lower output values)\n//     --asym < 1. => log (focusing resolution on higher output values)\n//\n// the second coefficient sets the symmetrical warping value\n//     --sym = 1. => linear\n//     --sym < 1. => focusing resolution around central (0.5) output value\n//         __________/\n//        /\n//\n//      --sym > 1. => focusing resolution on extremes (0 and 1) output values\n//                     _____\n//              _____/\n//\n// and of course they can be combined to create related warped shapes\n\n// make one\nWarpTable w;\n\n// some examples:\nw.coefs( [4., 1.] );    // fairly strong focus on low values; 4 is useful for octave mappings\n// w.coefs([0.25, 1.]);    // some focus on high values\n// w.coefs([1., 0.3]);     // strong focus on central values\n// w.coefs([1., 3.]);      // strong focus on hi/low values\n// w.coefs([10., 3.]);     // some focus on high values, strong focus on low values; warped\n// w.coefs([0.1, 0.3]);\n// w.coefs([1., 1.]);      // linear\n\n// create an envelope to scan through the table values\nEnvelope e => blackhole;\ne.duration( 10000::ms );\n0. => e.value;\ne.keyOn(); // ramp 0 to 1 in 10 seconds\n\n// on your mark\nwhile( true )\n{\n    // print\n    <<< e.value(), w.lookup(e.value()) >>>;\n\n    // end\n    if( e.value() == 1. ) break;\n\n    // advance time\n    10::ms => now;\n}\n",
                "data": []
            }
        },
        {
            "LiSa-simplelooping.ck": {
                "code": "//-----------------------------------------------------------------------------\n// name: LiSa-simplelooping.ck\n// desc: Live sampling utilities for ChucK\n//\n// author: Dan Trueman, 2007\n//\n// Another simple example of LiSa, demonstrating dopey looping...\n//-----------------------------------------------------------------------------\n\n// signal chain; record a sine wave, play it back\nSinOsc s => LiSa loopme => dac;\n// set frequency\n440. => s.freq;\n// set gain\n0.25 => s.gain;\n\n// alloc memory\n1::second => loopme.duration;\n// ramp time of 200 ms\nloopme.recRamp( 200::ms );\n\n// start recording input\nloopme.record(1);\n// 1 second later\n1000::ms => now;\n// stop recording;\nloopme.record(0);\n\n// next, start playing what was just recorded...\n\n// set playback rate\nloopme.rate(1.5);\n// set loop to true\nloopme.loop(1);\n// enable bi-directional looping\nloopme.bi(1);\n// play (voice 0)\nloopme.play(1);\n\n// keep alive loop\nwhile( true )\n{ 500::ms => now; }\n\n// bye bye\n",
                "data": []
            }
        },
        {
            "LiSa-munger1.ck": {
                "code": "//---------------------------------------------------------------------\n// name: LiSa-munger1.ck\n// desc: Live sampling utilities for ChucK\n//       (also see: LiSa-stereo.ck for stereo version of this)\n//\n// author: Dan Trueman, 2007\n//\n// These three example files demonstrate a couple ways to approach\n// granular sampling with ChucK and LiSa. All are modeled after the\n// munger~ from PeRColate. One of the cool things about doing this\n// in ChucK is that there is a lot more ready flexibility in\n// designing grain playback patterns; rolling one's own idiosyncratic\n// munger is a lot easier. \n//\n// Example 1 (below) is simple, but will feature some clicking due\n// to playing back over the record-point discontinuity.\n//---------------------------------------------------------------------\n// patch\nSinOsc s => LiSa lisa => dac;\n// thru\ns => dac;\n\n// LiSa duration (this also allocates internals)\nlisa.duration( 1::second );\n// set max voices\nlisa.maxVoices( 30 );\n// set ramp duration\nlisa.recRamp( 20::ms );\n\n// frequency\ns.freq( 440 );\n// gain\ns.gain( 0.25 );\n\n// modulator\nSinOsc freqmod => blackhole;\n// modulation frequency\nfreqmod.freq( 0.1 );\n\n// set it recording constantly; loop records by default\nlisa.record( true );\n// set gain\nlisa.gain( 0.1 );\n\n// compute 1 second from now\nnow + 1000::ms => time later;\nwhile( now < later )\n{\n    // update frequency\n    freqmod.last() * 500. + 200. => s.freq;\n    10::ms => now;\n}\n\n// stop recording\nlisa.record( false );\n// set gain to 0 for SinOsc\ns.gain( 0 );\n\n// this arrangment will create some clicks because of discontinuities\n// from the loop recording. to fix, need to make a rotating buffer \n// approach. see the next two example files...\nwhile( true )\n{\n    // random\n    Math.random2f( 1.5, 2.0 ) => float newrate;\n    Math.random2f( 250, 750 )::ms => dur newdur;\n\n    // spork grain\n    spork ~ getgrain( newdur, 20::ms, 20::ms, newrate );\n\n    // advance time\n    10::ms => now;\n}\n\n// sporkee: entry point for a grain!\nfun void getgrain( dur grainlen, dur rampup, dur rampdown, float rate )\n{\n    // get an available voice\n    lisa.getVoice() => int newvoice;\n\n    // make sure we got a valid voice   \n    if( newvoice > -1 )\n    {\n        // set play rate\n        lisa.rate(newvoice, rate);\n        // set play position\n        lisa.playPos(newvoice, 20::ms);\n        // lisa.playpos(newvoice, Math.random2f(0., 1000.)::ms);\n        // set ramp up duration\n        lisa.rampUp( newvoice, rampup );\n        // wait for grain length (minus the ramp-up and -down)\n        (grainlen - (rampup + rampdown)) => now;\n        // set ramp down duration\n        lisa.rampDown( newvoice, rampdown );\n        // for ramp down duration\n        rampdown => now;\n    }\n}\n",
                "data": []
            }
        },
        {
            "Gen5-test.ck": {
                "code": "// gen5: exponential line segment table generator\n// probably superceded by CurveTable\n// ported to ChucK from rtcmix by dan trueman\n// see luke's page: http://www.music.columbia.edu/cmix/makegens.html#02\n\n// make one, no sound here\nGen5 g5;\n\n// set up the values [0,1] and distances in the table\n// first arg is initial value \n// followed by pairs indicating distance (total distance = 1)\n// and destination value for exponential segments\n// NOTE: real minimum value is 0.000001\n\n// the following will create a triangle, with a peak at 1 halfway\n// through the table\n[0., 0.5, 1., 0.5, 0.] => g5.coefs;\n\n// create an envelope to scan through the table values\n// creates a continuous input from 0 -> 1 over 10 seconds\nEnvelope e => blackhole;\ne.duration( 10000::ms );\n0. => e.value;\ne.keyOn();\n\n// loop\nwhile (true)\n{\n    // print\n    <<<e.value(), g5.lookup(e.value())>>>;\n\n    // end\n    if( e.value() == 1. ) break;\n\n    // advance time\n    10::ms => now;\n}\n",
                "data": []
            }
        },
        {
            "Gen17-test.ck": {
                "code": "// gen17 chebyshev lookup table\n//\n// ported to ChucK from rtcmix by dan trueman\n// see luke's page: http://www.music.columbia.edu/cmix/makegens.html#06\n//\n// like gen10, this is a series of weightings for successive partials\n//   also http://www.music.columbia.edu/cmc/Rtcmix/docs/scorefile/gen17.html\n//   and http://www.music.columbia.edu/cmc/Rtcmix/docs/scorefile/maketable.html (scroll down)\n//   for nice documentation of this gen\n// see also: http://math.fullerton.edu/mathews/n2003/ChebyshevPolyMod.html\n// for info about chebyshev polynomials in general\n//\n// the main feature to be aware of is that these functions are primarily\n// useful for waveshaping, so in this case we drive it with a \n// SinOsc instead of a Phasor. see, for example:\n//   http://crca.ucsd.edu/~msp/techniques/v0.08/book-html/node74.html\n//   http://en.wikipedia.org/wiki/Distortion_synthesis\n\n// the patch\nSinOsc drive => Gen17 g17 => dac;\n\n// load up the coeffs\n[1., 0.5, 0.25, 0.125, 0.06, 0.03, 0.015] => g17.coefs;\n// some examples to try\n// [1., 0.5, 0.3, 0.2] => g17.coefs;\n// [1., 0.5, 0.25, 0.125, 0.06, 0.03, 0.015] => g17.coefs;\n// [1., 0.] @=> g17.coefs; // a simple one\n\n// make it quiet\n0.1 => g17.gain;\n\n// set frequency for reading through table\ndrive.freq( 440 );\n// sounds better not going to extremes\ndrive.gain( 0.99 ); \n\n// create an envelope to scan through the table values\n// so we can look at them as well as hear them\nEnvelope e => blackhole;\ne.duration( 10000::ms );\n0. => e.value;\ne.keyOn();\n\n// loop\nwhile (true)\n{\n    // print\n    <<< e.value(), g17.lookup(e.value()) >>>;\n    \n    // stop when envelope reaches 1\n    if( e.value() == 1. ) break;\n\n    // advance time\n    10::ms => now;\n}\n",
                "data": []
            }
        },
        {
            "GenX-CurveTable-test.ck": {
                "code": "// CurveTable: flexible Curve/Line Segment table generator\n\n// make one\nCurveTable c;\n\n// coeffs are all FLOATS, specifying proportional times, values, and curvature:\n// [time0, value0, curvature to next, time1, value1, curvature,..\n//      timeN-1, valueN-1, curvaturen-1, timeN, valueN]\n\n// times => ascending unitless values (NOT Chuck Time values)\n// values => whatever\n// curvature(0) => linear\n// curvature(<0) => convex\n// curvature(>0) => concave\n\n// see:\n//     http://www.music.columbia.edu/cmc/Rtcmix/docs/scorefile/maketable.html#curve\n//     for more documentation\n\n// set\n[0., 0., -0.5, 1., 1., 0.5, 2., -1.] => c.coefs;\n\n// create an envelope to scan through the table values\nEnvelope e => blackhole;\ne.duration(10000::ms);\n0. => e.value;\ne.keyOn(); //ramp to 1 in 10 seconds\n\n// patch\nPhasor p => c => dac;\n// set\n440. => p.freq;\n\n// ready\nwhile (true)\n{\n    // print\n    <<< e.value(), c.lookup(e.value()) >>>;\n    \n    // end\n    if(e.value() == 1.) break;\n\n    // advance time\n    10::ms => now; \n}\n",
                "data": []
            }
        },
        {
            "readme-LiSa1.ck": {
                "code": "//-----------------------------------------------------------------------------\n// name: readme-LiSa1.ck\n// desc: Live sampling utilities for ChucK\n//\n// the LiSa ugens allow realtime recording of audio to a buffer for\n// various kinds of manipulation. Below is a simple example\n// demonstrating the basic functionality of LiSa.\n//\n// See readme-LiSa2.ck for a command summary and instructions for\n// doing multiple voice playback.\n//\n// author: Dan Trueman, 2007\n//-----------------------------------------------------------------------------\n\n// signal chain; record a sine wave, play it back\nSinOsc s => LiSa saveme => dac;\n// monitor the input\ns => dac;\n\n// alloc memory; required\n6::second => saveme.duration;\n// freq\n440 => s.freq;\n// gain\n0.25 => s.gain;\n\n// start recording input\nsaveme.record(1);\n// let time pass for 2 seconds\n.5::second => now;\n// stop recording\nsaveme.record(0); \n\n// disconnect; stop monitoring input\ns =< dac;\n\n// start playing what was just recorded, with panning...\n// set playback rate\nsaveme.rate(1.5);\n// set pan (0 is hard left, 1 is hard right)\nsaveme.pan(0.0);\n// start playing, with a ramp up\n// (use saveme.play(1) to start playing without ramp)\nsaveme.rampUp(500::ms); \n\n// hang for a bit\n500::ms => now;\n\n// rampdown\n// (use saveme.play(0) to stop playing without ramp)\nsaveme.rampDown( 500::ms );\n\n// wait for ramp to finish\n600::ms => now;\n\n// bye bye\n",
                "data": []
            }
        },
        {
            "LiSa-load.ck": {
                "code": "//-----------------------------------------------------------------------------\n// name: LiSa-load.ck\n// desc: function for loading an audio file into LiSa\n//\n// author: Dan Trueman, original example (2007): was LiSa-SndBuf.ck\n//         Ge Wang, modified example (2021): rolled function, added twilight\n//                  sound (see twilight-granular-kb-interp.ck for more info)\n//                  and bi-directional loop\n//-----------------------------------------------------------------------------\n// this example shows how to open a soundfile and use it in LiSa. someday LiSa\n// may be able to open soundfiles directly, but don't hold your breath. \n//\n// note that unlike SndBuf, LiSa wants a dur (not an int) to specify the index\n// of the sample location\n//-----------------------------------------------------------------------------\n\n// one-stop function for creating a LiSa, loaded with the specified audio file\nload( me.dir() + \"twilight/twilight-granular.aiff\" ) @=> LiSa @ lisa;\n// connect\nlisa => dac;\n\n// party on...\n2 => lisa.rate; // rate!\n1 => lisa.loop; // loop it!\n1 => lisa.bi; // bi-directional loop!\n1 => lisa.play; // play!\n\n// commence party\nwhile( true ) 1::second => now;\n\n// create a new LiSa pre-loaded with the specified file\nfun LiSa load( string filename )\n{\n    // sound buffer\n    SndBuf buffy;\n    // load it\n    filename => buffy.read;\n\n    // instantiate new LiSa (will be returned)\n    LiSa lisa;\n    // set duration\n    buffy.samples()::samp => lisa.duration;\n\n    // transfer values from SndBuf to LiSa\n    for( 0 => int i; i < buffy.samples(); i++ )\n    {\n        // args are sample value and sample index\n        // (dur must be integral in samples)\n        lisa.valueAt( buffy.valueAt(i), i::samp );        \n    }\n\n    // set default LiSa parameters; actual usage parameters intended\n    // to be set to taste by the user after this function returns\n    lisa.play( false );\n    lisa.loop( false );\n\n    return lisa;\n}\n",
                "data": []
            }
        },
        {
            "LiSa-track5.ck": {
                "code": "//--------------------------------------------------------------------\n// name: LiSa-track5.ck\n// desc: live sampling utilities for ChucK\n//       demonstrate using track == 2 mode with LiSa\n//\n// author: Dan Trueman, 2007\n//--------------------------------------------------------------------\n\n// patch\nLiSa loopme => dac;\n// use for loading audio file (also see example: LiSa-load.ck)\nSndBuf buf;\n\n// change this path to your own sample\nme.dir() + \"geetar.wav\" => buf.read;\n// set lisa buffer size to sample size\nbuf.samples()::samp => loopme.duration;\n// transfer values from SndBuf to LiSa\nfor( 0 => int i; i < buf.samples(); i++ )\n{ loopme.valueAt(buf.valueAt(i), i::samp); }\n\n// set sync/track mode to 2, where the input chooses playback\n// position interpreted as a time value\n// again, negative values are multiplied internally by -1\n2 => loopme.sync;\n\n// use an oscillator to set playback position\nSinOsc tracker => loopme;\n// step signal as offset\nStep off => loopme;\n\n// tracker parameters; will determine how far into the buffer\n// to go (gain), with what offset (off) and with what speed (freq)\n0.05 => tracker.freq;\n// we'll loop over half of the buffer\nloopme.duration() / 4::samp => tracker.gain;\n//starting at the midpoint\nloopme.duration() / 2::samp => off.next;\n\n// set gain\n0.5 => loopme.gain;\n// play it back\n1 => loopme.play;\n\n// time loop\nwhile( true )\n{\n    // monitor where we're playing back from in the buffer\n\t<<< ( off.last() + tracker.last() ) / 44100 >>>;\n\t50::ms => now; \n}\n",
                "data": [
                    "https://raw.githubusercontent.com/ccrma/chuck/main/examples/special/geetar.wav"
                ]
            }
        },
        {
            "Gen7-test.ck": {
                "code": "// gen7: line segment table generator\n// probably superceded by CurveTable\n// ported to ChucK from rtcmix by dan trueman\n// see luke's page: http://www.music.columbia.edu/cmix/makegens.html#03\n\n// make one, no sound\nGen7 g7;\n\n// set up the values [0,1] and distances in the table\n// first arg is initial value \n// followed by pairs indicating distance (total distance = 1)\n// and destination value for linear segments\n\n// set coefficients\n[0., 0.5, 1., 0.5, 0.] => g7.coefs;\n\n// create an envelope to scan through the table values\nEnvelope e => blackhole;\ne.duration(10000::ms);\n0. => e.value;\ne.keyOn();\n\n// loop\nwhile (true)\n{\n    // print\n    <<< e.value(), g7.lookup(e.value()) >>>;\n\n    // end\n    if(e.value() == 1.) break;\n\n    // advance time\n    10::ms => now;\n}\n",
                "data": []
            }
        },
        {
            "LiSa-track1.ck": {
                "code": "//--------------------------------------------------------------------\n// name: LiSa-track1.ck\n// desc: live sampling utilities for ChucK\n//       demonstrate using track == 1 mode with LiSa\n//\n// author: Dan Trueman, 2007\n//\n// when track == 1, the input is used to control playback position\n// input [0,1] will control playback position within loop marks values\n// less than zero are multiplied by -1, so it is possible to use audio\n// signals [-1, 1] to control playback position, as in waveshaping\n//--------------------------------------------------------------------\n\n// signal chain; record a sine wave, play it back\nSinOsc s => LiSa loopme => dac;\n// frequency\n440 => s.freq;\n// gain\n0.25 => s.gain;\n\n// alloc LiSa memory\n6::second => loopme.duration;\n1000::ms => loopme.loopEndRec;\n1000::ms => loopme.loopEnd;\n\n// set recording ramp time\nloopme.recRamp(25::ms);\n\n// start recording input\nloopme.record(1);\n// wait for a second\n1000::ms => now;\n// stop recording input\nloopme.record(0);\n\n// set track mode to 1, where the input chooses playback position\n// note that you can still record this input\n1 => loopme.track;\n// disconnect sinosc as input\ns =< loopme;\n// use envelope to control playback position\nStep i => Envelope e => loopme;\n// set step hold value\n1 => i.next;\n\n// play it forward twice speed\n500::ms => e.duration;\n// open envelope\ne.keyOn();\n// play\nloopme.play(1);\n// advance time\n500::ms => now;\n\n// now backwards half speed\n2000::ms => e.duration;\n// close envelope\ne.keyOff();\n// advance time\n2000::ms => now;\n// stop playing\nloopme.play(0);\n\n// bye bye\n",
                "data": []
            }
        },
        {
            "LiSa-trigger.ck": {
                "code": "//--------------------------------------------------------------------\n// name: LiSa-trigger.ck\n// desc: Live sampling utilities for ChucK\n//\n// author: Dan Trueman, 2007\n//\n// based on the S.M.E.L.T. (http://smelt.cs.princeton.edu/) envelope\n// follower trigger program will trigger start and stop to one-shot\n// LiSa buffers. a sort of triggered delay line, so the delays follow\n// the player rather than being static. Success depends on tuning the\n// envelope follower closely to the input gains on however you are\n// getting audio into ChucK.  Mileage will vary....\n//--------------------------------------------------------------------\n\n// patch\nadc => Gain g => OnePole p => blackhole;\n// square the input, by chucking adc to g a second time\nadc => g;\n// set g to multiply its inputs\n3 => g.op;\n\n// set pole position, influences how closely the envelope follows the input\n//   : pole = 0 -> output == input; \n//   : as pole position approaches 1, follower will respond more slowly to input\n0.995 => p.pole;\n// thresholds\n.0001 => float threshold;\n.00005 => float releaseThresh;\n\n// duration between successive polling\n10::ms => dur pollDur;\n\n// LiSa stuff\nadc => LiSa lisa => dac;\nlisa.duration(25::second);\nlisa.recRamp(20::ms);\n\n// start recording input\nlisa.record(1);\n// voice variable\n-1 => int voice;\n// rate\nfloat rate;\n\n// read command line args; set rate\n// be nice to have pitch follower determine this, or some kind of table....\nStd.atof(me.arg(0)) => rate;\nif( rate == 0 ) 1. => rate;\n<<< \"setting rate to: \", rate >>>;\n\n// events\nEvent attacks[10];\ndur newstarttime, newlen;\ntime starttime_real;\n\n// infinite time loop\nwhile( true )\n{\n    // detect onset\n    if( p.last() > threshold )\n    {\n        // do something\n        <<< \"attack!; starting voice\", voice >>>;\n        // play last sample\n        if( voice > -1 ) attacks[voice].signal();\n        lisa.recPos() => newstarttime;\n        now => starttime_real;\n        \n\t\t// wait for release\n        while( p.last() > releaseThresh ) { pollDur => now; }\n        <<< \"release...\" >>>;\n\n\t\t// spork off new sample\n\t\tnow - starttime_real => newlen;\n        lisa.getVoice() => voice;\n        if( voice > -1 ) spork ~ playlast( attacks[voice], newstarttime, newlen, rate, voice );\n    }\n    \n    // determines poll rate\n    pollDur => now;\n}\n\n// sporkee\nfun void playlast( Event on, dur starttime, dur len, float newrate, int myvoice ) \n{\n\tif( newrate == 0. ) 1. => newrate;\n    <<< \"sporking shred with rate: \", newrate >>>;\n    if( rate > 0. ) lisa.playPos( myvoice, starttime );\n    else lisa.playPos( myvoice, lisa.recPos() - 1::ms );\n\n    // wait    \n    on => now;\n\n    lisa.rate( myvoice, newrate );\n    lisa.rampUp( myvoice, 20::ms );\n\n    Math.fabs( newrate ) => float absrate;\n    len / absrate => now;\n    lisa.rampDown( myvoice, ( 250 / absrate )::ms );\n    ( 250 / absrate )::ms => now;\n    \n    // bye bye shred....\n}\n",
                "data": []
            }
        },
        {
            "LiSa-stereo.ck": {
                "code": "//---------------------------------------------------------------------\n// name: LiSa-stereo.ck\n// desc: Live sampling utilities for ChucK (stereo edition)\n//\n// this can readily adapted to more channels, using one of the\n// following:\n//   ----\n//   LiSa2 (stereo)\n//   LiSa4 (quad),\n//   LiSa6 (6-channel, laptop orchestra edition)\n//   LiSa8 (8-channel),\n//   LiSa10 (10-channel, for compatibility)\n//   LiSa16 (16-channel)\n//   ----\n// The outputs of these LiSas can be sent to a multichannel dac, or\n// simply to other ugens, if it is desirable to process the channels\n// in different ways. These multiple channels are available\n// regardless of whether the dac is running > 2 chans. LiSaX's\n// multi-channel output can be manually connected through .chan(n).\n//\n// author: Dan Trueman, 2007 (LiSa-munger1.ck)\n//         Ge Wang 2023 (LiSa-stereo.ck, based on the above)\n//---------------------------------------------------------------------\n// patch\nSinOsc s => LiSa2 lisa => dac;\n// thru\ns => dac;\n\n// LiSa duration (this also allocates internals)\nlisa.duration( 1::second );\n// set max voices\nlisa.maxVoices( 30 );\n// set voice pan\nfor( int v; v < lisa.maxVoices(); v++ )\n{\n    // can pan across all available channels\n    // note LiSa.pan( voice, [0...channels-1] )\n    lisa.pan( v, Math.random2f( 0, lisa.channels()-1 ) );\n}\n// set ramp\nlisa.recRamp( 20::ms );\n\n// frequency\ns.freq( 440 );\n// gain\ns.gain( 0.25 );\n\n// modulator\nSinOsc freqmod => blackhole;\n// modulation frequency\nfreqmod.freq( 0.1 );\n\n// start recording; will loop-record by default\nlisa.record( true );\n// set gain\nlisa.gain( 0.1 );\n\n// compute 1 second from now\nnow + 1000::ms => time later;\nwhile( now < later )\n{\n    // update frequency\n    freqmod.last() * 500. + 200. => s.freq;\n    10::ms => now;\n}\n\n// stop recording\nlisa.record( false );\n// set gain to 0 for SinOsc\ns.gain( 0 );\n\n// this arrangment will create some clicks because of discontinuities\n// from the loop recording. to fix, need to make a rotating buffer \n// approach. see the next two example files...\nwhile( true )\n{\n    // random\n    Math.random2f( 1.5, 2.0 ) => float newrate;\n    Math.random2f( 250, 750 )::ms => dur newdur;\n\n    // spork grain\n    spork ~ getgrain( newdur, 20::ms, 20::ms, newrate );\n\n    // advance time\n    10::ms => now;\n}\n\n// sporkee: entry point for a grain!\nfun void getgrain( dur grainlen, dur rampup, dur rampdown, float rate )\n{\n    // get an available voice\n    lisa.getVoice() => int newvoice;\n\n    // make sure we got a valid voice   \n    if( newvoice > -1 )\n    {\n        // set play rate\n        lisa.rate(newvoice, rate);\n        // set play position\n        lisa.playPos(newvoice, 20::ms);\n        // lisa.playpos(newvoice, Math.random2f(0., 1000.)::ms);\n        // set ramp up duration\n        lisa.rampUp( newvoice, rampup );\n        // wait for grain length (minus the ramp-up and -down)\n        (grainlen - (rampup + rampdown)) => now;\n        // set ramp down duration\n        lisa.rampDown( newvoice, rampdown );\n        // for ramp down duration\n        rampdown => now;\n    }\n}\n",
                "data": []
            }
        },
        {
            "LiSa-track4.ck": {
                "code": "//--------------------------------------------------------------------\n// name: LiSa-track4.ck\n// desc: live sampling utilities for ChucK\n//       demonstrate using track == 1 mode with LiSa\n//\n// author: Dan Trueman, 2007\n//--------------------------------------------------------------------\n\n// patch\nLiSa loopme => dac;\n// use for loading audio file (also see example: LiSa-load.ck)\nSndBuf buf;\n\n// change this to your own audio file\nme.dir() + \"geetar.wav\" => buf.read;\n// set lisa buffer size to sample size\nbuf.samples()::samp => loopme.duration;\n// transfer values from SndBuf to LiSa\nfor( 0 => int i; i < buf.samples(); i++ )\n{ loopme.valueAt(buf.valueAt(i), i::samp); }\n\n// set sync/track mode to 1, where the input chooses playback position\n1 => loopme.sync;\n\n// use an oscillator to set playback position\nSinOsc tracker => loopme;\n// step signal as offset\nStep off => loopme;\n\n// tracker parameters; will determine how far into the buffer\n// to go (gain), with what offset (off) and with what speed (freq)\n0.05 => tracker.freq;\n0.25 => tracker.gain;\n.5 => off.next;\n\n// set gain\n0.5 => loopme.gain;\n// play it back\n1 => loopme.play;\n\n// infinite time-loop\nwhile ( true ) { 1::second => now; }\n",
                "data": [
                    "https://raw.githubusercontent.com/ccrma/chuck/main/examples/special/geetar.wav"
                ]
            }
        },
        "scream-o-matic"
    ],
    "scream-o-matic": [
        {
            "scream-o-matic.ck": {
                "code": "//---------------------------------------------------------------------\n// name: scream-o-matic.ck\n// desc: using multiple LiSas for granular synthesis, to make a\n//       continuous scream generator; based on the patch for\n//       the augmented FlowBee interface (2014). See:\n//       \n//       \"Suck-O-Phonic 6000: Augmented Flowbee Musical Interface\"\n//       https://www.youtube.com/watch?v=g3bkaljCVRs\n//\n// author: Alex Chechile\n//         Spencer Salazar\n//         Ge Wang (https://ccrma.stanford.edu/~ge/)\n//---------------------------------------------------------------------\n// change this for multi-channel screams\n2 => int NUM_CHANNELS;\n// per-channel components\nNRev reverb[NUM_CHANNELS];\n// DC blockers in case any input files has DC/low-freq bias\nPoleZero dcblocker[NUM_CHANNELS];\n\n// patch it\nfor( int i; i < NUM_CHANNELS; i++ )\n{\n    dcblocker[i] => reverb[i] => dac.chan(i);\n    .99 => dcblocker[i].blockZero;\n    .1 => reverb[i].mix;\n}\n\n// max lisa voices\n30 => int LISA_MAX_VOICES;\n// grain duration base\n250::ms => dur GRAIN_DURATION_BASE;\n// grain duration (in multiples of duration base)\n6 => float GRAIN_DURATION_FACTOR;\n// factor relating grain duration to ramp up/down time\n.5 => float GRAIN_RAMP_FACTOR;\n// playback rate\n1 => float GRAIN_PLAY_RATE;\n// grain rate factor (0 means no change)\n.2 => float GRAIN_RATE_FACTOR;\n\n// array of screams\nLiSa @ lisa[0];\n// load data and append to array\nlisa << load( me.dir() + \"scream-1.wav\" );\nlisa << load( me.dir() + \"scream-2.wav\" );\nlisa << load( me.dir() + \"scream-3.wav\" );\nlisa << load( me.dir() + \"scream-4.wav\" );\nlisa << load( me.dir() + \"scream-5.wav\" );\nlisa << load( me.dir() + \"scream-6-lion.wav\" );\n// how many to use (remove the `-1` to include lion roar)\nlisa.size()-1 => int NUM_LISA;\n\n// connect and pan\nfor( int i; i < NUM_LISA; i++ )\n{\n    // connect lisa to audio output\n    lisa[i] => dcblocker[i%NUM_CHANNELS];\n}\n\n// per-LiSa control shred; the arguments here can be adapted/replaced by\n// other input parameters, e.g., from code/kb/mouse/gametrak\nfun void go( LiSa @ lisa, float avgR, float varR, float avgT, float varT, dur T )\n{\n    while( true )\n    {\n        // fireGrain( LiSa @ lisa, float pos, float rate, dur T, float gain )\n        fireGrain( lisa, \n            Math.random2f(.1,.9), Math.random2f(avgR-varR/2,avgR+varR/2), \n            Math.random2f(avgT-varT/2, avgT+varT/2)::ms, 1 );\n        T => now;        \n    }\n}\n\n// spork per-lisa shre\nfor( int i; i < NUM_LISA; i++ )\n{\n    // randomize each LiSa for now\n    // play with these parameters; maybe randomize differently for different effect\n    // go( LiSa @ lisa, float avgR, float varR, float avgT, float varT, dur T )\n    spork ~ go( lisa[i], 1, .4, 800, 400, Math.random2f(300,500)::ms );\n}\n\n// time loop\nwhile( true )\n{ \n    for( int i; i < NUM_LISA; i++ )\n    {\n        // one of several place to map input (e.g., from kb/mouse/gametrak)\n        .5 => lisa[i].gain;\n    }\n    \n    10::ms => now;\n}\n\n// fire a grain\nfun void fireGrain( LiSa @ lisa, float pos, float rate, dur T, float gain )\n{\n    // get diff time\n    // gt.currTime - gt.lastTime => dur diffTime;\n    GRAIN_DURATION_BASE => dur diffTime;\n    // grain length\n    diffTime * GRAIN_DURATION_FACTOR => dur grainLen;\n    // ramp time\n    grainLen * GRAIN_RAMP_FACTOR => dur rampTime;\n    // a grain\n    if( lisa != null && pos >= 0 )\n        spork ~ grain( lisa, pos * lisa.duration(), grainLen, T/2, T/2, \n        rate * GRAIN_PLAY_RATE, gain );\n}\n\n// sporkee\nfun void grain( LiSa @ lisa, dur pos, dur grainLen, dur rampUp, dur rampDown, float rate, float gain )\n{\n    // get a voice to use\n    lisa.getVoice() => int voice;\n    \n    // if available\n    if( voice > -1 )\n    {\n        // set rate\n        lisa.rate( voice, rate );\n        // set playhead\n        lisa.playPos( voice, pos );\n        // voice inga\n        lisa.voiceGain( voice, gain );\n        // ramp up\n        lisa.rampUp( voice, rampUp );\n        // wait\n        (grainLen - rampUp) => now;\n        // ramp down\n        lisa.rampDown( voice, rampDown );\n        // wait\n        rampDown => now;\n    }\n}\n\n// load file into a LiSa\nfun LiSa load( string filename )\n{\n    // sound buffer\n    SndBuf buffy;\n    // load it\n    filename => buffy.read;\n    \n    // new LiSa\n    LiSa lisa;\n    // set duration\n    buffy.samples()::samp => lisa.duration;\n    \n    // transfer values from SndBuf to LiSa\n    for( 0 => int i; i < buffy.samples(); i++ )\n    {\n        // args are sample value and sample index\n        // (dur must be integral in samples)\n        lisa.valueAt( buffy.valueAt(i), i::samp );        \n    }\n    \n    // set LiSa parameters\n    lisa.play( false );\n    lisa.loop( false );\n    lisa.maxVoices( LISA_MAX_VOICES );\n    \n    return lisa;\n}",
                "data": [
                    "https://raw.githubusercontent.com/ccrma/chuck/main/examples/special/scream-o-matic/data/scream-4.wav",
                    "https://raw.githubusercontent.com/ccrma/chuck/main/examples/special/scream-o-matic/data/scream-2.wav",
                    "https://raw.githubusercontent.com/ccrma/chuck/main/examples/special/scream-o-matic/data/scream-5.wav",
                    "https://raw.githubusercontent.com/ccrma/chuck/main/examples/special/scream-o-matic/data/scream-1.wav",
                    "https://raw.githubusercontent.com/ccrma/chuck/main/examples/special/scream-o-matic/data/scream-6-lion.wav",
                    "https://raw.githubusercontent.com/ccrma/chuck/main/examples/special/scream-o-matic/data/scream-3.wav"
                ]
            }
        }
    ],
    "type": [
        {
            "type_query.ck": {
                "code": "//---------------------------------------------------------------------\n// name: type-query.ck\n// desc: this example shows working with the Type type in ChucK\n//       to query Types currently in the ChucK type system\n//\n// version: needs 1.5.0.0 or higher\n//\n// author: Ge Wang (https://ccrma.stanford.edu/~ge/)\n// date: Winter 2023\n//---------------------------------------------------------------------\n\n// get types currently in ChucK type system\nType.getTypes(\n    Type.PRIMITIVE, Type.BUILTIN\n) @=> Type types[];\n\n// print results of query\nfor( int i; i < types.size(); i++ )\n{\n    cherr <= \"(builtin primitive types): \" <= types[i].name() <= \" (\" <= types[i].origin() <= \")\" <= IO.newline();\n}\n\n// get types currently in ChucK type system\nType.getTypes(\n    Type.OBJECT, Type.BUILTIN\n) @=> types;\n\n// print results of query\nfor( int i; i < types.size(); i++ )\n{\n    cherr <= \"(builtin object types): \" <= types[i].name() <= \" (\" <= types[i].origin() <= \")\" <= IO.newline();\n}\n\n// get types currently in ChucK type system\nType.getTypes(\n    Type.OBJECT, Type.CHUGIN\n) @=> types;\n\n// print results of query\nfor( int i; i < types.size(); i++ )\n{\n    cherr <= \"(chugin types): \" <= types[i].name() <= \" (\" <= types[i].origin() <= \")\" <= IO.newline();\n}\n\n// get all subclasses of UGen\nUGen.typeOf().children() @=> types;\n// print results\nfor( int i; i < types.size(); i++ )\n{\n    cherr <= \"(UGens): \" <= types[i].name() <= \" (\" <= types[i].origin() <= \")\" <= IO.newline();\n}\n",
                "data": []
            }
        },
        {
            "type_type.ck": {
                "code": "//---------------------------------------------------------------------\n// name: type-type.ck\n// desc: this example shows working with the Type type in ChucK;\n//       a Type instance represents a specific type currently in\n//       in the ChucK VM\n//\n// version: needs 1.5.0.0 or higher\n//\n// author: Ge Wang (https://ccrma.stanford.edu/~ge/)\n// date: Winter 2023\n//---------------------------------------------------------------------\n\n// print some info about a Type\nfun void about( Type t )\n{\n    // divider\n    cherr <= \"--------------------------------------------------\" <= IO.newline();\n    // check\n    if( t == null )\n    {\n        cherr <= \"null Type passed to about()!\" <= IO.newline();\n        return;\n    }\n\n    //-----------------------------------------------------------------\n    // use .name() to get full type name e.g., 'int[][]'\n    //-----------------------------------------------------------------\n    cherr <= \"type name using .name(): \" <= t.name() <= IO.newline();\n    //-----------------------------------------------------------------\n    // use .baseName() to get base type name (without the array part)\n    //-----------------------------------------------------------------\n    cherr <= \"type name using .baseName(): \" <= t.baseName();\n    repeat( t.arrayDepth() ) cherr <= \"[]\";\n    cherr <= IO.newline();\n\n    //-----------------------------------------------------------------\n    // parents\n    //-----------------------------------------------------------------\n    cherr <= \"inherits: \";\n    // get parent\n    t.parent() @=> Type @ p;\n    // nothing\n    if( p == null ) cherr <= \"(nothing)\" <= IO.newline();\n    else\n    {\n        while( p != null )\n        {\n            // name of parent\n            cherr <= p.name();\n            // get parent's parent\n            p.parent() @=> p;\n            // null?\n            cherr <= ((p != null) ? \" -> \" : IO.newline());\n        }\n    }\n\n    //-----------------------------------------------------------------\n    // is a kind of?\n    //-----------------------------------------------------------------\n    cherr <= \"isa...Object:\" <= t.isa(\"Object\") <= \" \"\n          <= \"UGen:\" <= t.isa(\"UGen\") <= \" \"\n          <= \"UAna:\" <= t.isa(\"UAna\") <= IO.newline();\n\n    //-----------------------------------------------------------------\n    // more attributes\n    //-----------------------------------------------------------------\n    cherr <= \"primitive: \" <= (t.isPrimitive() ? \"YES\" : \"NO\" ) <= IO.newline();\n    cherr <= \"array: \" <= (t.isArray() ? \"YES\" : \"NO\" )\n          <= \" depth: \" <= t.arrayDepth() <= IO.newline();\n}\n\n// make an array\nint array[2][2];\nabout( array.typeOf() );\nabout( Type.of( array ) );\n\n// a patch\nSinOsc foo;\n\n// get the type of classes\nSinOsc.typeOf() @=> Type @ tSinOsc;\n// print info\nabout( tSinOsc );\n// get the type of an instance\nfoo.typeOf() @=> Type @ tfoo;\n// print info (should be the same as above)\nabout( tfoo );\n\n// get type of any value or variable\nabout( Type.of( 1 ) );\nabout( Type.of( 2.0 ) );\nabout( Type.of( now ) );\nabout( Type.of( 3::second ) );\nabout( Type.of( #(1,2) ) );\nabout( Type.of( %(1,pi/2) ) );\nabout( Type.of( @(1,2,3) ) );\nabout( Type.of( @(1,2,3,4) ) );\nabout( Type.of( dac ) );\n\n// get type by name\nabout( Type.find(\"MFCC\") );\n\n// get the type of the Type type; should be itself\nType.typeOf() @=> Type @ tType;\n\n// get all subclasses of StkInstrument\nStkInstrument.typeOf().children() @=> Type kids[];\n// print results\nfor( int i; i < kids.size(); i++ )\n{\n    cherr <= \"StkInstrument: \" <= kids[i].name() <= IO.newline();\n}\n\n// get all subclasses of UAna\nUAna.typeOf().children() @=> kids;\n// print results\nfor( int i; i < kids.size(); i++ )\n{\n    cherr <= \"UAna: \" <= kids[i].name() <= IO.newline();\n}\n",
                "data": []
            }
        },
        {
            "type_object.ck": {
                "code": "// in contrast to primitive types, we have Objects\n// <<< >>> will display a reference address when printed\n\n// instantiate a base Object\nObject obj;\n// print\n<<<obj>>>;\n",
                "data": []
            }
        },
        {
            "type_primitives.ck": {
                "code": "// quick survey of chuck primitives\n// <<<>>> will print the type and value of any variable; \n\n// integers \n1 => int i; \n<<<i>>>;\n// modify value and print again...\n2 => i;\n<<<i>>>;\n\n// hexadecimal notation\n0x22 => i;\n<<<i>>>;\n\n// floats \n5.678 => float f; \n<<<f>>>;\n\n// durations are a measure of time \n// the value we print will be in audio samples\n\n9.0::second => dur d; \n<<<d>>>;\n\nnow => time t; \n<<<t>>>;\n\n// we advance time, and now will change to reflect \n<<<\"waiting 10 seconds...\">>>;\n10::second => now;\n<<<now>>>;\n\n// there is more: see type_analysis.ck for more primitives\n// including complex and polar\n",
                "data": []
            }
        },
        {
            "polymorph.ck": {
                "code": "//---------------------------------------------------------------------\n// name: polymorph.ck\n// desc: example showing polymorphism using a base class and two\n//       subclasses that each implement their own play() function;\n//       a generic array of base class references is initialized\n//       with the more specific subclass instances; this allows\n//       for .play() to be called during the loop, the behavior of\n//       which can take on different forms depending on the specific\n//       type of underlying subclass.\n//\n//       philosophically, polymorphism in programming amounts to\n//       a structured way to \"break\" the established contract between\n//       a type system and the programmer, allowing objects of\n//       apparently the same type to exhibit different behaviors.\n//\n// author: Ge Wang (https://ccrma.stanford.edu/~ge/)\n// date: Winter 2023\n//---------------------------------------------------------------------\n// generic base class\nclass Motif\n{\n    // default method to be potentially overridden in subclasses\n    fun void play()\n    {\n        <<< \"base class Motif.play()\", \"\" >>>;\n    }\n}\n\n// subclass that inherits from Motif\n// can think of MoA as a more specific kind of Motif\nclass MoA extends Motif\n{\n    // define play behavior for MoA by overriding play()\n    fun void play()\n    {\n        <<< \"do Motif A\", \"\" >>>;\n    }\n}\n\n// subclass that inherits from Motif\n// can think of MoB as a more specific kind of Motif\nclass MoB extends Motif\n{\n    // define play behavior for MoB by overriding play()\n    fun void play()\n    {\n        <<< \"do Motif B\", \"\" >>>;\n    }\n}\n\n// instantiate array of base class Motif references\n// each element is a specific kind of Motif\n[new MoA, new MoB, new MoB, new MoA] @=> Motif @ motifs[];\n\n// array index variable\n0 => int which;\n\n// loop\nwhile( true )\n{\n    // will automatically call the right play() depending on\n    // the underlying type (MoA vs. MoB) as instantiated above\n    spork ~ motifs[which].play();\n    \n    // advance time\n    300::ms => now;\n\n    // cycle which / print divider every cycel\n    which++; if( which >= motifs.size() )\n    { 0 => which; cherr <= \"--\" <= IO.newline(); }    \n}\n",
                "data": []
            }
        },
        {
            "type_auto.ck": {
                "code": "// name: type_auto.ck\n// desc: using the 'auto' type which infers type from context\n//\n// requires: chuck-1.5.0.8 or higher\n\n// int\n1 => auto a;\n<<< a, \"\" >>>;\n\n// array\n[1,2,3] @=> auto arr[];\n<<< arr[1], \"\" >>>;\n\n// multi-dim array\n[ [1,2,3], [4,5,6] ] @=> auto arr2[][];\n<<< arr2[0][2], \"\" >>>;\n\n// objects\nnew SinOsc @=> auto z;\n440 => z.freq;\n<<< z.freq()$int, \"\" >>>;\n\n// for-each\nfor( auto x : arr )\n{\n    // print\n    <<< x, \"\" >>>;\n}\n",
                "data": []
            }
        },
        {
            "type_analysis.ck": {
                "code": "// print complex\n<<< #(1,1) >>>;\n// print polar\n<<< %(1,2*pi) >>>;\n\n// cast int to complex\n<<< 1 $ complex >>>;\n// cast int to polar\n<<< 2 $ polar >>>;\n// cast float to complex\n<<< 3.0 $ complex >>>;\n// cast float to polar\n<<< 4.0 $ polar >>>;\n\n// cast complex to polar\n<<< \"cast:\", #(10,10) $ polar >>>;\n// cast polar to complex\n<<< \"cast:\", %(1,pi/2) $ complex >>>;\n// cast to and to\n<<< \"cast:\", #(5,5) $ polar $ complex >>>;\n\n// store in variable\n#(1,2.0) => complex c;\n// print\n<<< c >>>;\n// store in variable\n%(3.0,4) => polar p;\n// print\n<<< p >>>;\n\n// add\n<<< #(1,1) + #(1,1) >>>;\n<<< %(1,0) + 3*%(1,1) >>>;\n// minus\n<<< #(1,1) - #(.5,-1) >>>;\n<<< %(1,1) - %(.5,0) >>>;\n// times\n<<< #(1,2) * #(3,4) >>>;\n<<< %(2,.25*pi) * %(2,.35*pi) >>>;\n// divide\n<<< #(2,2) / #(1,1) >>>;\n<<< %(5,.25*pi) / %(4,.5*pi) >>>;\n\n// add assign\n#(1,1) => complex foo;\n#(2,3) +=> foo; <<< foo >>>;\n#(2,3) -=> foo; <<< foo >>>;\n#(0,5) *=> foo; <<< foo >>>;\n#(0,5) /=> foo; <<< foo >>>;\n%(2,pi) => polar bar;\n%(3,pi) +=> bar; <<< bar >>>;\n%(-1,0) -=> bar; <<< bar >>>;\n%(2,pi) *=> bar; <<< bar >>>;\n%(2,pi) /=> bar; <<< bar >>>;\n\n// constant\n<<< \"Math.j:\", Math.j >>>;\n\n// math\n<<< Math.re( #(1,2) ) >>>;\n<<< Math.im( #(1,2) ) >>>;\n<<< Math.mag( %(2,pi) ) >>>;\n<<< Math.phase( %(2,pi) ) >>>;\n\n// array\ncomplex arr[10];\n<<< arr.size() >>>;\n<<< arr[0] >>>;\n#(10, 11) => arr[1];\n<<< arr[1] >>>;\n\npolar brr[10];\n<<< brr.size() >>>;\n<<< brr[0] >>>;\n%(5,pi) => brr[1];\n<<< brr[1] >>>;\n<<< Math.mag( brr[1] ) >>>;\n\n// components\n<<< #(1,2).re, #(1,2).im >>>;\n<<< %(3,pi).mag, %(3,pi).phase >>>;\n<<< foo.re, foo.im >>>;\n5 => foo.re => foo.im;\n<<< foo, foo.re, foo.im >>>;\n\n// arrays\n[ #(1,2), #(3,4), #(5,6) ] @=> complex cs[];\npolar ps[cs.size()];\n// convert\nMath.rtop( cs, ps );\n<<< ps[0], ps[1], ps[2] >>>;\nMath.ptor( ps, cs );\n<<< cs[0], cs[1], cs[2] >>>;\n",
                "data": []
            }
        }
    ],
    "pca": [
        {
            "pca.ck": {
                "code": "//---------------------------------------------------------------------\n// name: pca.ck\n// desc: principle component analysis utility\n//\n// version: need chuck version 1.5.0.0 or higher\n// sorting: part of ChAI (ChucK for AI)\n//\n// uncomment for PCA API:\n// PCA.help();\n//\n// author: Yikai Li\n//         Ge Wang (https://ccrma.stanford.edu/~ge/)\n// date: Winter 2023\n//---------------------------------------------------------------------\n\n// prepare\nfloat input[10][10], output[10][3];\nfor( 0 => int i; i < 10; i++ )\n{\n    for( 0 => int j; j < 10; j++ )\n    {\n        // put noise in\n        Math.randomf() => input[i][j];\n    }\n}\n\n// dimension reduce input (e.g., 10x10) to output (e.g., 10x3)\n// PCA.reduce() is a static method...\n// can be called with or without PCA instance\nPCA.reduce( input, 3, output );\n\n// print\nfor ( 0 => int i; i < 10; i++ )\n{\n    for ( 0 => int j; j < 3; j++ )\n    {\n        // prin t\n        chout <= output[i][j] <= \",\";\n    }\n    chout <= IO.newline();\n}\n",
                "data": []
            }
        }
    ],
    "knn": [
        {
            "knn2-classify.ck": {
                "code": "//------------------------------------------------------------------------------\n// name: knn2-classify.ck\n// desc: k-nearest-neighbor (k-NN) classification example; it simulates a \n//       simplified musical genre classification task where three labeled\n//       categories are given respective locations in a 2D feature space.\n//\n// version: need chuck version 1.5.0.0 or higher\n// sorting: part of ChAI (ChucK for AI)\n//\n// uncomment the next line to learn more about the KNN2 object:\n// KNN2.help();\n//\n// author: Yikai Li and Ge Wang\n// date: Spring 2023\n//------------------------------------------------------------------------------\n\n// create a k-NN classifier\nKNN2 knn;\n\n// prepare data: labels\n[\"classical\", \"pop\", \"rock\"] @=> string labelNames[];\n// prepare data: using 2-dimensional feature space for this example;\n// in general, the feature space could be much higher\n[[0.0, 0.0],\n [1.0, 1.0],\n [2.0, 2.0]] @=> float features[][];\n// prepare data: corresponding IDs between labels and features\n[0, 1, 2] @=> int labels[];\n// number of labels\nlabels.size() => int NUM_LABELS;\n// train the model\nknn.train( features, labels );\n// optional: weigh the feature dimensions\n[1.0, 1.0] @=> float weights[];\n// optional: set the weights across feature dimensions\nknn.weigh( weights );\n\n// provide an unlabeled test query\n[0.5, 0.5] @=> float q[];\n\n// predict with new query and k=1\npredict( q, 1 );\n// predict with the same query and k=2\npredict( q, 2 );\n\n// based on a new unlabeled test query and its distance to its\n// k nearest neighbors, predict and print the probabilities of\n// class membership NOTE: for the sake of the example, this\n// function assumes query has 2 dimensions\nfun void predict( float query[], int k )\n{\n    // how we get the data back\n    float prob[NUM_LABELS];\n\n    // predict with k nearest neighbors\n    knn.predict( query, k, prob );\n    // print\n    chout <= \"query=(\" + query[0] + \",\" + query[1] + \"); k=\" + k + \":\" <= IO.newline();\n    for( 0 => int i; i < 3; i++ )\n    {\n        chout <= labelNames[i] + \": \" + prob[i] <= IO.newline();\n    }\n    chout <= IO.newline();\n}\n",
                "data": []
            }
        },
        {
            "knn2-search.ck": {
                "code": "//------------------------------------------------------------------------------\n// name: knn2-search.ck\n// desc: basic k-nearest-neighbor (k-NN) search example; it simulates a\n//       simplified musical genre classification task where three labeled\n//       categories are given respective locations in a 2D feature space.\n//\n// version: need chuck version 1.5.0.0 or higher\n// sorting: part of ChAI (ChucK for AI)\n//\n// uncomment the next line to learn more about the KNN2 object:\n// KNN2.help();\n//\n// author: Yikai Li and Ge Wang\n// date: Spring 2023\n//------------------------------------------------------------------------------\n\n// create a k-NN object\nKNN2 knn;\n\n// prepare data: labels\n[\"classical\", \"pop\", \"rock\"] @=> string labelNames[];\n// prepare data: using 2-dimensional feature space for this example;\n// in general, the feature space could be much higher\n[[0.0, 0.0],\n [1.0, 1.0],\n [2.0, 2.0]] @=> float features[][];\n// prepare data: corresponding IDs between labels and features\n[0, 1, 2] @=> int labels[];\n// number of labels\nlabels.size() => int NUM_LABELS;\n// train the model\nknn.train( features, labels );\n// optional: weigh the feature dimensions\n[1.0, 1.0] @=> float weights[];\n// optional: set the weights across feature dimensions\nknn.weigh( weights );\n\n// provide an unlabled test query\n[0.5, 0.5] @=> float q[];\n\n// search for nearest neighbor label\nint neighbor_labels[0];\n// corresponding indices\nint neighbor_indices[0];\n\n// search type #1: get labels\nknn.search( q, 1 , neighbor_labels );\nchout <= \"query=(\" + q[0] + \", \" + q[1] + \"); k=1:\\n\" + labelNames[neighbor_labels[0]] <= IO.newline();\n\n// search type #2: get labels and indices\nknn.search( q, 2 , neighbor_labels, neighbor_indices );\nchout <= \"\\n\" <= \"query=(\" + q[0] + \", \" + q[1] + \"); k=2:\\n\";\nfor (int i; i < 2; i++)\n{\n    chout <= labelNames[neighbor_labels[i]] + \" [\" + neighbor_indices[i] + \"]\" <= IO.newline();\n}\n\n// search for nearest neighbor label and feature\nfloat neighbor_features[2][2];\nknn.search( q, 2 , neighbor_labels, neighbor_indices, neighbor_features );\nchout <= \"\\n\" <= \"query=(\" + q[0] + \", \" + q[1] + \"); k=2:\\n\";\nfor (int i; i < 2; i++)\n{\n    chout <= labelNames[neighbor_labels[i]] + \" [\" + neighbor_indices[i] + \"]\" + \n             \" (\" + neighbor_features[i][0] + \", \" + neighbor_features[i][1] + \")\" <= IO.newline();\n}\n\n\n",
                "data": []
            }
        },
        {
            "knn-search.ck": {
                "code": "//------------------------------------------------------------------------------\n// name: knn2-search.ck\n// desc: basic k-nearest-neighbor (k-NN) search example;\n//\n// version: need chuck version 1.5.0.0 or higher\n// sorting: part of ChAI (ChucK for AI)\n//\n// uncomment the next line to learn more about the KNN object:\n// KNN.help();\n//\n// author: Yikai Li and Ge Wang\n// date: Spring 2023\n//------------------------------------------------------------------------------\n\n// create a KNN object\nKNN knn;\n\n// prepare data: using 2-dimensional feature space for this example;\n// in general, the feature space could be much higher\n[[0.0, 0.0],\n [1.0, 1.0],\n [2.0, 2.0]] @=> float features[][];\n// train the model\nknn.train( features );\n// optional: weigh feature dimensions\n[1.0, 1.0] @=> float weights[];\n// optional: set the weights across dimensions\nknn.weigh( weights );\n\n// provide a test query\n[0.5, 0.5] @=> float q[];\n\n// corresponding indices\nint neighbor_indices[0];\n\n// search\nknn.search( q, 2 , neighbor_indices );\nchout <= \"query = (\"+ q[0]+\",\"+q[1]+\"); k=2: [\"+ neighbor_indices[0]+\",\"+neighbor_indices[1]+\"]\" <= IO.newline();\n",
                "data": []
            }
        }
    ],
    "features": [
        {
            "rolloff2.ck": {
                "code": "// our patch\nadc => FFT fft =^ RollOff roff50 => blackhole;\n// a second rolloff\nfft =^ RollOff roff85 => blackhole;\n\n// set parameters\n1024 => fft.size;\n// set hann window\nWindowing.hann(1024) => fft.window;\n// compute srate\nsecond / samp => float srate;\n// set rolloff percents\n.5 => roff50.percent;\n.85 => roff85.percent;\n\n// control loop\nUAnaBlob blobby;\nUAnaBlob blobert;\nwhile( true )\n{\n    // upchuck: take fft then the rolloffs\n    roff50.upchuck() @=> blobby;\n    roff85.upchuck() @=> blobert;\n    // print out\n    <<< \"50% rolloff:\", blobby.fvals()[0] * srate / 2,\n        \"85% rolloff:\", blobert.fvals()[0] * srate / 2 >>>;\n\n    // advance time\n    fft.size()::samp => now;\n}\n",
                "data": []
            }
        },
        {
            "chroma.ck": {
                "code": "//---------------------------------------------------------------------\n// name: chroma.ck\n// desc: chroma unit anlyzer, used for feature extraction of pitch data\n//       e.g., a set of frequencies\n//\n// uncomment for Chroma API:\n// Chroma.help();\n//\n// author: Yikai Li\n//         Ge Wang (https://ccrma.stanford.edu/~ge/)\n// date: Winter 2023\n//---------------------------------------------------------------------\n\n// synthesis / analysis network\nSinOsc s => FFT fft =^ Chroma chroma => blackhole;\n\n// set FFT size\n2048 => fft.size;\n// set window type and size\nWindowing.hann(fft.size()) => fft.window;\n// our hop size (how often to perform analysis)\nfft.size()::samp => dur HOP;\n\n// pitch names\n[\"C4\", \"C#\", \"D4\", \"D#\", \"E4\", \"F4\", \"F#\", \"G4\", \"G#\", \"A4\", \"A#\", \"B4\"] @=> string note_names[];\n// test frequencies\n[262, 277, 294, 311, 330, 349, 370, 392, 415, 440, 466, 494] @=> int freqs[];\n\n// print header\ncherr <= \"freq \";\nfor (0 => int i; i < 12; i++) {\n    cherr <= note_names[i] + \" \";\n}\ncherr <= IO.newline();\n\n// let one FFT-size of time pass (to buffer)\nfft.size()::samp => now;\n\n// extract chroma features\nfor( 0 => int i; i < freqs.size(); i++ )\n{\n    // set frequency for test\n    freqs[i] => s.freq;\n\n    //----------------------------------------------------------------\n    // upchuck() computes our Chroma, automatically computing upstream\n    // dependencies connected to it using =^ (e.g., FFT)\n    //----------------------------------------------------------------\n    chroma.upchuck();\n\n    // print features\n    cherr <= freqs[i] <= \": \";\n    for( 0 => int j; j < chroma.fvals().size(); j++ )\n    {\n        Math.round(chroma.fval(j) * 100) => float tmp;\n        cherr <= (tmp < 10 ? \" \":\"\") <= tmp <= \" \";\n    }\n    cherr <= IO.newline();\n\n    // advance time\n    HOP => now;\n}\n",
                "data": []
            }
        },
        {
            "rolloff.ck": {
                "code": "// our patch\nadc => FFT fft =^ RollOff roff50 => blackhole;\n// a second rolloff\nfft =^ RollOff roff85 => blackhole;\n\n// set parameters\n1024 => fft.size;\n// set hann window\nWindowing.hann(1024) => fft.window;\n// compute srate\nsecond / samp => float srate;\n// set rolloff percents\n.5 => roff50.percent;\n.85 => roff85.percent;\n\n// control loop\nwhile( true )\n{\n    // upchuck: take fft then the rolloffs\n    roff50.upchuck();\n    roff85.upchuck();\n    // print out\n    <<< \"50% rolloff:\", roff50.fval(0) * srate / 2,\n        \"85% rolloff:\", roff85.fval(0) * srate / 2 >>>;\n\n    // advance time\n    fft.size()::samp => now;\n}\n",
                "data": []
            }
        },
        {
            "rms.ck": {
                "code": "// our patch\nadc => FFT fft =^ RMS rms => blackhole;\n\n// set parameters\n1024 => fft.size;\n// set hann window\nWindowing.hann(1024) => fft.window;\n\n// control loop\nwhile( true )\n{\n    // upchuck: take fft then rms\n    rms.upchuck() @=> UAnaBlob blob;\n    // print out RMS\n    <<< blob.fval(0) >>>;\n\n    // advance time\n    fft.size()::samp => now;\n}\n",
                "data": []
            }
        },
        {
            "mfcc-mean.ck": {
                "code": "//---------------------------------------------------------------------\n// name: mfcc-mean.ck\n// desc: mel-frequency cepstral coefficients\n//       this example aggregates multiple MFCC frames; compute mean\n//\n// version: need chuck version 1.5.0.0 or higher\n// sorting: part of ChAI (ChucK for AI)\n//\n// to see API, uncomment:\n// MFCC.help();\n//\n// author: Yikai Li and Ge Wang\n// date: Spring 2023\n//---------------------------------------------------------------------\n\n// analysis patch\nadc => FFT fft =^ MFCC mfcc => blackhole;\n\n// FFT size\n2048 => fft.size;\n// FFT hop size\n512 => int hopSize;\n// number of filters in MEL space\n10 => mfcc.numFilters;\n// number of MFCC coefficients to compute per frame\n13 => mfcc.numCoeffs => int nCoeffs;\n// used to compute the frame size\n.1::second => dur aggregateTime;\n// set FFT window\nWindowing.hamming(fft.size()) => fft.window;\n// current sample sample\nsecond / samp => float sampleRate;\n// this should already be set to the current chuck srate\n// but could be overridden, if desired\n// sampleRate => mfcc.sampleRate;\n\n// calculate the number of frames\n(aggregateTime/second * sampleRate / hopSize + .5) $ int => int nFrames;\n\n// print out\nchout <= IO.newline();\n<<< \"--------------------------------------------\", \"\" >>>;\n<<< \"num filters:\", mfcc.numFilters() >>>;\n<<< \"num MFCC coefficients:\", mfcc.numCoeffs() >>>;\n<<< \"agregrateTime:\", aggregateTime/second, \"seconds\" >>>;\n<<< \"num frames:\", nFrames >>>;\n<<< \"--------------------------------------------\", \"\" >>>;\nchout <= IO.newline();\n\n// per-frame MFCC coefficients\nfloat mfccs[nFrames][nCoeffs];\n// average of MFCC coefficients across all frames\nfloat mfccMean [nCoeffs];\n\n// let one FFTsize of time pass\nfft.size()::samp => now;\n\n// analysis loop\nwhile( true )\n{\n    // aggregate mfcc features\n    for( 0 => int fi; fi < nFrames; fi++ )\n    {\n        // triggers MFCC and its dependencies (e.g., FFT)\n        mfcc.upchuck();\n        // get contents\n        for( 0 => int i; i < nCoeffs; i++ )\n        {\n            // copy the resulting coeffs\n            mfcc.fval(i) => mfccs[fi][i];\n        }\n        // advance time by one hop\n        hopSize::samp => now;\n    }\n\n    // compute mean\n    for( 0 => int i; i < nCoeffs; i++ )\n    {\n        // zero out\n        0.0 => mfccMean[i];\n        // sum\n        for (0 => int j; j < nFrames; j++)\n        {\n            mfccs[j][i] +=> mfccMean[i];\n        }\n        // divide by frames\n        nFrames /=> mfccMean[i];\n        // print\n        chout <= mfccMean[i] <= \" \";\n    }\n\n    // new line\n    chout <= IO.newline();\n}\n",
                "data": []
            }
        },
        {
            "sfm.ck": {
                "code": "//---------------------------------------------------------------------\n// name: sfm.ck\n// desc: Spectral Flatness Measure\n//\n// uncomment for SFM API:\n// SFM.help();\n//\n// author: Yikai Li\n//         Ge Wang\n// date: Winter 2023\n//---------------------------------------------------------------------\n\n// synthesis / analysis network\nSinOsc s => FFT fft =^ SFM sfm => blackhole;\n\n// set FFT size\n2048 => fft.size;\n// set window type and size\nWindowing.hann(fft.size()) => fft.window;\n// our hop size (how often to perform analysis)\nfft.size()::samp => dur HOP;\n\n// let one FFT-size of time pass (to buffer)\nfft.size()::samp => now;\n// control loop\nwhile( true )\n{\n    //----------------------------------------------------------------\n    // upchuck() computes SFM, automatically computing upstream\n    // dependencies connected to it using =^ (e.g., FFT)\n    //----------------------------------------------------------------\n    sfm.upchuck();\n    // print\n    cherr <= \"SFM: \";\n    // print the SFM results\n    for( int i; i < sfm.fvals().size(); i++ )\n    {\n        Math.round(sfm.fval(i) * 10) / 10 => float tmp;\n        cherr <= tmp <= (tmp == 1 || tmp == 0?\".0\":\"\") <= \" \";\n    }\n    // endline\n    cherr <= IO.newline();\n    // advance time\n    HOP => now;\n    // randomize frequency\n    Math.random2f(20, 1000) => s.freq;\n}\n",
                "data": []
            }
        },
        {
            "flux.ck": {
                "code": "// our UGen/UAna patch\nadc => FFT fft =^ Flux flux => blackhole;\n\n// set fft size\n1024 => fft.size;\n// set window (optional here)\nWindowing.hann( 1024 ) => fft.window;\n\n// infinite time loop\nwhile( true )\n{\n    // propogate the analysis computations\n    flux.upchuck();\n    // print it (should always be 0)\n    <<< flux.fval(0) >>>;\n\n    // hop along\n    512::samp => now;\n}\n",
                "data": []
            }
        },
        {
            "kurtosis.ck": {
                "code": "//---------------------------------------------------------------------\n// name: kurtosis.ck\n// desc: chroma unit anlyzer, used for feature extraction\n//\n// uncomment for Chroma API:\n// Kurtosis.help();\n//\n// author: Yikai Li\n//         Ge Wang (https://ccrma.stanford.edu/~ge/)\n// date: Winter 2023\n//---------------------------------------------------------------------'\n\n// our patch\nadc => FFT fft =^ Kurtosis kurtosis => blackhole;\n\n// set parameters\n1024 => fft.size;\n// set hann window\nWindowing.hann(1024) => fft.window;\n// our hop size (how often to perform analysis)\nfft.size()::samp => dur HOP;\n\n// control loop\nwhile( true )\n{\n    //----------------------------------------------------------------\n    // upchuck() computes our kurtosis, automatically computing upstream\n    // dependencies connected to it using =^ (e.g., FFT)\n    //----------------------------------------------------------------\n    kurtosis.upchuck() @=> UAnaBlob blob;\n    // print out Kurtosis\n    <<< blob.fval(0) >>>;\n\n    // advance time\n    HOP => now;\n}\n",
                "data": []
            }
        },
        {
            "centroid.ck": {
                "code": "//---------------------------------------------------------------------\n// name: centroid.ck\n// desc: fantastic audio features and where to extract them:\n//       extracting spectral centroid; also demonstrates using\n//       unit analyzers (UAna), connecting them using the\n//       upchuck operator (=^), and getting results\n//\n// author: Ge Wang (https://ccrma.stanford.edu/~ge/)\n// date: Spring 2023\n//---------------------------------------------------------------------\n\n// synthesis / analysis network\nSinOsc foo => FFT fft =^ Centroid centroid => blackhole;\n// set sine frequency\n440 => foo.freq;\n\n// set FFT size\n1024 => fft.size;\n// set window type and size\nWindowing.hann(fft.size()) => fft.window;\n// our hop size (how often to perform analysis)\nfft.size()::samp => dur HOP;\n// compute srate\nsecond / samp => float srate;\n\n// let one FFT-size of time pass (to buffer)\nfft.size()::samp => now;\n// control loop\nwhile( true )\n{\n    //----------------------------------------------------------------\n    // upchuck() computes our centroid, automatically computing upstream\n    // dependencies connected to it using =^ (e.g., FFT)\n    //----------------------------------------------------------------\n    centroid.upchuck();\n\n    // get and print the output\n    <<< \"centroid (hz):\", centroid.fval(0) * srate / 2 >>>;\n\n    // advance time\n    HOP => now;\n}\n",
                "data": []
            }
        },
        {
            "zerox.ck": {
                "code": "//----------------------------------------------------------------\n// name: ZeroX (Zero Crossing Detector)\n// desc: Detect the number of zero crosses in a Flip of samples\n//       1. Flip will convert N samples to a UAna Frame\n//       2. ZeroX will then count the number of zero crossings in \n//       the UAna Frame \n//       \n//       Note the ZeroX output in this example is equal to\n//       zeroX = 2*freq / (sample_rate / N) \n//----------------------------------------------------------------\n\n// analysis patch\nSinOsc foo => Flip flip =^ ZeroX zerox => blackhole;\n\n// set flip size (N)\n4096 => flip.size;\n\n// change the frequency of foo randomly every 1-2 seconds\nfun void ctrl()\n{\n    while( true )\n    {\n        // new random freq\n        Math.random2f( 100, 2000 ) => foo.freq;\n        <<< \"setting new freq:\", foo.freq() >>>;\n        // wait 1-2 seconds\n        Math.random2f( 1, 2 )::second => now;\n    }\n}\n\n// spork frequency changer shred\nspork ~ ctrl();\n\n// main\nwhile( true )\n{\n    // compute ZeroX in the last UAna Frame\n    // store the result in a UAnaBlob\n    zerox.upchuck() @=> UAnaBlob blob;\n\n    // print number of zero crossings\n    <<< blob.fvals()[0], \"\" >>>;\n\n    // advance time\n    flip.size()::samp => now;\n}\n",
                "data": []
            }
        },
        {
            "mfcc-basic.ck": {
                "code": "//---------------------------------------------------------------------\n// name: mfcc-basic.ck\n// desc: mel-frequency cepstral coefficients\n//       basic MFCC feature extractor\n//\n// version: need chuck version 1.5.0.0 or higher\n// sorting: part of ChAI (ChucK for AI)\n//\n// uncomment for MFCC API:\n// MFCC.help();\n//\n// author: Ge Wang (https://ccrma.stanford.edu/~ge/)\n// date: Spring 2023\n//---------------------------------------------------------------------\n\n// synthesis / analysis network\nadc => FFT fft =^ MFCC mfcc => blackhole;\n\n// set number of coefficients in MFCC (how many we get out)\n// 13 is a commonly used value; using less here for printing\n7 => mfcc.numCoeffs;\n// set number of mel filters in MFCC\n10 => mfcc.numFilters;\n\n// set FFT size\n2048 => fft.size;\n// set window type and size\nWindowing.hann(fft.size()) => fft.window;\n// our hop size (how often to perform analysis)\nfft.size()::samp => dur HOP;\n\n// let one FFT-size of time pass (to buffer)\nfft.size()::samp => now;\n// control loop\nwhile( true )\n{\n    //----------------------------------------------------------------\n    // upchuck() computes our MFCC, automatically computing upstream\n    // dependencies connected to it using =^ (e.g., FFT)\n    //----------------------------------------------------------------\n    mfcc.upchuck();\n    // print\n    cherr <= \"MFCC: \";\n    // print the MFCC results\n    for( int i; i < mfcc.fvals().size(); i++ )\n    { cherr <= mfcc.fval(i) <= \" \"; }\n    // endline\n    cherr <= IO.newline();\n    // advance time\n    HOP => now;\n}\n",
                "data": []
            }
        },
        {
            "features-combined.ck": {
                "code": "//---------------------------------------------------------------------\n// name: features-combined.ck\n// desc: extracting multiple features; collect into one vector\n//       e.g.,  Centroid, Flux, RMS, MFCC\n//\n// author: Ge Wang (https://ccrma.stanford.edu/~ge/)\n// date: Spring 2023\n//---------------------------------------------------------------------\n\n// audio input into a FFT\nadc => FFT fft;\n// a thing for collecting multiple features into one vector\nFeatureCollector combo => blackhole;\n// add spectral feature: Centroid\nfft =^ Centroid centroid =^ combo;\n// add spectral feature: Flux\nfft =^ Flux flux =^ combo;\n// add spectral feature: RMS\nfft =^ RMS rms =^ combo;\n// add spectral feature: MFCC\nfft =^ MFCC mfcc =^ combo;\n\n// set number of coefficients in MFCC (how many we get out)\n// 13 is a commonly used value; using less here for printing\n13 => mfcc.numCoeffs;\n// set number of mel filters in MFCC\n10 => mfcc.numFilters;\n\n// set FFT size\n2048 => fft.size;\n// set window type and size\nWindowing.hann(fft.size()) => fft.window;\n// our hop size (how often to perform analysis)\nfft.size()::samp => dur HOP;\n\n// let one FFT-size of time pass (to buffer)\nfft.size()::samp => now;\n// control loop\nwhile( true )\n{\n    //-----------------------------------------------------------------\n    // a single upchuck() will trigger analysis on everything\n    // connected upstream from combo via the upchuck operator (=^)\n    // the total number of output dimensions is the sum of\n    // dimensions of all the connected unit analyzers\n    //-----------------------------------------------------------------\n    combo.upchuck();\n\n    // print\n    cherr <= \"features (\" <= combo.fvals().size() <= \" total dims): \";\n    // print the MFCC results\n    for( int i; i < combo.fvals().size(); i++ )\n    { cherr <= combo.fval(i) <= \" \"; }\n    // endline\n    cherr <= IO.newline();\n \n    // advance time\n    HOP => now;\n}\n",
                "data": []
            }
        },
        {
            "flux0.ck": {
                "code": "// our UGen/UAna patch\nSinOsc s => FFT fft =^ Flux flux => blackhole;\n\n// compute sample rate\nsecond / samp => float srate;\n// set a nice frequency to minimize flux across frames\nsrate / 8 => s.freq;\n// set fft size\n1024 => fft.size;\n// set window (optional here)\nWindowing.hann( 1024 ) => fft.window;\n\n// infinite time loop\nwhile( true )\n{\n    // propogate the analysis computations (example: optional usage of blob)\n    flux.upchuck() @=> UAnaBlob blob;\n    // print it (should always be 0)\n    <<< blob.fval(0) >>>;\n\n    // hop along\n    512::samp => now;\n}\n",
                "data": []
            }
        }
    ],
    "genre-classify": [
        {
            "x-validate.ck": {
                "code": "//------------------------------------------------------------------------------\n// name: x-validate.ck\n// desc: a cross validation example using extracted features\n//\n// version: need chuck version 1.5.0.0 or higher\n// sorting: part of ChAI (ChucK for AI)\n//\n// USAGE: this is purely for cross validation on extracted features, so ...\n//        run chuck in non-real-time mode (this actually can be much\n//        faster than real-time mode, since it doesn't synch to audio):\n//\n//        cross validation from FILE\n//            > chuck --silent x-validate.ck:FILE\n//\n// date: Spring 2023\n// authors: Yikai Li\n//          Ge Wang (https://ccrma.stanford.edu/~ge/)\n//------------------------------------------------------------------------------\n\n// input: pre-extracted features file with labels\n\"\" => string FEATURES_FILE;\n// if have arguments, override filename\nif( me.args() > 0 ) me.arg(0) => FEATURES_FILE;\nelse\n{ <<< \"[usage]: chuck --silent x-validate:FILE\", \"\" >>>; me.exit();}\n//------------------------------------------------------------------------------\n// expected features file format:\n//------------------------------------------------------------------------------\n// VALUE VALUE ... VALUE LABEL\n// VALUE VALUE ... VALUE LABEL\n// ...   ...   ... ...   LABEL\n// VALUE VALUE ... VALUE LABEL\n//------------------------------------------------------------------------------\n\n\n//------------------------------------------------------------------------------\n// load feature data; read important global values like numPoints and numCoeffs\n//------------------------------------------------------------------------------\n// values to be read from file\n0 => int numPoints; // number of points in data\n0 => int numCoeffs; // number of dimensions in data\n// file read PART 1: read over the file to get numPoints and numCoeffs\nloadFile( FEATURES_FILE ) @=> FileIO @ fin;\n// check\nif( !fin.good() ) me.exit();\n\n// labels of all data points\nstring inLabels[numPoints];\n// label indices of all data points\nint inLabelsInt[inLabels.size()];\n// feature vectors of data points\nfloat inFeatures[numPoints][numCoeffs];\n// keys\nstring labels[0];\n// use as map: labels to numbers\nint label2int[0];\n\n\n//------------------------------------------------------------------------------\n// read the data\n//------------------------------------------------------------------------------\nreadData( fin );\n\n\n//------------------------------------------------------------------------------\n// set up our KNN object to use for classification\n// (KNN2 is a fancier version of the KNN object)\n// -- run KNN2.help(); in a separate program to see its available functions --\n//------------------------------------------------------------------------------\nKNN2 knn;\n// k nearest neighbors\n10 => int K;\n// results vector\nfloat knnResult[labels.size()];\n\n\n//------------------------------------------------------------------------------\n// cross validation\n//------------------------------------------------------------------------------\n// number of folds\n20 => int numFolds;\n// number of folds to use for testing\n4 => int numTestFolds;\n// number of folds to use for training\nnumFolds - numTestFolds => int numTrainFolds;\n// number of points in each fold\n(numPoints / numFolds) $ int => int numPointsPerFold;\n// feature vectors of training data\nfloat trainFeatures[numTrainFolds * numPointsPerFold][numCoeffs];\n// labels of training data\nint trainLabelsInt[numTrainFolds * numPointsPerFold];\n// feature vectors of testing data\nfloat testFeatures[numTestFolds * numPointsPerFold][numCoeffs];\n// labels of testing data\nint testLabelsInt[numTestFolds * numPointsPerFold];\n// normalize the data\nnormalizeData();\n// shuffle the data\nshuffleData();\n// cross validation\nfor( 0 => int i; i < numFolds / numTestFolds; i++)\n{\n    // prepare training and testing data\n    prepareData( i );\n    // train\n    knn.train( trainFeatures, trainLabelsInt );\n    // test\n    0.0 => float accuracy;\n    for( 0 => int j; j < testLabelsInt.size(); j++ )\n    {\n        // predict\n        knn.predict( testFeatures[j], K, knnResult );\n        // aggregate accuracy\n        knnResult[ testLabelsInt[j] ] +=> accuracy;\n    }\n    // print accuracy\n    chout <= \"fold \" + i + \" accuracy: \" + ( accuracy / testLabelsInt.size() ) <= IO.newline();\n}\n\n\n//------------------------------------------------------------------------------\n// function: normalizeData()\n//------------------------------------------------------------------------------\nfun void normalizeData()\n{\n    // for each dimension\n    for( 0 => int i; i < numCoeffs; i++ )\n    {\n        // find min and max\n        inFeatures[0][i] => float min;\n        inFeatures[0][i] => float max;\n        for( 1 => int j; j < numPoints; j++ )\n        {\n            if( inFeatures[j][i] < min ) inFeatures[j][i] => min;\n            if( inFeatures[j][i] > max ) inFeatures[j][i] => max;\n        }\n        max - min => float range;\n        // normalize\n        for( 0 => int j; j < numPoints; j++ )\n            (inFeatures[j][i] - min) / range => inFeatures[j][i];\n    }\n}\n\n\n//------------------------------------------------------------------------------\n// function: shuffleData()\n//------------------------------------------------------------------------------\nfun void shuffleData()\n{\n    // prepare swap data\n    float swapFeatures[numCoeffs];\n    int swapLabelInt;\n    // shuffle the data\n    for( numPoints - 1 => int i; i > 0; i-- )\n    {\n        // random index\n        Math.random2( 0, i ) => int j;\n        // swap features\n        for( 0 => int k; k < numCoeffs; k++ )\n        {\n            inFeatures[i][k] => swapFeatures[k];\n            inFeatures[j][k] => inFeatures[i][k];\n            swapFeatures[k] => inFeatures[j][k];\n        }\n        // swap labels\n        inLabelsInt[i] => swapLabelInt;\n        inLabelsInt[j] => inLabelsInt[i];\n        swapLabelInt => inLabelsInt[j];\n    }\n}\n\n\n//------------------------------------------------------------------------------\n// function: prepareData( int fold )\n//------------------------------------------------------------------------------\nfun void prepareData( int fold )\n{\n    // test indices\n    fold * numTestFolds * numPointsPerFold => int testStart;\n    testStart + numTestFolds * numPointsPerFold => int testEnd;\n    // index\n    0 => int train_i;\n    0 => int test_i;\n    // prepare training and testing data\n    for( 0 => int i; i < numPoints; i++ )\n    {\n        // test\n        if( i >= testStart && i < testEnd )\n        {\n            // copy features\n            for( 0 => int j; j < numCoeffs; j++ )\n                inFeatures[i][j] => testFeatures[test_i][j];\n            // copy label\n            inLabelsInt[i] => testLabelsInt[test_i];\n            // increment\n            test_i++;\n        }\n        // train\n        else\n        {\n            // copy features\n            for( 0 => int j; j < numCoeffs; j++ )\n                inFeatures[i][j] => trainFeatures[train_i][j];\n            // copy label\n            inLabelsInt[i] => trainLabelsInt[train_i];\n            // increment\n            train_i++;\n        }\n    }\n}\n\n\n//------------------------------------------------------------------------------\n// function: load data file\n//------------------------------------------------------------------------------\nfun FileIO loadFile( string filepath )\n{\n    // reset\n    0 => numPoints;\n    0 => numCoeffs;\n    \n    // load data\n    FileIO fio;\n    if( !fio.open( filepath, FileIO.READ ) )\n    {\n        // error\n        <<< \"cannot open file:\", filepath >>>;\n        // close\n        fio.close();\n        // return\n        return fio;\n    }\n    \n    string str;\n    string line;\n    // read file int array\n    while( fio.more() )\n    {\n        // read each line\n        fio.readLine().trim() => str;\n        // check if empty line\n        if( str != \"\" )\n        {\n            numPoints++;\n            str => line;\n        }\n    }\n    \n    // a string tokenizer\n    StringTokenizer tokenizer;\n    // set to last non-empty line\n    tokenizer.set( line );\n    // -1 (to account for label)\n    -1 => numCoeffs;\n    // see how many, including label name\n    while( tokenizer.more() )\n    {\n        tokenizer.next();\n        numCoeffs++;\n    }\n    \n    // check\n    if( numPoints == 0 || numCoeffs <= 0 )\n    {\n        <<< \"no data in file:\", filepath >>>;\n        fio.close();\n        return fio;\n    }\n    \n    // print\n    <<< \"# of data points:\", numPoints, \"dimensions:\", numCoeffs >>>;\n    \n    // done for now\n    return fio;\n}\n\n\n//------------------------------------------------------------------------------\n// function: read the data\n//------------------------------------------------------------------------------\nfun void readData( FileIO fio )\n{\n    // rewind the file reader\n    fio.seek( 0 );\n    \n    // read file int array\n    string str;\n    int ci, ri;\n    while( fio => str )\n    {\n        // check for last\n        if( (ci != 0) && ((ci % numCoeffs) == 0) )\n        {\n            // read in label\n            str => inLabels[ri];\n            // set in map\n            1 => label2int[str];\n            // increment row\n            ri++;\n            // reset column\n            0 => ci;\n        }\n        else\n        {\n            // store feature value\n            Std.atof(str) => inFeatures[ri][ci];\n            // increment column\n            ci++;\n        }\n    }\n    \n    // get keys from map\n    label2int.getKeys( labels );\n    // assign index\n    for( int i; i < labels.size(); i++ )\n    { i => label2int[labels[i]]; }\n    // convert in labels to ints\n    for( int i; i < inLabels.size(); i++ )\n    {\n        // get index as int\n        label2int[inLabels[i]] => inLabelsInt[i];\n    }\n}\n",
                "data": []
            }
        }
    ],
    "svm": [
        {
            "svm-basic.ck": {
                "code": "//------------------------------------------------------------------------------\n// name: svm-basic.ck\n// desc: basic support vector machine example (SVM)\n//\n// version: need chuck version 1.5.0.0 or higher\n// sorting: part of ChAI (ChucK for AI)\n//\n// uncomment the next line to learn more about the KNN object:\n// HMM.help();\n//\n// author: Yikai Li\n// date: Spring 2023\n//------------------------------------------------------------------------------\n\n// instance\nSVM svm;\n\n// prepare data\n[[1.0, 1.0],\n [2.0, 2.0],\n [3.0, 3.0]] @=> float x[][];\n[[1.0],\n [2.0],\n [3.0]] @=> float y[][];\n\n// train\n// <<< \"training...\", \"\" >>>;\nsvm.train(x, y);\n\n// test\nfloat res[1];\n// <<< \"predicting...\", \"\" >>>;\nsvm.predict([1.5, 1.5], res);\n<<< res[0] >>>;",
                "data": []
            }
        }
    ],
    "hmm": [
        {
            "hmm-load.ck": {
                "code": "//------------------------------------------------------------------------------\n// name: hmm-load.ck\n// desc: basic hidden markov model (HMM) usage example (using load)\n//\n// version: need chuck version 1.5.0.0 or higher\n// sorting: part of ChAI (ChucK for AI)\n//\n// uncomment the next line to learn more about the KNN object:\n// HMM.help();\n//\n// author: Yikai Li\n// date: Spring 2023\n//------------------------------------------------------------------------------\n\n// init\nHMM hmm;\n\n// load\n[0.6, 0.2, 0.2] @=> float initial[];\n[[0.8, 0.1, 0.1],\n [0.2, 0.7, 0.1],\n [0.1, 0.3, 0.6]] @=> float transition[][];\n[[0.7, 0.0, 0.3],\n [0.1, 0.9, 0.0],\n [0.0, 0.2, 0.8]] @=> float emission[][];\nhmm.load( initial, transition, emission );\n\n// generate\nint observations[30];\nhmm.generate( 30, observations );\n\n// output\nfor ( 0 => int i; i < observations.size(); i++ )\n{\n    chout <= observations[i] <= \" \";\n}\nchout <= IO.newline();\n",
                "data": []
            }
        },
        {
            "hmm-train.ck": {
                "code": "//------------------------------------------------------------------------------\n// name: hmm-train.ck\n// desc: basic hidden markov model (HMM) usage example (using train)\n//\n// version: need chuck version 1.5.0.0 or higher\n// sorting: part of ChAI (ChucK for AI)\n//\n// uncomment the next line to learn more about the KNN object:\n// HMM.help();\n//\n// author: Yikai Li\n// date: Spring 2023\n//------------------------------------------------------------------------------\n\n// init\nHMM hmm;\n\n// train\n[0, 1, 2, 0, 1, 2, 0, 1, 2, 0, 1, 2] @=> int observations[];\nhmm.train( 2, 3, observations );\n\n// generate\nint results[30];\nhmm.generate( 30, results );\n\n// output\nfor ( 0 => int i; i < results.size(); i++ )\n{\n    chout <= results[i] <= \" \";\n}\nchout <= IO.newline();",
                "data": []
            }
        }
    ],
    "wekinator": [
        {
            "wekinator-customize.ck": {
                "code": "//---------------------------------------------------------------------\n// name: wekinator-customize.ck\n// desc: a more extensive example of working with the Wekinator object,\n//       with many options including per-output-channel configurations.\n//\n// achievement trophy to Yikai Li for the adaptation from Wekinator\n// system and source, and redesigning the API with Ge into Wekinator\n// chuck object; Yikai generated over 6000 lines of C++ code in this\n// substantial adaption effort\n//\n// lifetime achievement award to Rebecca Fiebrink from making Wekinator,\n// and showing us a humanistic and playful way forward in an AI-drenched\n// world...\n//\n// version: need chuck version 1.5.0.0 or higher\n// sorting: part of ChAI (ChucK for AI)\n//\n// uncomment for Wekinator API:\n// Wekinator.help();\n//\n// authors: Yikai Li\n//          Ge Wang (https://ccrma.stanford.edu/~ge/)\n//          Rebecca Fiebrink (original Wekinator framework)\n// date: Winter 2023\n//---------------------------------------------------------------------\n\n// Wekinator instance\nglobal Wekinator wek;\n\n<<< \"---------------\", \"\" >>>;\n// set number of expect inputs\n// (if different than exisxting, this will clear all current observations)\nwek.inputDims(2); \n<<< \"# input channels:\", wek.inputDims() >>>;\n// set number of expect outputs\n// (if different than exisxting, this will clear all current observations)\nwek.outputDims(3);\n<<< \"# output channels:\", wek.outputDims() >>>;\n// set the type of task for Wekinator to do\n// current options: AI.Classification, AI.Regression\nwek.taskType( AI.Regression );\n// print including taskType name\n<<< \"task ID:\", wek.taskType(), \"==\", wek.taskTypeName() >>>;\n\n// set regression-related attributes\nwek.setProperty( AI.Regression, \"min\", 0 );\nwek.setProperty( AI.Regression, \"max\", 1 );\n// how to handle values outside [min,max]? 0 = none, 1 = soft, 2 = hard\nwek.setProperty( AI.Regression, \"limit\", false );\n// set classification-related attributes\nwek.setProperty( AI.Classification, \"classes\", 5 );\n// set (global) MLP attributes\n// NOTE: these will overwrite the corresponding output channel-specific properties\nwek.setProperty( AI.MLP, \"hiddenLayers\", 1 );\nwek.setProperty( AI.MLP, \"nodesPerHiddenLayer\", 0 ); // 0 = same as number of inputs\nwek.setProperty( AI.MLP, \"learningRate\", 0.01 );\nwek.setProperty( AI.MLP, \"epochs\", 100 );\n// set (global) KNN attributes\n// this is the default unless a more local attribute is set for a given output channel\nwek.setProperty(AI.KNN, \"k\", 5);\n<<< \"---------------\", \"\" >>>;\n// how to get properties; NOTE that each numeric property is associatd with int or float type\n<<< \"regression min:\", wek.getPropertyFloat(AI.Regression, \"min\") >>>;\n<<< \"regression max:\", wek.getPropertyFloat(AI.Regression, \"max\") >>>;\n<<< \"regression limit type:\", wek.getPropertyInt(AI.Regression, \"limit\") >>>;\n<<< \"MLP hiddenLayers:\", wek.getPropertyInt(AI.MLP, \"hiddenLayers\") >>>;\n<<< \"MLP nodesPerHiddenLayer:\", wek.getPropertyInt(AI.MLP, \"nodesPerHiddenLayer\") >>>;\n<<< \"MLP learningRate:\", wek.getPropertyFloat(AI.MLP, \"learningRate\") >>>;\n<<< \"MLP epochs:\", wek.getPropertyInt(AI.MLP, \"epochs\") >>>;\n<<< \"classification # classes:\", wek.getPropertyInt(AI.Classification, \"classes\") >>>;\n<<< \"KNN k:\", wek.getPropertyInt(AI.KNN, \"k\") >>>;\n<<< \"---------------\", \"\" >>>;\n\n// set the type of underlying algorithm used\n// options: AI.Regression: AI.MLP, AI.LR (currently not implemented)\n// options: AI.Classification: AI.KNN, AI.SVM, AI.DT (current not implemented)\nwek.modelType(AI.MLP);\n// print including modelType name\n<<< \"modelType ID:\", wek.modelType(), \"==\", wek.modelTypeName() >>>;\n\n// set any output channel-specific attributes, which locally\n// overrides the global attributes set in wek.setProperty()\nwek.setOutputProperty(0, \"taskType\", AI.Regression); // AI.Classification, AI.Regression\nwek.setOutputProperty(0, \"modelType\", AI.MLP); // AI.Regression: AI.MLP, AI.LR; AI.Classification: AI.KNN, AI.SVM, AI.DT\nwek.setOutputProperty(0, AI.Regression, \"min\", 0);\nwek.setOutputProperty(0, AI.Regression, \"max\", 1);\nwek.setOutputProperty(0, AI.Regression, \"limit\", false); // true: limit to [min,max]; false: no limit\nwek.setOutputProperty(0, AI.MLP, \"hiddenLayers\", 1);\nwek.setOutputProperty(0, AI.MLP, \"nodesPerHiddenLayer\", 0); // 0 = same as number of inputs\nwek.setOutputProperty(0, AI.MLP, \"learningRate\", 0.01);\nwek.setOutputProperty(0, AI.MLP, \"epochs\", 100);\nwek.setOutputProperty(0, AI.Classification, \"classes\", 5);\nwek.setOutputProperty(0, AI.KNN, \"k\", 5);\nwek.setOutputProperty(0, \"connectedInputs\", [0, 1]); // sets which input to incorporate into the model\n\n<<< \"---------------\", \"\" >>>;\n// get output channel-specific attributes\n<<< \"taskType | output channel 0:\", wek.getOutputPropertyInt(0, \"taskType\") >>>;\n<<< \"modelType | output channel 0:\", wek.getOutputPropertyInt(0, \"modelType\") >>>;\n<<< \"regression min | output channel 0:\", wek.getOutputPropertyFloat(0, AI.Regression, \"min\") >>>;\n<<< \"regression max | output channel 0:\", wek.getOutputPropertyFloat(0, AI.Regression, \"max\") >>>;\n<<< \"regression limit type | output channel 0:\", wek.getOutputPropertyInt(0,   AI.Regression, \"limit\") >>>;\n<<< \"MLP hiddenLayers | output channel 0:\", wek.getOutputPropertyInt(0,   AI.MLP, \"hiddenLayers\") >>>;\n<<< \"MLP nodesPerHiddenLayer | output channel 0:\", wek.getOutputPropertyInt(0,   AI.MLP, \"nodesPerHiddenLayer\") >>>;\n<<< \"MLP learningRate | output channel 0:\", wek.getOutputPropertyFloat(0, AI.MLP, \"learningRate\") >>>;\n<<< \"MLP epochs | output channel 0:\", wek.getOutputPropertyInt(0,   AI.MLP, \"epochs\") >>>;\n<<< \"classification # classes | output channel 0:\", wek.getOutputPropertyInt(0,   AI.Classification, \"classes\") >>>;\n<<< \"KNN k | output channel 0:\", wek.getOutputPropertyInt(0,   AI.KNN, \"k\") >>>;\n<<< \"---------------\", \"\" >>>;\n\nint indices[1];\n// get indices of input channels connected to a particular output\nwek.getOutputProperty(0, \"connectedInputs\", indices);\n// print\ncherr <= \"connected inputs | output channel 0: \";\nfor( int i; i < indices.size(); i++ ) cherr <= indices[i] <= \" \";\ncherr <= IO.newline();\n\n// set as the current input\nwek.input([0.5, 0.5]);\n\n// randomize output for each channel between that channels min and max\nwek.randomizeOutputs();\n// set as the current output\nwek.output([0.5, 0.5, 0.5]);\n\n// add an observation from the current input to output\nwek.add();\n// increments the training round number\n// a round consists of one or more added observations\nwek.nextRound();\n// add an observation explicitly from input and output\nwek.add([1.0, 1.0], [1.0, 1.0, 1.0]);\n// add an observation explicitly from input and output, for channel 0\nwek.add(0, [2.0, 2.0], [2.0, 2.0, 2.0]);\n\n// train on all the observations so far\nwek.train();\n\n// array to hold predictions\nfloat outputs[1];\n// predict output given new input\nwek.predict([3.0, 3.0], outputs);\n// print output\ncherr <= \"prediction: \";\nfor( int i; i < outputs.size(); i++ ) cherr <= outputs[i] <= \", \";\ncherr <= IO.newline();\n\n// get the number of observations (globally)\n<<< \"number of observations (total):\", wek.numObs() >>>;\n// get the number of observations for a specific output channel\n<<< \"number of observations for output channel 0:\", wek.numObs(0) >>>;\n\n<<< \"---------------\", \"\" >>>;\n// array to hold observations\n// due to a current ChucK language limitation, need to pre-allocate array to obs size\nfloat obs[wek.numObs()][0];\n// retrieve current observations\nwek.getObs(obs);\n// print what we got\n<<< \"ID, time, recording round, Input-0, Input-1, Output-0, Output-1, Output-2\", \"\" >>>;\nfor( 0 => int i; i < obs.size(); i++ )\n{\n    for( 0 => int j; j < obs[i].size(); j++ )\n    {\n        cherr <= obs[i][j] <= \", \";\n    }\n    cherr <= IO.newline();\n}\n\n// array to hold observations\n// due to a current ChucK language limitation, need to pre-allocate array to obs size\nfloat obs1[wek.numObs(0)][0];\n// retrieve current observations for a specific channel\nwek.getObs(0, obs1);\n// print what we got\n<<< \"ID, time, recording round, Input-0, Input-1, Output-0, Output-1, Output-2\", \"\" >>>;\nfor( 0 => int i; i < obs1.size(); i++ )\n{\n    for( 0 => int j; j < obs1[i].size(); j++ )\n    {\n        cherr <= obs1[i][j] <= \", \";\n    }\n    cherr <= IO.newline();\n}\n\n// delete the last round of observations (since the last wek.nextRound())\nwek.deleteLastRound();\n\n// clear observations by ID in the given range lo to hi\nwek.clearObs( 0, 1 );\n// clear observations by ID in the given range lo to hi, for a specific channel\nwek.clearObs( 0, 0, 1 );\n\n// save everything for this Wekinator (observations, model parameters, configurations)\nwek.save(\"tmp.txt\");\n// load Wekinator state from file\nwek.load(\"tmp.txt\");\n\n// export observations only (no model or configurations)\nwek.exportObs(\"./tmp.arff\");\n// export observations only (no model or configurations), for a specific channel\nwek.exportObs(0, \"./tmp0.arff\");\n// import observations (NOTE: this replaces existing observations,\n// reset the round number, and will be associated with all output channels)\nwek.importObs(\"./tmp.arff\");\n\n// clear all observations\nwek.clearAllObs();\n// clear all observations on a given channel\nwek.clearAllObs(0);\n\n<<< \"---------------\", \"\" >>>;\n// set whether Wekinator.add() should be associated with output channels (all)\nwek.setAllRecordStatus( false );\n// set whether Wekinator.add() should be associated with a specific output channel\nwek.setOutputRecordStatus( 0, true );\n// print \n<<< \"record status | output channel 0:\", wek.getOutputRecordStatus( 0 ) >>>;\n\n// setting this to false will \"mask\" out all output channels; will predict 0s\nwek.setAllRunStatus( false );\n// <<< wek.getAllRunStatus() >>>;\n// setting this to false will \"mask\" out a specific output channels\n// that particular output channel will predict 0s\nwek.setOutputRunStatus(0, true);\n<<< \"run status | output channel 0:\", wek.getOutputRunStatus(0) >>>;\n\n// clear all observations, round number, model (parameters and local properties)\n// NOTE: the global properties will remain unchanged\nwek.clear();\n<<< \"---------------\", \"\" >>>;\n",
                "data": [
                    "https://raw.githubusercontent.com/ccrma/chuck/main/examples/ai/wekinator/./tmp.txt"
                ]
            }
        },
        {
            "wekinator-import.ck": {
                "code": "//---------------------------------------------------------------------\n// name: wekinator-import.ck\n// desc: this examples imports training data from an .arff file,\n//       (which can be saved either from the Wekinator app or\n//       using Wekinator.exportObs())\n//\n// version: need chuck version 1.5.0.0 or higher\n// sorting: part of ChAI (ChucK for AI)\n//\n// uncomment for Wekinator API:\n// Wekinator.help();\n//\n// authors: Yikai Li\n//          Ge Wang (https://ccrma.stanford.edu/~ge/)\n//          Rebecca Fiebrink (original Wekinator framework)\n// date: Winter 2023\n//---------------------------------------------------------------------\n\n// instantiate a global Wekinator, so other files can easily use\nglobal Wekinator wek;\n\n// print\ncherr <= \"loading observations from file...\" <= IO.newline();\n// load an ARFF data file containing input-output observations\n// (generated either from Wekinator.exportObs() or Wekinator app)\n// NOTE: Wekinator.importObs() clears existing training data,\n//       and uses the inputDims and outputDims inferred from file\n// NOTE: it is possible to add additional observations after\nwek.importObs( me.dir() + \"currentData.arff\" );\n\n// print what we loaded\ncherr <= \"inputDims: \" <= wek.inputDims() <= \" \"\n<= \"outputDims: \" <= wek.outputDims() <= \" \"\n<= \"numObs: \" <= wek.numObs() <= IO.newline();\n\n// train using current observations\nwek.train();\n\n// input (dimensions should match inputDims)\n[0.3, 0.25, 0.4] @=> float x[];\n// output (dimensions should match outputDims)\nfloat y[wek.outputDims()];\n// predict output based on input\nwek.predict( x, y );\n\n// print\nfor( int i; i < y.size(); i++ ) { cherr <= y[i] <= \" \"; }\ncherr <= IO.newline();\n",
                "data": []
            }
        },
        {
            "wekinator-basic.ck": {
                "code": "//---------------------------------------------------------------------\n// name: wekinator-basic.ck\n// desc: basic example using the built-in Wekinator object in ChucK,\n//       based on Rebecca Fiebrink's Wekinator framework;\n//       This example adds two groups of 3-2 input-output\n//       observations, trains, and predicts output based on new input.\n//       default task: regression\n//       default model: MLPs (one hidden layer with same # of nodes as input)\n//\n// version: need chuck version 1.5.0.0 or higher\n// sorting: part of ChAI (ChucK for AI)\n//\n// uncomment for Wekinator API:\n// Wekinator.help();\n//\n// authors: Yikai Li\n//          Ge Wang (https://ccrma.stanford.edu/~ge/)\n//          Rebecca Fiebrink (original Wekinator framework)\n// date: Winter 2023\n//---------------------------------------------------------------------\n\n// instantiate a global Wekinator, so other files can access\nglobal Wekinator wek;\n\n// clear training observations\nwek.clear();\n\n// group count\n1 => int groupNum;\n\ncherr <= \"-----------\" <= IO.newline();\n// add a group of data\naddGroup( [0.1, 0.1, 0.1], [48.0, 60.0], 20 );\naddGroup( [0.4, 0.4, 0.4], [5.0, 8.0], 20 );\naddGroup( [0.8, 0.0, 0.4], [30.0, 30.0], 20 );\ncherr <= \"-----------\" <= IO.newline();\n\n// (optional) set model type; MLP is default\n// AI.MLP => wek.modelType;\n// (optional) set task type; regression is default\nAI.Regression => wek.taskType;\n// print\n<<< \"modelType:\", wek.modelTypeName(),\n    \"| taskType:\", wek.taskTypeName() >>>;\n\n// (optional) set properties to your liking\n// <<< \"changing Wekinator MLP properties...\", \"\" >>>;\n// wek.setProperty( AI.MLP, \"hiddenLayers\", 1 );\n// note: 0 nodesPerHiddenLayer means \"same as input layer\"\n// wek.setProperty( AI.MLP, \"nodesPerHiddenLayer\", 0 );\n// wek.setProperty( AI.MLP, \"learningRate\", 0.01 );\n// wek.setProperty( AI.MLP, \"epochs\", 100 );\n\n // print model properties\n<<< \"Wekinator MLP hiddenLayers:\", wek.getPropertyInt( AI.MLP, \"hiddenLayers\" ) >>>;\n<<< \"Wekinator MLP nodesPerHiddenLayer:\", wek.getPropertyInt( AI.MLP, \"nodesPerHiddenLayer\" ) >>>;\n<<< \"Wekinator MLP learningRate\", wek.getPropertyFloat( AI.MLP, \"learningRate\" ) >>>;\n<<< \"Wekinator MLP epochs:\", wek.getPropertyInt( AI.MLP, \"epochs\" ) >>>;\n// (optional) save the observations for loading later\n// wek.exportObs( me.dir() + \"currentData.arff\" );\n\n// print\ncherr <= \"-----------\" <= IO.newline();\ncherr <= \"training...\" <= IO.newline();\ncherr <= \"-----------\" <= IO.newline();\n// train using current training set\nwek.train();\n\n// new input\nfloat x[];\n// to hold predicted output\nfloat y[2];\n\ncherr <= \"given new input, predict output...\" <= IO.newline();\n// predict and print\npredict( [0.101, 0.1, 0.1], y );\npredict( [0.401, 0.4, 0.4], y );\npredict( [0.801, 0.0, 0.4], y );\n\n// test run\nrepeat( 20 )\n{\n    // generate random input\n    [Math.random2f(0,1), Math.random2f(0,1), Math.random2f(0,1)] @=> x;\n    // predict and print\n    predict( x, y );\n    // advance time (just for effect)\n    50::ms => now;\n}\n\n\n// add a group of training observations\nfun void addGroup( float inputs[], float outputs[], int N )\n{\n    // print\n    cherr <= \"adding group \" <= groupNum++;\n    // collect data\n    repeat( N )\n    {\n        // input and output (could be set in another file)\n        wek.input( inputs ); wek.output( outputs );\n        // add current input and output (typically these are different)\n        wek.add();\n        // print\n        cherr <= \".\";\n        // advance time (delay on purpose to visualize the process)\n        (300.0/N)::ms => now;\n    }\n    // print\n    cherr <= IO.newline();\n}\n\n// predict and print\nfun void predict( float inputs[], float outputs[] )\n{\n    // predict output based on input; 3 inputs -> 2 outputs\n    wek.predict(inputs, outputs);\n    // print\n    cherr <= \"(\" <= inputs[0] <= \",\"<= inputs[1] <= \",\"<= inputs[2] <= \") -> (\"\n          <= outputs[0] <= \", \" <= outputs[1] <= \")\" <= IO.newline();\n}\n",
                "data": []
            }
        }
    ],
    "mlp": [
        {
            "model-load.ck": {
                "code": "//---------------------------------------------------------------------\n// name: mlp-load.ck\n// desc: loading an MLP model from file (created by MLP.save())\n//\n// version: need chuck version 1.5.0.0 or higher\n// sorting: part of ChAI (ChucK for AI)\n//\n// uncomment for MLP API:\n// MLP.help();\n//\n// author: Yikai Li\n//         Ge Wang (https://ccrma.stanford.edu/~ge/)\n// date: Winter 2023\n//---------------------------------------------------------------------\n\n// instantiate a multilayer perception\nMLP mlp;\n\n// file name\n\"model.txt\" => string filename;\n// print\n<<< \"loading model from file:\", filename >>>;\n// load the model into network (created by MLP.save() elsewhere)\nif( !mlp.load( me.dir() + filename ) ) me.exit();\n\n// predict given a new input\n[0.7, 0.8, 0.9] @=> float x[];\n// array to how output\nfloat y[2];\n\n// predict output given input\nmlp.predict(x, y);\n// print the output\n<<< y[0], y[1] >>>;\n",
                "data": [
                    "https://raw.githubusercontent.com/ccrma/chuck/main/examples/ai/mlp/model.txt"
                ]
            }
        },
        {
            "mlp-manual.ck": {
                "code": "//---------------------------------------------------------------------\n// name: mlp-manual.ck\n// desc: training (step-by-step) a multilayer perception (MLP):\n//       (for a less manaul example, see mlp.ck)\n//\n// version: need chuck version 1.5.0.0 or higher\n// sorting: part of ChAI (ChucK for AI)\n//\n// uncomment for MLP API:\n// MLP.help();\n//\n// author: Yikai Li\n//         Ge Wang (https://ccrma.stanford.edu/~ge/)\n// date: Winter 2023\n//---------------------------------------------------------------------\n// delay for each epoch (change for print speed)\n// (or run with --silent for no print delay)\n100::ms => dur T_PRINT;\n// learning rate\n0.01 => float learningRate;\n// number of epochs\n100 => int epochs;\n\n// instantiate a multilayer perception (a basic neural network)\nMLP mlp;\n\n// neurons per layer: input, [hidden layer(s)], output\n[3, 5, 5, 2] @=> int nodesPerLayer[];\n// initialize with the # of neurons per layer\nmlp.init( nodesPerLayer );\n\n// input observations\n[[0.1, 0.2, 0.3], [0.4, 0.5, 0.6]] @=> float X[][];\n// output observations\n[[0.1, 0.2], [0.3, 0.4]] @=> float Y[][];\n// input and output array references\nfloat x[], y[];\n\n\n//---------------------------------------------------------------------\n// train the neural network epoch by epoch\n// this is a more \"manual\" alternative to simply calling MLP.train()\n// intended for education and curiosity\n//---------------------------------------------------------------------\nfor( int i; i < epochs; i++ )\n{\n    // shuffle the observations\n    MLP.shuffle( X, Y );\n\n    // train over all observations\n    for( int j; j < X.size(); j++ )\n    {\n        // print weights and biases\n        chout <= IO.newline() <= \"--- WEIGHTS AND BIASES |\"\n              <= \" EPOCH:\" <= i+1 <= \" OBSERVATION:\" <= j+1 <= \" ---\" <= IO.newline();\n        visWeightsBiases();\n\n        // forward propagation\n        chout <= IO.newline() <= \"--- FORWARD-PROPAGATION |\"\n              <= \" EPOCH:\" <= i+1 <= \" OBSERVATION:\" <= j+1 <= \" ---\" <= IO.newline();\n        mlp.forward( X[j] );\n        visActivations();\n\n        // backpropagation\n        chout <= IO.newline() <= \"--- BACKPROPAGATION |\"\n              <= \" EPOCH:\" <= i+1 <= \" OBSERVATION:\" <= j+1 <= \" ---\" <= IO.newline();\n        mlp.backprop( Y[j], learningRate );\n        visGradients();\n    }\n    \n    // print\n    chout <= IO.newline();\n    chout <= \"********************************************\" <= IO.newline();\n    chout <= \"*** LEARNING-RATE:\" <= learningRate <= \" | EPOCH:\" <= i+1 <= \" DONE\" <= IO.newline();\n    chout <= \"********************************************\" <= IO.newline();\n\n    // pause for print\n    T_PRINT => now;\n}\n\n// print weights and biases\nchout <= IO.newline() <= \"--- FINAL WEIGHTS AND BIASES |\"\n      <= \" EPOCH:\" <= epochs <= \" ---\" <= IO.newline();\nvisWeightsBiases();\nchout <= IO.newline();\n\n// print\nchout <= \"********************************************\" <= IO.newline();\nchout <= \"************* TRAINING DONE ****************\" <= IO.newline();\nchout <= \"********************************************\" <= IO.newline();\nchout <= IO.newline();\n\n\n//---------------------------------------------------------------------\n// visualize activations\n//---------------------------------------------------------------------\nfun void visActivations()\n{\n    // chout <= \"[activations]\" <= IO.newline();\n    for ( 0 => int k; k < nodesPerLayer.size(); k++ )\n    {\n        // activations\n        chout <= \"layer \" <= k <= \" ACTIVATIONS\" <= IO.newline();\n        float a[nodesPerLayer[k]];\n        mlp.getActivations(k, a);\n        for ( 0 => int l; l < nodesPerLayer[k]; l++ )\n            chout <= a[l] <= \" \";\n        chout <= IO.newline();\n    }\n}\n\n\n//---------------------------------------------------------------------\n// visualize weights and biases\n//---------------------------------------------------------------------\nfun void visWeightsBiases()\n{\n    // chout <= \"[weights]\" <= IO.newline();\n    for ( 0 => int k; k < nodesPerLayer.size() - 1; k++ )\n    {\n        // weights\n        chout <= \"layer \" <= k <= \" WEIGHTS\" <= IO.newline();\n        float w[nodesPerLayer[k]][nodesPerLayer[k+1]];\n        mlp.getWeights(k, w);\n        for ( 0 => int l; l < nodesPerLayer[k]; l++ )\n        {\n            for ( 0 => int m; m < nodesPerLayer[k+1]; m++ )\n                chout <= w[l][m] <= \" \";\n            chout <= IO.newline();\n        }\n    }\n    \n    chout <= \"---\" <= IO.newline();\n    // chout <= \"[biases]\" <= IO.newline();\n    for ( 0 => int k; k < nodesPerLayer.size() - 1; k++ )\n    {\n        // biases\n        chout <= \"layer \" <= k <= \" BIASES\" <= IO.newline();\n        float b[nodesPerLayer[k+1]];\n        mlp.getBiases(k, b);\n        for ( 0 => int l; l < nodesPerLayer[k+1]; l++ )\n            chout <= b[l] <= \" \";\n        chout <= IO.newline();\n    }\n}\n\n\n//---------------------------------------------------------------------\n// visualize gradients\n//---------------------------------------------------------------------\nfun void visGradients()\n{\n    // chout <= \"[gradients]\" <= IO.newline();\n    for ( 0 => int k; k < nodesPerLayer.size(); k++ )\n    {\n        // gradients\n        chout <= \"layer \" <= k <= \" GRADIENTS\" <= IO.newline();\n        float g[nodesPerLayer[k]];\n        mlp.getGradients(k, g);\n        for ( 0 => int l; l < nodesPerLayer[k]; l++ )\n            chout <= g[l] <= \" \";\n        chout <= IO.newline();\n    }\n}\n",
                "data": []
            }
        },
        {
            "mlp.ck": {
                "code": "//---------------------------------------------------------------------\n// name: mlp.ck\n// desc: training a multilayer perception (MLP),\n//       a basic artificial neural network\n//       (for a step-by-step example, see mlp-manual.ck)\n//\n// version: need chuck version 1.5.0.0 or higher\n// sorting: part of ChAI (ChucK for AI)\n//\n// uncomment for MLP API:\n// MLP.help();\n//\n// author: Yikai Li\n//         Ge Wang (https://ccrma.stanford.edu/~ge/)\n// date: Winter 2023\n//---------------------------------------------------------------------\n\n// instantiate a multilayer perception\nMLP mlp;\n// learning rate\n0.01 => float learningRate;\n// number of epochs\n100 => int epochs;\n\n// nodes per layer: input, [hidden layer(s)], output\n[3, 5, 5, 2] @=> int nodesPerLayer[];\n\n// initialize with the units per layer with default activation function\n// default: AI.Sigmoid for all layers except output layer;\n// default: AI.Linear for output layer\nmlp.init( nodesPerLayer );\n\n// (ALTERNATE #1) initialize with activation function\n// mlp.init( nodesPerLayer, AI.Sigmoid );\n\n// (ALTERNATE #2) specify activation function per layer\n// [AI.ReLU, AI.Tanh, AI.Softmax] @=> int activationPerLayer[];\n// (ALTERNATE #2) initialize with activation function per layer\n// mlp.init( nodesPerLayer, activationPerLayer );\n\n// input observations\n[[0.1, 0.2, 0.3], [0.4, 0.5, 0.6]] @=> float X[][];\n// output observations\n[[0.1, 0.2], [0.3, 0.4]] @=> float Y[][];\n// print\n<<< \"training model...\", \"\" >>>;\n// train the network\nmlp.train( X, Y, learningRate, epochs );\n// ALTERNATE: train with default learning_rate=0.01, epochs=100\n// mlp.train(X, Y);\n\n// save the network into a model file, which can loaded later\n// mlp.save( me.dir() + \"model.txt\" );\n\n// predict given a new input\n[0.7, 0.8, 0.9] @=> float x[];\n// array to how output\nfloat y[2];\n// predict output given input\nmlp.predict(x, y);\n// print the output\n<<< \"predicted output:\", y[0], y[1] >>>;\n",
                "data": [
                    "https://raw.githubusercontent.com/ccrma/chuck/main/examples/ai/mlp/model.txt"
                ]
            }
        },
        {
            "model-save.ck": {
                "code": "//---------------------------------------------------------------------\n// name: model-save.ck\n// desc: training a basic artificial neural network and save the\n//       parameters to a model file, which can later be loaded\n//       using MLP.load()\n//\n// version: need chuck version 1.5.0.0 or higher\n// sorting: part of ChAI (ChucK for AI)\n//\n// uncomment for MLP API:\n// MLP.help();\n//\n// author: Yikai Li\n//         Ge Wang (https://ccrma.stanford.edu/~ge/)\n// date: Winter 2023\n//---------------------------------------------------------------------\n\n// instantiate a multilayer perception\nMLP mlp;\n\n// nodes per layer: input, [hidden layer(s)], output\n[3, 5, 2] @=> int nodesPerLayer[];\n// initialize with the units per layer with default activation function\n// default: AI.Sigmoid for all layers except output layer;\n// default: AI.Linear for output layer\nmlp.init( nodesPerLayer );\n\n// (ALTERNATE #1) initialize with activation function\n// mlp.init( nodesPerLayer, AI.Sigmoid );\n\n// (ALTERNATE #2) specify activation function per layer\n// [AI.ReLU, AI.Tanh, AI.Softmax] @=> int activationPerLayer[];\n// (ALTERNATE #2) initialize with activation function per layer\n// mlp.init( nodesPerLayer, activationPerLayer );\n\n// input observations\n[[0.1, 0.2, 0.3], [0.4, 0.5, 0.6]] @=> float X[][];\n// output observations\n[[0.1, 0.2], [0.3, 0.4]] @=> float Y[][];\n// learning rate\n0.001 => float learningRate;\n// number of epochs\n100 => int epochs;\n// train the network\nmlp.train( X, Y, learningRate, epochs );\n// ALTERNATE: train with default learning_rate=0.001, epochs=100\n// mlp.train(X, Y);\n\n// file name\n\"model2.txt\" => string filename;\n// save the network\nmlp.save( me.dir() + filename );\n// print\n<<< \"saved model to file:\", filename >>>;\n",
                "data": [
                    "https://raw.githubusercontent.com/ccrma/chuck/main/examples/ai/mlp/model2.txt"
                ]
            }
        }
    ],
    "machine": [
        {
            "eval.ck": {
                "code": "// name: eval.ck\n// desc: use Machine.eval() to compile and run code from a string;\n//       this as enables chuck to generate code to run at run-time;\n//       powerful! perilous!\n//\n// version: requires chuck-1.5.0.5 or higher\n//          Machine.eval() was first introduced in 1.5.0.0;\n//          the operation semantics was changed in 1.5.0.5 for\n//          Machine eval to run immediately, and automatically\n//          yielding the current shred to give the eval'ed code\n//          a chance to run -- all this without advancing time\n//\n// uncomment this to print out info about Machine:\n// Machine.help();\n//\n// date: Spring 2023\n\n// our code to run\n\"cherr <= \\\"hello!\\\" <= IO.newline();\" => string codeStr;\n\n// compile the string as code and spork it as a new shred\nif( !Machine.eval( codeStr ) ) <<< \"error evaluating code!\", \"\" >>>;\n\n// each of these will be evaluated and run as code,\n// each on its independent shred; Machine.eval() automatically\n// yields the originating \"evaluator\" shred, giving the evaluated\n// code a chance to run without advancing time\nMachine.eval( \"<<< 1 >>>;\" );\n<<< \"a\" >>>;\nMachine.eval( \"<<< 2 >>>;\" );\n<<< \"b\" >>>;\nMachine.eval( \"<<< 3 >>>;\" );\n<<< \"c\" >>>;\n",
                "data": []
            }
        },
        {
            "test2.ck": {
                "code": "// added by machine-help.ck\n\n// print\n<<< \"*** hello! I'm TEST 2 ***\", \"\" >>>;\n\n// print arguments\nfor( int i; i < me.args(); i++ )\n{\n    <<< \"--- got argument ->\", me.arg(i) >>>;\n}\n\n// wait\nwhile( true )\n{\n    1::second => now;\n}",
                "data": []
            }
        },
        {
            "eval-global.ck": {
                "code": "// name: eval-global.ck\n// desc: this example uses Machine.eval() to run generated code\n//       to update a global variable; this also shows Machine.eval()\n//       running the evaluatd code synchronously and immediately\n//\n// version: requires chuck-1.5.0.5 or higher\n//          Machine.eval() was first introduced in 1.5.0.0;\n//          the operation semantics was changed in 1.5.0.5 for\n//          Machine eval to run immediately, and automatically\n//          yielding the current shred to give the eval'ed code\n//          a chance to run -- all this without advancing time\n//\n// uncomment this to print out info about Machine:\n// Machine.help();\n//\n// date: Summer 2023\n\n// a shared value among shreds\nglobal int g_value;\n\n// initial value\n100 => g_value;\n\n// code str\n\"global int g_value; g_value++;\" => string code;\n\n// do this a couple of times\nrepeat( 3 )\n{\n    // this shows the execution order of Machine.eval() within\n    // a single line of code -- Machine.eval() runs the new code\n    // immediately (and synchronously) before continuing the\n    // current shred (even if it's in the middle of a statement)\n    // as shown below \n    cherr <= g_value <= \" \"\n          <= (Machine.eval(code) ? \"(eval)\" : \"(error)\") <= \" \"\n          <= g_value <= \" \"\n          <= (Machine.eval(code) ? \"(eval)\" : \"(error)\")\n          <= IO.nl();\n}\n",
                "data": []
            }
        },
        {
            "intsize.ck": {
                "code": "// get the size (in bits) of a chuck int\ncherr <= \"size of chuck int: \" <= Machine.intsize() <= \"-bit\" <= IO.newline();\n",
                "data": []
            }
        },
        {
            "machine-shred.ck": {
                "code": "// on-the-fly shred management\n\n// this is kind of like using the OTF commands \n//     add / remove / replace etc.\n// except this is done from code and also can be timed.\n// (this is also a hack for including other files)\n\n// infinite time loop \nwhile( true )\n{\n    // the path is relative to where 'chuck' is invoked\n    Machine.add( \"../basic/moe.ck\" ) => int moe;\n\n    // the operation is sample synchronous\n    500::ms => now;\n\n    // replace\n    Machine.replace( moe, \"../basic/wind.ck\" ) => int wind;\n\n    500::ms => now;\n\n    // remove\n    Machine.remove( wind );\n}\n",
                "data": []
            }
        },
        {
            "is-realtime.ck": {
                "code": "<<< \"are we running in realtime audio mode?\", \n    Machine.realtime() ? \"YES\" : \"NO \" >>>;\n\n<<< \"are we running in silent mode (e.g., --silent)?\", \n    Machine.silent() ? \"YES\" : \"NO \" >>>;\n\n",
                "data": []
            }
        },
        {
            "test1.ck": {
                "code": "// added by machine-help.ck\n\n// print\n<<< \"*** hello! I'm TEST 1 ***\", \"\" >>>;\n\n// print arguments\nfor( int i; i < me.args(); i++ )\n{\n    <<< \"--- got argument ->\", me.arg(i) >>>;\n}\n\n// wait\nwhile( true )\n{\n    1::second => now;\n}",
                "data": []
            }
        },
        {
            "machine-help.ck": {
                "code": "// usage examples for a number of Machine functions\n// (requires chuck-1.5.1.3 or higher)\n//\n// see ChucK API Reference on Machine\n// https://chuck.stanford.edu/doc/reference/base.html#Machine\n//\n// or uncomment the next line to print Machine usage\n// Machine.help()\n\n// print language version\n<<< \"chuck version:\", Machine.version() >>>;\n\n// keep informed\n<<< \"\\nMachine.eval() example...\", \"\" >>>;\n\n// compile the string as code and spork it as a new shred\n// also see eval.ck for more on Machine.eval()\nMachine.eval( \"repeat(5) { <<< Math.random2f(0,1) >>>; }\" );\n\n// keep informed\n<<< \"\\nwaiting for half a second...\", \"\" >>>;\n\n// advance time\n.5::second => now;\n\n// keep informed\n<<< \"\\ntrying some shred management...\", \"\" >>>;\n\n// add\nMachine.add( me.dir() + \"test1.ck:foo\" ) => int id;\n// yield to give new shred a chance to run\nme.yield();\n\n// replace\nMachine.replace( id, me.dir() + \"test2.ck:bar:5\" ) => id;\n// yield to give new shred a chance to run\nme.yield();\n\n// print current VM status (list of shreds)\nMachine.printStatus();\n// remove shred\nMachine.remove( id );\n\n// keep informed\n<<< \"\\ntrying more Machine functions...\", \"\" >>>;\n// print current VM time\nMachine.printTimeCheck();\n// reset shred IDs to current highest + 1\nMachine.resetShredID();\n// remove all shreds (including this one!)\nMachine.removeAllShreds();\n// reset type system and all global variables; remove all shreds\n// Machine.clearVM();\n\n// unreachable code\n<<< \"shouldn't get here\" >>>;\n",
                "data": []
            }
        },
        {
            "version.ck": {
                "code": "// ever wonder which chuck language version you are currently using?\ncherr <= \"chuck version: \" <= Machine.version() <= IO.nl();\n",
                "data": []
            }
        },
        {
            "crash.ck": {
                "code": "// ummm this expicitly and deliberately crashes ChucK; use with caution\nMachine.crash();\n\n// if ChucK didn't crash, then something is *really* wrong\n",
                "data": []
            }
        }
    ],
    "class": [
        {
            "constructors.ck": {
                "code": "// specifying and overloading class constructors\n// requires chuck-1.5.2.0 or higher\n\n// a class\nclass Foo\n{\n    // a member variable (this will be initialized before\n    // any actual constructors, as Foo's \"pre-constructor\")\n    1 => int num;\n\n    // constructor 1 \"default\"\n    fun @construct()\n    {\n        13 => num; // set num to something\n        <<< \"constructor 1:\", num >>>;\n    }\n\n    // constructor 2\n    fun @construct( int x )\n    {\n        x => num;\n        <<< \"constructor 2:\", x >>>;\n    }\n    \n    // constructor 3 (alternate method to define)\n    fun void Foo( int x, int y )\n    {\n        x*y => num;\n        <<< \"constructor 3:\", x, y >>>;\n    }\n}\n\n// declare a Foo, invoke constructor 1\nFoo f0;\n// declare a Foo, invoke constructor 1\nFoo f1();\n// declare a Foo, invoke constructor 2\nFoo f2(15);\n// instantiate a Foo, invoke constructor 3\nnew Foo(8,9) @=> Foo @ f3;\n\n// print\n<<< f0.num, f1.num, f2.num, f3.num >>>;\n\n// can also invoke constructor for each element in array\nFoo array1(2)[3];\n// print each element's num\nfor( auto f : array1 ) <<< f.num, \"\" >>>;\n\n// instantiate an array of Foo, invoking constructor for each\nnew Foo(6,5)[4] @=> Foo array2[];\n// print each element's num\nfor( auto f : array2 ) <<< f.num, \"\" >>>;\n",
                "data": []
            }
        },
        {
            "dinky.ck": {
                "code": "// this class defines the Dinky instrument\n// the variables defined at class level are member variables\n//\n// to test this: \n//    > chuck dinky.ck try.ck\n//\n// NOTE (2003): in a future version of chuck...\n//       this class will be able to extend UGen\n// NOTE (2013): the above is now possible using Chugraphs,\n//       Chugens, or Chugins!\n// NOTE (2023): finally updated this example using Chugraphs\n\n// the Dinky class\npublic class Dinky extends Chugraph\n{\n    // impulse to filter to dac\n    Impulse i => BiQuad f => Envelope e => outlet;\n    // set the filter's pole radius\n    .99 => f.prad;\n    // set equal gain zeros\n    1 => f.eqzs;\n    // set filter gain\n    .2 => f.gain;\n    // set the envelope\n    .004::second => e.duration;\n\n    public void radius( float rad )\n    { rad => f.prad; }\n\n    public void connect( UGen ugen )\n    { e => ugen; }\n\n    // t is for trigger\n    public void t( float freq )\n    {\n        // set the current sample/impulse\n        1.0 => i.next;\n        // set filter resonant frequency\n        freq => f.pfreq;\n        // open the envelope\n        e.keyOn();\n    }\n\n    // t is for trigger (using MIDI note numbers)\n    public void t( int note )\n    { t( Std.mtof( note ) ); }\n\n    // another lazy name: c (for close)\n    public void c() { e.keyOff(); }\n}\n",
                "data": []
            }
        },
        {
            "ctors-dtor.ck": {
                "code": "// example: defining basic class constructors + destructor\n\n// a class\nclass Foo\n{\n    // a member variable\n    1 => int num;\n\n    // constructor \"default\"\n    fun @construct() { 2 => num; }\n\n    // another constructor\n    fun @construct( int x ) { x => num; }\n\n    // yet another constructor\n    fun @construct( int x, int y ) { x*y => num; }\n\n    // alternate way of define a constructor\n    fun void Foo( int x, int y, int z ) { x*y*z => num; }\n\n    // destructor\n    fun @destruct() { <<< \"destructor:\", this.num >>>; }\n}\n\n// constructor \"default\"\nFoo f0;\n// constructor \"default\"\nFoo f1();\n// another constructor\nFoo f2(15);\n// yet another constructor\nnew Foo(8,9) @=> Foo @ f3;\n// yet another constructor\nnew Foo(10,11,12) @=> Foo @ f4;\n// print\n<<< f0.num, f1.num, f2.num, f3.num, f4.num >>>;\n",
                "data": []
            }
        },
        {
            "try.ck": {
                "code": "// uses the Dinky class\n// (run dinky.ck before running this, for now...)\n//\n//     > chuck dinky try\n//\n// NOTE (2003): in a future version of chuck...\n//       1. we will have better dependency/include system\n//       2. we can extend Dinky from UGen, so we don't have \n//          to use a 'connect( UGen )' function in Dinky\n// NOTE (2013): the above (#2) is now possible using Chugraphs!\n//       check out: extend/chugraph.ck\n// NOTE (2023): actually updated dinky.ck and this example\n//       to use Chugraphs\n\n// connect the rest of the patch\nDinky dinky => Gain g => NRev r => Echo e => Echo e2 => dac;\n// direct/dry\ng => dac;\ne => dac;\n\n// set up delay, gain, and mix\n1500::ms => e.max => e.delay;\n3000::ms => e2.max => e2.delay;\n1 => g.gain;\n.5 => e.gain;\n.25 => e2.gain;\n.1 => r.mix;\n\n// set the radius (should never be more than 1)\ndinky.radius( .999 );\n\n// an array (our scale)\n[ 0, 2, 4, 7, 9, 11 ] @=> int hi[];\n\n// infinite time-loop\nwhile( true )\n{\n    // trigger\n    dinky.t( 45 + Math.random2(0,3)*12 +\n             hi[Math.random2(0,hi.size()-1)] );\n    // let time pass\n    195::ms => now;\n    // close the envelope\n    dinky.c();\n    // let a bit more time pass\n    5::ms => now;\n}\n",
                "data": []
            }
        },
        {
            "destructor.ck": {
                "code": "// example of class destructor\n\n// a class\nclass Foo\n{\n    // class destructor\n    fun @destruct()\n    {\n        <<< \"destructor called...\", \"\" >>>;\n    }\n}\n\nFoo foo;\n// when `foo` goes out of scope, the destructor should be called...\n",
                "data": []
            }
        }
    ],
    "shred": [
        {
            "machine.ck": {
                "code": "// on-the-fly shred management\n\n// this is kind of like using the OTF commands \n//     add / remove / replace etc.\n// except this is done from code and also can be timed.\n// (this is also a hack for including other files)\n\n// infinite time loop \nwhile( true )\n{\n    // the path is relative to where 'chuck' is invoked\n    Machine.add( \"../basic/moe.ck\" ) => int moe;\n\n    // the operation is sample synchronous\n    500::ms => now;\n\n    // replace\n    Machine.replace( moe, \"../basic/wind.ck\" ) => int wind;\n\n    500::ms => now;\n\n    // remove\n    Machine.remove( wind );\n}\n",
                "data": []
            }
        },
        {
            "powerup.ck": {
                "code": "// power up!\n// - philipd\n\n// global noise source \nNoise n;\n\n// sweep shred\nfun void sweep( float st, float inc, time end)\n{\n    //set up the audio chain\n    n => TwoPole z => dac; \n    1  => z.norm;\n    0.1 => z.gain;\n    st => z.freq;\n\n    //store the time we entered the thread\n    now => time my_start;\n    0.0 => float my_seconds;\n\n    Math.random2f( 0.94, 0.99 ) => z.radius;\n\n    // keep going until we've passed the end time sent in by the control thread.\n    while( now < end )\n    {\n        ( now - my_start ) / 1.0::second => my_seconds; \n        Math.max( my_seconds * 4.0, 1.0 ) * 0.1  => z.gain; \n        z.freq() + inc * -0.02  => z.freq;\n        10::ms => now;\n    }\n\n    n =< z;\n    z =< dac;\n}\n\n// time loop\nwhile( true )\n{ \n    500::ms => dur d;\n    if( Math.random2( 0, 10 ) > 3 ) d * 2.0 => d;\n    if( Math.random2( 0, 10 ) > 6 ) d * 3.0 => d;\n    spork ~ sweep( 220.0 * Math.random2(1,8), \n        \t       880.0 + Math.random2f(100.0, 880.0), \n\t\t           now + Math.random2f(1.0, 3.0)::second );\n    d => now;\n}\n",
                "data": []
            }
        },
        {
            "spork2.ck": {
                "code": "// define function\nfun void foo()\n{\n    while( true )\n    {\n        <<< \"hi\" >>>;\n        .2::second => now;\n    }\n}\n\n// spork the function, remember the shred reference\nspork ~ foo() @=> Shred @ s;\n\n// wait for 2 seconds\n2::second => now;\n\n// remove by id\nMachine.remove( s.id() );\n\n// wait a little more\n2::second => now;\n",
                "data": []
            }
        },
        {
            "parent.ck": {
                "code": "// return a shred's parent shred (i.e., the shred that sporked it)\n// if the shred is a top-level shred, then me.parent() will return null\n// related: ancestor.ck\n\n<<< \"the top-level shred's ID is:\", me.id() >>>;\n<<< \"the top-level shred's parent is:\", me.parent() >>>;\n\nfun void findTheParent()\n{\n    // this will be the same as the top-level shred id\n    <<< \"the sporked shred's ID is:\", me.id() >>>;\n    <<< \"the sporked shred's parent ID is:\", me.parent().id() >>>;\n}\n\n// spork a child shred\nspork ~ findTheParent();\n\n// yield to let validateParent(...) run\nme.yield();\n",
                "data": []
            }
        },
        {
            "spork.ck": {
                "code": "// this shows how to dynamically spork shreds...\n\nfun void foo( int a )\n{\n    while( true )\n    {\n        <<<a>>>;\n        500::ms => now;\n    }\n}\n\nspork ~ foo( 1 );\n250::ms => now;\nspork ~ foo( 2 );\n\n\n// infinite time loop - children shreds leave with parent shred\nwhile( true )\n    1::second => now;\n",
                "data": []
            }
        },
        {
            "spork2-remove.ck": {
                "code": "// define function\nfun void foo()\n{\n    while( true )\n    {\n        <<< \"hi\" >>>;\n        .2::second => now;\n    }\n}\n\n// spork the function, remember the shred reference\nspork ~ foo() @=> Shred @ s;\n\n// wait for 2 seconds\n2::second => now;\n\n// remove by id; equivalent to s.exit()\nMachine.remove( s.id() );\n\n// wait a little more\n2::second => now;\n",
                "data": []
            }
        },
        {
            "spork2-exit.ck": {
                "code": "// name: spork3-exit.ck\n// desc: how to spork and terminate specific child shreds\n\n// a function to spork\nfun void go( int n )\n{\n    while( true )\n    {\n        <<< \"go\", n >>>;\n        250::ms => now;\n    }\n}\n\n// spork three shreds, save the resulting shred reference\nspork ~ go(1) @=> Shred s1;\nspork ~ go(2) @=> Shred s2;\nspork ~ go(3) @=> Shred s3;\n\n// exit the shreds\n1::second => now;\ns1.exit();\n1::second => now;\ns2.exit();\n1::second => now;\ns3.exit();\n\n// yield this shred, give chance for s3 to run at current time\nme.yield();\n// print done\n<<< \"done...\", \"\" >>>;\n\n// wait a bit more to see nothing is printed from child shreds\n1::second => now;\n\n// print out Shred functionality, if you are curious\n// Shred.help();\n\n// print done\n<<< \"exiting parent shred...\", \"\" >>>;",
                "data": []
            }
        },
        {
            "ancestor.ck": {
                "code": "// Shred.ancestor() returns the top-level shred that is directly or \n// indirectly a parent shred of the calling shred; useful for getting\n// information relevant to top-level shreds; related: parent.ck\n\n// test me\n<<< \"the top-level shred's ID is:\", me.id() >>>;\n// my ancestor\n<<< \"the top-level shred's ancestor ID is:\", me.ancestor().id(), \"\\n\" >>>;\n\n// recursive function to test finding ancestor from different \n// \"generations\" of shreds\nfun void findTheAncestor( int generation )\n{\n    // stop recursing\n    if( generation <= 0 ) return;\n\n    // calling shred\n    <<< \"the sporked shred's ID is:\", me.id() >>>;\n    // this will always be the same as the top-level shred id\n    <<< \"the sporked shred's ancestor ID is:\", me.ancestor().id(), \"\\n\" >>>;\n\n    // spork a child shred\n    spork ~ findTheAncestor( generation-1 );\n    // wait a bit to give child shred a chance to run\n    1::samp => now;\n}\n\n// recursively spork function this 10 times; me.ancestor() should always \n// point to the top-level shred\nspork ~ findTheAncestor(10);\n\n// wait to give children shreds a chance to run\n1::samp => now;\n",
                "data": []
            }
        },
        {
            "dir.ck": {
                "code": "// me is currnt shred; print directory of current file (if saved)\n<<< me.dir() >>>;\n// same as above\n<<< me.dir( 0 ) >>>;\n// one level up\n<<< me.dir( 1 ) >>>;\n// can also use negative values (same as positive)\n<<< me.dir( -2 ) >>>;\n// something absurd (should return top level path)\n<<< me.dir( 100 ) >>>;\n",
                "data": []
            }
        }
    ],
    "string": [
        {
            "strops.ck": {
                "code": "// strops.ck some basic string operations\n//\n// for string API documentation, see:\n// https://chuck.stanford.edu/doc/reference/base.html#string\n\n// three strings\n\"hello\" => string foo;\n\"hello\" => string bar;\n\"there\" => string geh;\n\n// makeshift assert\nfun void assert( int condition, string text )\n{\n    if( !condition )\n    {\n        <<< \"assertion failed: \", text >>>;\n        me.exit();\n    }\n}\n\n// equality\nassert( foo == foo, \"1\" );\nassert( foo == bar, \"2\" );\nassert( \"abc\" == \"abc\", \"3\" );\nassert( \"hello\" == foo, \"4\" );\n\nassert( foo != geh, \"5\" );\nassert( \"x\" != \"y\", \"6\" );\nassert( foo != \"there\", \"7\" );\n\n// lt\nassert( foo < geh, \"8\" );\nassert( foo < \"hello!\", \"9\" );\nassert( foo <= foo, \"10\" );\nassert( foo <= \"there\", \"11\" );\n\n// gt\nassert( foo > \"abc\", \"12\" );\nassert( foo > \"b\", \"13\" );\nassert( foo >= foo, \"14\" );\nassert( foo >= bar, \"15\" );\n\n// concatenation\nassert( \"foo\" + \"bar\" == \"foobar\", \"16\" );\n\"foo\" => string s;\n\"bar\" +=> s;\nassert( s == \"foobar\", \"17\" );\nassert( \"bar\" + 10 == \"bar10\", \"18\" );\nassert( \"bar\" + 10.0 == \"bar10.0000\", \"19\" );\nassert( 10 + \"bar\" == \"10bar\", \"20\" );\nassert( 10.0 + \"bar\" == \"10.0000bar\", \"21\" );\nassert( \"foo\" + \"bar\" + \"cle\" == \"foobarcle\", \"22\" );\nassert( \"FoO\".lower() == \"foo\", \"23\" );\nassert( \"foo\".upper() == \"FOO\", \"24\" );\nassert( \" foo  \".trim() == \"foo\", \"25\" );\nassert( \" foo \".ltrim() == \"foo \", \"26\" );\nassert( \" foo \".rtrim() == \" foo\", \"27\" );\n\n<<< \"success\" >>>;\n",
                "data": []
            }
        },
        {
            "replace.ck": {
                "code": "// replace all occurances of a substring with a different string\n// (requires chuck-1.5.1.3 or higher) @nshaheed\n\n// a string\n\"Hello, the world! Hello, the world!\" => string str;\n\n// replace instances of \"the world\" with \"ChucK\"\nstr.replace( \"the world\", \"ChucK\" );\n// et voila\n<<< str >>>;\n\n// keep on replacing\nstr.replace( \", ChucK! Hello, ChucK!\", \" the world\" );\nstr.replace( \"H\", \"h\" );\n// print\n<<< str >>>;\n\n// replace starting at position 6\nstr.replace( 6, \"cat\" );\n// et voila\n<<< str >>>;\n\n// string.replace( position, length, str )\nfor( int x : Std.range(0,10) )\n{\n    // reset\n    str => string str2;\n    // replace\n    str2.replace( 6, x, \"kitty\" );\n    // print\n    <<< \"replace( 6,\", x, \"):\", str2 >>>;\n}\n\n// for string API documentation, see:\n// https://chuck.stanford.edu/doc/reference/base.html#string\n",
                "data": []
            }
        },
        {
            "strops2.ck": {
                "code": "// strops2.ck: more string operations\n//\n// for string API documentation, see:\n// https://chuck.stanford.edu/doc/reference/base.html#string\n\n// a string\n\"the quick brown fox jumped over the lazy dog\" @=> string str;\n\n// print string\n<<< \"str:\", str >>>;\n\n// read the first char (as int)\n<<< \"str.charAt( 0 ):\", str.charAt( 0 ) >>>;\n// read 10th char\n<<< \"str.charAt( 10 ):\", str.charAt( 10 ) >>>;\n// test character by index\nstr.setCharAt( 0, 'T' );\n<<< \"str.setCharAt( 0, 'T' ):\", str >>>;\n\n// test substring -- from the 10th char\n<<< \"str.substring( 10 ):\", str.substring( 10 ) >>>;\n// test substring -- from 10th char, for 10 chars\n<<< \"str.substring( 10, 10 ):\", str.substring(10, 10) >>>;\n\n// insert\nstr.insert( 36, \"old \" );\n<<< \"str.insert( 36, \\\"old \\\" ):\", str >>>;\n\n// test erase\nstr.erase( 40, 5 );\n<<< \"str.erase( 40, 5 ):\", str >>>;\n\n// test replace\nstr.replace( 40, \"cat\" );\n<<< \"str.replace( 40, \\\"cat\\\" ):\", str >>>;\n// test replace\nstr.replace( 4, 5, \"slow\" );\n<<< \"str.replace( 4, 5, \\\"slow\\\" ):\", str >>>;\n\n// test replace | 1.5.1.3 or higher\n// str.replace( \"slow brown\", \"hungry\" );\n// <<< \"str.replace( \\\"slow brown\\\", \\\"hungry\\\" ):\", str >>>;\n\n// test find -- index of letter, return -1 if not found\n<<< \"str.find('x'):\", str.find('x') >>>;\n// test find\n<<< \"str.find('x', 15):\", str.find('x', 15) >>>;\n// test find\n<<< \"str.find(\\\"fox\\\"):\", str.find(\"fox\") >>>;\n// test find\n<<< \"str.find(\\\"fox\\\", 20):\", str.find(\"fox\", 20) >>>;\n\n// test rfind\n<<< \"str.rfind('o'):\", str.rfind('o') >>>;\n// test rfind\n<<< \"str.rfind('o', 20):\", str.rfind('o', 20) >>>;\n// test rfind\n<<< \"str.rfind(\\\"fox\\\"):\", str.rfind(\"fox\") >>>;\n// test rfind\n<<< \"str.rfind(\\\"fox\\\", 20):\", str.rfind(\"fox\", 20) >>>;\n",
                "data": []
            }
        },
        {
            "escape.ck": {
                "code": "// escape sequences\n\n// newline\n<<< \"line1\\nline2\", \"\\n\" >>>;\n\n// tab\n<<< \"a\\tb\", \"\\n\" >>>;\n\n// audible bell (uh...)\n<<< \"bell!\\a\", \"\\n\" >>>;\n\n// \"\n<<< \"->\\\"<-\", \"\\n\" >>>;\n\n// end of string\n<<< \"here\\0can't see me\", \"\\n\" >>>;\n\n// wait a bit\n200::ms => now;\n\n// octal (man ascii)\n<<< \"bell!\\007\\060---\\061\\012\", \"\" >>>;\n",
                "data": []
            }
        },
        {
            "token.ck": {
                "code": "//----------------------------------------------------\n// name: StringTokenizer\n// desc: Break a string into tokens using a whitespace delimiter\n//       Iterate through the tokens using next() + more() \n//       or get(i) to get the i-th token\n//\n// author: terry feng\n//----------------------------------------------------\n\nStringTokenizer strtok;\n\n// set the string\nstrtok.set( \"Tokenize me please!\" );\n\n// check how many tokens there are\n<<< \"tokens found:\", strtok.size() >>>;\n\n// iterate through the tokens\nwhile( strtok.more() )\n{\n    // print current token\n    <<< strtok.next(), \"\" >>>;\n}\n\n// reset the tokenizer\nstrtok.reset();\n\nstring foo;\n\n// get the first token and pass it to foo\nstrtok.next( foo );\n<<< \"first token:\", foo >>>;\n\n// another way to get the first token\n<<< \"first token:\", strtok.get( 0 ) >>>;\n\n// get last token and pass it to foo\nstrtok.get( strtok.size() - 1, foo );\n<<< \"last token:\", foo >>>;\n",
                "data": []
            }
        },
        {
            "tostr.ck": {
                "code": "// instantiate object\nEvent e;\nObject o;\n\n// call\n<<< e.toString() + \" --- \" + o.toString() >>>;\n",
                "data": []
            }
        }
    ],
    "filter": [
        {
            "lpf.ck": {
                "code": "// LPF is a low-pass filter\nNoise n => LPF lpf => dac;\n\n// infinite time-loop\nwhile( true )\n{\n    // sweep the cutoff\n    Math.sin(now/second) * 110 => Math.fabs => Std.mtof => lpf.freq;\n    // advance time\n    5::ms => now;\n}\n",
                "data": []
            }
        },
        {
            "WPKorg35.ck": {
                "code": "Noise nse => WPKorg35 fltr => dac;\n\nSinOsc sin => blackhole;\nSinOsc sinb => blackhole;\n0.01 => nse.gain;\n40 => sin.freq;\n0.0125 => sinb.freq;\n1.99999 => fltr.resonance;\ntrue => fltr.nonlinear;\n\nwhile(true){\n    40 * sinb.last() => sin.freq;\n    40 + (Math.pow((sin.last() + 1)/2.0,2) * 17000) => fltr.cutoff;\n    1::samp => now;\n}\n",
                "data": []
            }
        },
        {
            "Multicomb.ck": {
                "code": "////////////////////////////////////////////////////\n// Multicomb                                      //\n//                                                //\n// Multiple simultaneous comb filters randomly    //\n// chosen within a specified frequency range      //\n// and spread across the stereo field             //\n////////////////////////////////////////////////////\n//\n// Settings:\n//\n// num (int): set number of comb filters (default 5)\n// minfreq (float): set low frequency\n// maxfreq (float): set high frequency\n// set (float, float): set both low and high freqs\n// revtime (dur): total ring time (default 1::second)\n\nImpulse imp => Multicomb comb => dac;\n500::ms => comb.revtime;\n\nrepeat (60)\n{\n\tcomb.set(220,880);\n\t1 => imp.next;\n\t500::ms => now;\n}\n",
                "data": []
            }
        },
        {
            "rlpf.ck": {
                "code": "// our patch\nSqrOsc so => LPF f => dac;\n\n// set osc frequency\n50 => so.freq;\n// set Q\n10 => f.Q;\n// set gain\n.5 => f.gain;\n\n// infinite time-loop\nwhile( true )\n{\n    // sweep the cutoff\n    100 + Math.fabs(Math.sin(now/second)) * 5000 => f.freq;\n    // advance time\n    5::ms => now;\n}\n",
                "data": []
            }
        },
        {
            "dcblocker.ck": {
                "code": "// name: dcblocker.ck\n// desc: using a PoleZero filter for a DC blocker, which can\n//       remove/attenuate extremely low frequencies\n//\n// note: this example makes no sound; it only prints\n\n// connect patch (no sound)\nSinOsc foo => PoleZero blocker => blackhole;\n\n// set low frequency\n.1 => foo.freq;\n\n// set DC blocker parameter; controls sharpness of the cutoff;\n// closer to 1 means narrower rejection band around DC\n.95 => blocker.blockZero;\n\n// time loop\nwhile( true )\n{\n    // print before and after DC blocker\n    cherr <= \"before DC blocker: \" <= foo.last()\n          <= \" after DC blocker: \" <= blocker.last()\n          <= IO.newline();\n    // advance time\n    100::ms => now;\n}\n",
                "data": []
            }
        },
        {
            "WPDiodeLadder.ck": {
                "code": "Noise nse => WPDiodeLadder fltr => dac;\n\nSinOsc sin => blackhole;\nSinOsc sinb => blackhole;\n0.01 => nse.gain;\n40 => sin.freq;\n0.0125 => sinb.freq;\n17 => fltr.resonance;\ntrue => fltr.nonlinear;\nfalse => fltr.nlp_type;\n\nwhile(true){\n    40 * sinb.last() => sin.freq;\n    40 + (Math.pow((sin.last() + 1)/2.0,2) * 17000) => fltr.cutoff;\n    1::samp => now;\n}\n",
                "data": []
            }
        },
        {
            "hpf.ck": {
                "code": "// HPF is a high-pass filter\nNoise n => HPF f => dac;\n\n// set gain\n.5 => f.gain;\n\n// infinite time-loop\nwhile( true )\n{\n    // sweep the cutoff\n    Math.sin(now/second) * 110 => Math.fabs => Std.mtof => f.freq;\n    // advance time\n    5::ms => now;\n}\n",
                "data": []
            }
        },
        {
            "brf.ck": {
                "code": "// BRF is a band-reject filter\nSqrOsc so => BRF f => dac;\n\n// set osc frequency\n50 => so.freq;\n// set filter Q\n.25 => f.Q;\n// set gain\n.5 => f.gain;\n\n// infinite time-loop\nwhile( true )\n{\n    // sweep the cutoff\n    100 + Math.fabs(Math.sin(now/second)) * 5000 => f.freq;\n    // advance time\n    5::ms => now;\n}\n",
                "data": []
            }
        },
        {
            "bpf.ck": {
                "code": "// BPF is a band-pass filter\nNoise n => BPF f => dac;\n\n// set filter Q\n1 => f.Q;\n\n// infinite time-loop\nwhile( true )\n{\n    // sweep the cutoff\n    100 + Math.fabs(Math.sin(now/second)) * 5000 => f.freq;\n    // advance time\n    5::ms => now;\n}\n",
                "data": []
            }
        },
        {
            "rhpf.ck": {
                "code": "// HPF can also be used as a resonance high-pass filter\nSqrOsc so => HPF f => dac;\n\n// set osc frequency\n50 => so.freq;\n// set Q\n10 => f.Q;\n// set gain\n.5 => f.gain;\n\n// infinite time-loop\nwhile( true )\n{\n    // sweep the cutoff\n    100 + Math.fabs(Math.sin(now/second)) * 5000 => f.freq;\n    // advance time\n    5::ms => now;\n}\n",
                "data": []
            }
        },
        {
            "resonz.ck": {
                "code": "// ResonZ is a second-order resonance filter with equal-gain zeroes.\n// This filter keeps its gain in-check across frequencies, including\n// near the extremes; useful for sweeping\nNoise n => ResonZ f => dac;\n\n// set filter Q (higher == narrower, sharper resonance)\n2 => f.Q;\n\n// infinite time-loop\nwhile( true )\n{\n    // sweep the cutoff\n    100 + Math.fabs(Math.sin(now/second)) * 5000 => f.freq;\n    // advance time\n    5::ms => now;\n}\n",
                "data": []
            }
        }
    ],
    "spatial": [
        {
            "AmbPan3-CCRMA.ck": {
                "code": "\nCNoise noise => AmbPan3 pan => dac;\n\n0.1 => noise.gain;\n\"pink\" => noise.mode;\n\n// W  X  Y  Z  R   S   T  U  V  K  L  M   N   O  P  Q\n  [0, 1, 2, 7, 8,  9, 10, 3, 4,11,12,13, 14, 15, 5, 6] => pan.channelMap;\n\n0 => pan.elevation;\npi/2 => pan.azimuth;\n\nwhile(true)\n{\n    //pan.azimuth()+pi/1024 => pan.azimuth;\n    pan.elevation() + pi/1024 => pan.elevation;\n    5::ms => now;\n}\n\n",
                "data": []
            }
        }
    ],
    "effects": [
        {
            "chorus.ck": {
                "code": "//------------------------------------------------------------------------------\n// name: chorus.ck\n// desc: basic demo of the Chorus UGen\n//\n// The Chorus UGen adds a chorus effect to a signal. Chorus refers to an audio\n// effect in which multiple sounds occur close together in time, and with\n// similar pitch. The slight deviations in pitch and time are generally small\n// enough such that the signals are not perceived as being out-of-tune. The\n// effect is often described as adding \"shimmer\", \"richness\", or \"complexity\"\n// to the timbre. When implemented digitally, the chorus effect is acheived by\n// taking a source signal, and mixing it with delayed copies of itself. The\n// pitch of these copies is usually modulated using another signal like an LFO.\n// In ChucK, you can adjust the depth and frequency of this modulation of pitch,\n// as well as the amount of delay and how much of the chorus effect is present\n// in the mix.\n//\n// author: Alex Han\n// date: Spring 2023\n//------------------------------------------------------------------------------\n\n// set up signal chain\nSinOsc s[4]; Chorus chor[4];\n// chorus often \"shines\" best with polyphonic textures!\n[62, 65, 69, 72] @=> int notes[];\n\n// connect\nfor( int i; i < s.size(); i++ )\n{\n    // patch each voice\n    s[i] => chor[i] => dac;\n\n    // sine wave as source signal\n    s[i].gain( .2 );\n    s[i].freq( Std.mtof(notes[i]) );\n\n    // initializing a light chorus effect\n    // (try tweaking these values!)\n    chor[i].baseDelay( 10::ms );\n    chor[i].modDepth( .4 );\n    chor[i].modFreq( 1 );\n    chor[i].mix( .2 );\n}\n\n// time loop\nwhile( true )\n{\n    // nothing to do here except advance time\n    1::second => now;\n}\n",
                "data": []
            }
        },
        {
            "ExpDelay.ck": {
                "code": "////////////////////////////////////////////////////\n// ExpDelay - Feedback delay at exponentially     //\n//            changing delay times                //\n//                                                //\n// by Joel Matthys                                //\n// (c) 2014, GPL 2.0                              //\n//                                                //\n////////////////////////////////////////////////////\n//\n// Settings:\n// mix (float): 0-1, dry/wet mix\n// max (dur): maximum possible delay duration\n// delay (dur): duration of delay\n// reps (int): number of repetitions\n// durcurve (float) [0.0001-inf]: set steepness of delay curve\n//       1 = steady\n//       <1 = starts fast and slows down\n//       >1 = starts slow and speeds up \n// ampcurve (float) [0.0001-inf]: set steepness of amplitude decay\n\nModalBar pop => ExpDelay ed => dac;\n3::second => ed.max;\n3::second => ed.delay;\n\nwhile (true)\n{\n  Math.random2(54,66) => Std.mtof => pop.freq;\n  1 => pop.noteOn;\n  Math.random2f(0.5,2) => ed.durcurve;\n  Math.random2f(0.5,2) => ed.ampcurve;\n  Math.random2(5,30) => ed.reps;\n  <<< \"durcurve:\",ed.durcurve(), \"ampcurve:\",ed.ampcurve(), \"reps:\",ed.reps() >>>;\n  4::second => now;\n}\n",
                "data": []
            }
        },
        {
            "ExpEnv-modes.ck": {
                "code": "class Mode extends Chubgraph {\n    SinOsc s => ExpEnv e => outlet;\n    fun void freq(float freq) { freq => s.freq; }\n    fun void T60(dur tsixty) { tsixty => e.T60; }\n    fun void keyOn() { 1 => e.keyOn; }\n}\n\nMode mod => dac;\n\n1000 => mod.freq;\nsecond/2 => mod.T60;\nmod.keyOn();\nsecond => now;\n\n700 => mod.freq;\n2*second => mod.T60;\nmod.keyOn();\n2*second => now;\n\n1200 => mod.freq;\n3::second => mod.T60;\nmod.keyOn();\n3*second => now;\n\n\n",
                "data": []
            }
        },
        {
            "pitch-shift.ck": {
                "code": "//------------------------------------------------------------------------------\n// name: pitshift.ck\n// desc: basic demo of the PitShift (pitch shift) UGen\n//\n// The PitShift UGen uses delay lines to create a simple pitch shift effect. The\n// input signal is copied, pitch-shifted, and mixed with the original signal.\n// The amount of the pitch-shifted signal that is present can be set using .mix()\n// The amount of pitch shifting for the modified signal can be set using .shift()\n// When .shift() = 1, the modified signal has the same pitch as the original.\n// .shift() can be positive or negative.\n// The example here demonstrates a pitch shifting for two different kinds of signal\n// The first one uses a sawtooth wave as input signal, sweeping the pitch shift\n// amount between -2.5 and 2.5.\n// The second loops a SndBuf (audio file) with random pitch shift amounts.\n//\n// author: Alex Han\n// date: Spring 2023\n//------------------------------------------------------------------------------\n\nSawOsc s => PitShift ps => dac; // for example 1\nSndBuf buf => PitShift ps2 => dac; // for example 2\n\ns.gain(0);\ns.freq(440);\n\nbuf.gain(0);\n\"special:dope\" => buf.read;\n\nps.mix(.5);\nps2.mix(1);\n\n// pitch-shifted sawtooth, sweeping shift amount between -2.5 and 2.5\nfun void sawShift()\n{\n    s.gain(.2);\n\n    while(true)\n    {\n        for(-250 => int i; i < 250; i++)\n        {\n            ps.shift(i*.01);\n            chout <= \"current pitch shift amount: \" <= ps.shift();\n            chout <= IO.newline();\n            50::ms => now;\n        }\n    }\n\n}\n\n// pitch shifted audio file playback (\"dope!\") random shift amount each time\nfun void dopeShift()\n{\n    1 => buf.gain;\n\n    while(true)\n    {\n        0 => buf.pos;\n        ps2.shift(Math.random2f(-5.0, 5.0));\n        chout <= \"current pitch shift amount: \" <= ps2.shift();\n        chout <= IO.newline();\n        buf.length() => now;\n    }\n\n}\n\n// uncomment either of these to try\nspork ~ sawShift();\n// spork ~ dopeShift();\n\n// time loop\nwhile(true)\n{\n    1::second => now;\n}",
                "data": []
            }
        },
        {
            "ExpEnv.ck": {
                "code": "SinOsc s => ExpEnv eenv => dac;\n1000 => s.freq;\n0.999 => eenv.radius;\n\n100*ms => eenv.T60;  1 => eenv.keyOn;  second => now;\nsecond => eenv.T60;  1 => eenv.keyOn;  second => now;\n3*second => eenv.T60; 1 => eenv.keyOn; 3*second => now;\n\nwhile (1)  {\n   Math.random2f(0.995,0.9995) => eenv.radius;\n   Math.random2f(0.3,1.0) => eenv.gain;\n   Std.mtof(Math.random2(0,10)*2+72) => s.freq;\n   1 => eenv.keyOn;\n   0.1::second => now;\n}\n",
                "data": []
            }
        }
    ],
    "vector": [
        {
            "vec3.ck": {
                "code": "// vec3 is a primitive type\n@(1,0,0) => vec3 a;\n// declare another\n@(0,1,0) => vec3 b;\n\n// add them\na + b => vec3 sum;\n// difference\na - b => vec3 diff;\n// cross product\na * b => vec3 c;\n\n// print sum!\n<<< \"sum:\", sum >>>;\n// print difference\n<<< \"diff:\", diff >>>;\n// print cross product\n<<< \"cross product:\", c >>>;\n\n// array\n[ a, b, @(-1,1,0) ] @=> vec3 group[];\n// print them\n<<< group[0], group[1], group[2] >>>;\n\n// another v\nvec3 v;\n// set value\nv.set( 2,2,2 );\n// print magnitude\n<<< \"magnitude:\", v.magnitude() >>>;\n// normalize\nv.normalize();\n// print vector\n<<< \"normalize:\", v >>>;\n\n// multiply\n5 * v => vec3 v2;\n// print result\n<<< \"scalar multiply:\", v2 >>>;\n",
                "data": []
            }
        },
        {
            "vec2.ck": {
                "code": "// vec2 is a primitive type...\n// requires chuck-1.5.1.7 or higher\n\n// print vec2 literal\n<<< \"print vec2 literal:\", @(1,2) >>>;\n\n// variable\nvec2 a;\n// assignment\n@(3,4) => a;\n// one line\n@(5,6) => vec2 b;\n\n// print\n<<< \"print variables:\", a, b >>>;\n<<< \"print fields (x,y):\", a.x, a.y >>>;\n<<< \"print fields (u,v):\", a.u, a.v >>>;\n<<< \"print fields (s,t):\", a.s, a.t >>>;\n\n// equivalence\n<<< \"a == a :\", a == a ? \"true\" : \"false\" >>>;\n<<< \"a != 2*a :\", a != 2*a ? \"true\" : \"false\" >>>;\n<<< \"a == b :\", a == b ? \"true\" : \"false\" >>>;\n\n// casting vec2 to vec3\n@(7,8) $ vec3 => vec3 v3;\n<<< \"casting vec2 to vec3:\", v3 >>>;\n<<< \"casting vec2 to vec4:\", @(9,10) $ vec4 >>>;\n<<< \"casting vec3 to vec2:\", @(9,10,11) $ vec2 >>>;\n<<< \"casting vec4 to vec2:\", @(9,10,11,12) $ vec2 >>>;\n\n// add and minus\na + b => vec2 c;\nb - a => auto d;\n.5 * a => vec2 e;\nb * 2 => vec2 f;\nb / 2 => vec2 g;\n<<< \"plus minus:\", c, d >>>;\n<<< \"scalar multiply:\", e, f, g >>>;\n<<< \"adding vec2 literals:\", @(11,12) + @(13,14) >>>;\n<<< \"vec2 + vec3:\", @(15,16) + @(17,18,19) >>>;\n<<< \"vec4 + vec2:\", @(20,21,22,23) + @(1,1) >>>;\n// add assign\na +=> f;\n// times assign\n2 *=> g;\n<<< \"add/times assign:\", f, g >>>;\n// minus assign\na -=> f;\n// divide assign\n2 /=> g;\n<<< \"minus/divide assign:\", f, g >>>;\n\n// arrays\nvec2 vs[0];\n// append\nvs << a << b << v3$vec2 << @(24,25) << d;\n// foreach\nfor( auto v : vs ) <<< \"foreach 1:\", v >>>;\n\n// assign to reference\n[@(1,2),a,b] @=> vec2 vsB[];\n// foreach\nfor( auto v : vsB ) <<< \"foreach 2:\", v >>>;\n\n// map\nvec2 map[0]; @(100,101) => map[\"foo\"];\n<<< \"map:\", map[\"foo\"] >>>;\n\nfun void foo( vec2 v ) { <<< \"foo():\", v >>>; }\nfun void bar( vec2 vs[] ) { for( auto v : vs ) <<< \"bar():\", v >>>; }\n\n// call function\nfoo( @(1,2) );\n// call with array\nbar( [@(3,4),@(5,6)] );\n\n// print with IO\ncherr <= \"cherr: \" <= a <= \" \" <= b <= IO.nl();\n",
                "data": []
            }
        },
        {
            "interpolate.ck": {
                "code": "// name: interpolate.ck\n// desc: using vec3 as a non-linear, slewing interpolator\n//       this is quite useful to making a percentage progress\n//       towards a goal, in an amount proportional to the slew\n//       and some delta time\n\n// connect\nSinOsc foo => dac;\n\n// the interpolator\nvec3 i;\n// the interpolation rate\n10::ms => dur irate;\n// set initial .value, .goal, .slew\ni.set( 440, 440, .05 * (second/irate) );\n\n// spork interpolate function\nspork ~ interpolate( irate );\n\n// main shred sets the goal\nwhile( true )\n{\n    // set interpolator goal\n    i.update( Math.random2f(200,1000) );\n    // every so often\n    500::ms => now;\n}\n\n// function to drive interpolator(s) concurrently\nfun void interpolate( dur delta )\n{\n    while( true )\n    {\n        // interpolate (can also get new value via .value)\n        i.interp( delta ) => foo.freq;\n        // advance time by rate\n        delta => now;\n    }\n}\n",
                "data": []
            }
        },
        {
            "vecs-cast.ck": {
                "code": "// casting between vec2, vec3, vec4\n\n// vec2 to vec3\n@(1,2) $ vec4 => vec4 v4; <<< v4 >>>;\n// vec2 to vec4\n@(1,2) $ vec4 => v4; <<< v4 >>>;\n// vec3 to vec4\n@(1,2,3) $ vec4 => v4; <<< v4 >>>;\n\n// vec4 to vec3\n@(1,2,3,4) $ vec3 => vec3 v3; <<< v3 >>>;\n// vec4 to vec2\n@(1,2,3,4) $ vec2 => vec2 v2; <<< v2 >>>;\n",
                "data": []
            }
        },
        {
            "vec4.ck": {
                "code": "// vec4 is a primitive type\n@(1,2,3,4) => vec4 a;\n// declare another\n@(5,6,7,8) => vec4 b;\n\n// add them\na + b => vec4 sum;\n// difference\na - b => vec4 diff;\n// cross product (ignores w component)\na * b => vec4 c;\n\n\n// print sum!\n<<< \"sum:\", sum >>>;\n// print difference\n<<< \"diff:\", diff >>>;\n// print cross product\n<<< \"cross product:\", c >>>;\n\n\n// array\n[ a, b, c ] @=> vec4 group[];\n\n// print them\n<<< group[0], group[1], group[2] >>>;\n",
                "data": []
            }
        }
    ],
    "event": [
        {
            "broadcast.ck": {
                "code": "// broadcast.ck : event broadcast\n\n// delcare event e\nEvent e;\n\n// base function for shred\nfun void hi( Event e )\n{\n    // wait on event\n    e => now;\n\n    // print stuff out\n    <<<\"success\">>>;\n}\n\n// spork 4 shreds\nspork ~ hi( e );\nspork ~ hi( e );\nspork ~ hi( e );\nspork ~ hi( e );\n\n// yield current shred (without advancing time)\n// ... allow other shreds to start running ...\n// (alternative: advance time to allow all shreds to start running)\nme.yield();\n\n// signal all shreds waiting on event e\ne.broadcast();\n\n// advance time since this parent shred will free all child shreds on exit\n// (alternative: me.yield())\n1::ms => now;\n",
                "data": []
            }
        },
        {
            "event-x-bpm-2.ck": {
                "code": "//---------------------------------------------------------------------\n// name: event-x-bpm-2.ck\n// desc: this is the same as event-x-bpm-1.ck, but one() uses array\n//       lookup (instead of if/else) to figure out what to play on tick\n//---------------------------------------------------------------------\n\n// sometimes it's helpful to define a custom kind of Event\n// so we can associate our own data with it\nclass MyEvent extends Event\n{\n    // measure number\n    int measure;\n    // smallest beat subdivision within a measure (e.g., 16th notes)\n    // we will assume the event will be broadcast every tick\n    int tick;\n}\n\n// make a shared event that any shred can wait on\nMyEvent PULSE;\n// bpm variable\n100 => float BPM;\n// how many ticks per measure?\n16 => float ticksPerMeasure;\n\n// play volume / probablity per tick (can think of this as a sequence)\n[1.0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0] @=> float playProbs[];\n// play rate per tick\n[.5, 0, 0, 0, 1, 0, 0, 0, .5, 0, 0, 0, 1, 0, 0, 0] @=> float playRates[];\n// NOTE: the sizes of these arrays should equal ticksPerMeasure\n\n// spork timekeeper\nspork ~ metronome();\n// different functions\nspork ~ one() @=> Shred @ shOne;\nspork ~ two() @=> Shred @ shTwo;\n// a function to change the BPM\nspork ~ tempoController();\n\n// keep things running\nwhile( true )\n{\n    1::second => now;\n}\n\n// a thing to change BPM when desired\nfun void tempoController()\n{\n    // a loop to control the BPM\n    while( true )\n    {\n        // every two measures, change the BPM for fun\n        if( PULSE.tick == 0 && (PULSE.measure%2 == 0) )\n        {\n            // randomize BPM lol\n            Math.random2f( 60, 120 ) => BPM;\n            // print BPM\n            <<< \"new BPM:\", BPM >>>;\n        }\n        \n        // wait on the pulse\n        PULSE => now;\n    }\n}\n\n// metronome (our \"conductor\")\nfun void metronome()\n{\n    while( true )\n    {\n        // compute every time in case BPM changes\n        1/BPM * minute => dur BEAT;\n        // assume 4/4, compute durationm of a tick\n        BEAT*4/ticksPerMeasure => dur TICK;\n        \n        // broadcast to all shreds waiting on PULSE\n        PULSE.broadcast();\n        \n        // increment tick count\n        PULSE.tick++;\n        // print\n        cherr <= \".\"; cherr.flush();\n        // if we reached the end of a measure\n        if( PULSE.tick >= ticksPerMeasure )\n        {\n            // increment measure number\n            PULSE.measure++;\n            // reset tick count to 0\n            0 => PULSE.tick;\n            // next line\n            cherr <= IO.newline();\n        }\n        \n        // advance time by a tick duration\n        TICK => now;\n    }\n}\n\n// define function\nfun void one()\n{\n    SndBuf buffy => dac;\n    \"special:dope\" => buffy.read;\n    0 => buffy.gain;\n    \n    while( true )\n    {\n        // wait on the shared event\n        PULSE => now;\n        // look up\n        if( playProbs[PULSE.tick] > 0 ) // instead of 0, it could be a threshold controlled by a knob\n        {\n            // play\n            0 => buffy.pos;\n            // use the prob value also as volume\n            playProbs[PULSE.tick] => buffy.gain;\n            // look up the play rate\n            playRates[PULSE.tick] => buffy.rate;\n        }\n    }\n}\n\n// define function\nfun void two()\n{\n    SndBuf buffy => dac;\n    \"special:dope\" => buffy.read;\n    0 => buffy.gain;\n    \n    while( true )\n    {\n        // wait on the shared event\n        PULSE => now;\n        // in this case play every tick\n        0 => buffy.pos;\n        // HIGH PITCHED DOH\n        2 => buffy.rate;\n        .1 => buffy.gain;\n    }\n}\n",
                "data": []
            }
        },
        {
            "event-extend.ck": {
                "code": "//---------------------------------------------------------------------\n// name: event-extend.ck\n// desc: defining and using a custom Event\n//---------------------------------------------------------------------\n\n// new event class\nclass TheEvent extends Event\n{\n    int value;\n}\n\n// the event\nTheEvent e;\n\n// handler\nfun void hi( TheEvent e )\n{\n    while( true )\n    {\n        // wait on event\n        e => now;\n        // get the data\n        <<<e.value>>>;\n    }\n}\n\n// spork\nspork ~ hi( e );\nspork ~ hi( e );\nspork ~ hi( e );\nspork ~ hi( e );\n\n// yield this shred to give sporked shreds a chance to run\nme.yield();\n\n// infinite time loop\nwhile( true )\n{\n    // set data\n    Math.random2( 0, 5 ) => e.value;\n\n    // signal one waiting shred\n    e.signal();\n\n    // advance time\n    1::second => now;\n}\n",
                "data": []
            }
        },
        {
            "signal4.ck": {
                "code": "// signal-4.ck : one event signals 4 shreds\n\n// our event\nEvent e;\n\n// the base function of our shreds\nfun void hi( Event e, string id )\n{\n    // time/event loop\n    while( true )\n    {\n        // wait on event\n        e => now;\n        <<<id>>>;\n    }\n}\n\n// spork our shreds with different strings\nspork ~ hi( e, \"yo\" );\nspork ~ hi( e, \"hi\" );\nspork ~ hi( e, \"hello\" );\nspork ~ hi( e, \"hey come back here!\" );\n\n// may want to yield to give shreds chance to start\nme.yield();\n\n// time loop\nwhile( true )\n{\n    // signal one shred\n    e.signal();\n    // advance time by 1 second (alternative: me.yield())\n    1::second => now;\n}\n",
                "data": []
            }
        },
        {
            "event-extend2.ck": {
                "code": "//---------------------------------------------------------------------\n// name: event-extend2.ck\n// desc: working with shreds and custom Event to control audio\n//       the \"main\" shred sporks four child shreds, each of which \n//       sets an concurrent voice (using FrencHrn). the main shred\n//       then signals the child shreds one by one, passing along\n//       pitch and velocity info using the custom event we defined.\n//---------------------------------------------------------------------\n\n// define a custom event class\nclass TheEvent extends Event\n{\n    int pitch;\n    float velocity;\n}\n\n// instantiate the event\nTheEvent e;\n\n// shared reverb\nNRev reverb => dac;\n// set mix\n.15 => reverb.mix;\n\n// handler\nfun void hi( TheEvent e, int id )\n{\n    // voice\n    FrencHrn f => reverb;\n    \n    while( true )\n    {\n        // wait on event\n        e => now;\n        // print the data contained in the event\n        <<< \"shred\", id, \":\", e.pitch, e.velocity >>>;\n        \n        // set the pitch\n        e.pitch => Std.mtof => f.freq;\n        // play it\n        e.velocity => f.noteOn;\n        \n        // wait a bit\n        150::ms => now;\n        // note off\n        f.noteOff( 0 );\n    }\n}\n\n// spork\nspork ~ hi( e, 1 );\nspork ~ hi( e, 2 );\nspork ~ hi( e, 3 );\nspork ~ hi( e, 4 );\n\n// yield to let sporked shreds to have a chance to run and wait on the event\nme.yield();\n\n// infinite time loop\nwhile( true )\n{\n    // set pitch\n    Math.random2( 48, 84 ) => e.pitch;\n    // set velocity\n    Math.random2f( .5,1 ) => e.velocity;\n    // signal one waiting shred\n    e.signal();\n    // advance time\n    600::ms => now;\n}\n",
                "data": []
            }
        },
        {
            "event-x-bpm-1.ck": {
                "code": "//---------------------------------------------------------------------\n// name: event-x-bpm-1.ck\n// desc: shows how to\n//       1) define a custom type of Event (called MyEvent here)\n//          to hold our custom data; create a MyEvent called PULSE\n//       2) make a metronome to broadcast PULSE, which will wake\n//          up all shreds waiting on PULSE; this metronome will also\n//          update the 'measure' and 'tick' numbers in PULSE to\n//          indicate where we are in the measure\n//       3) define two shreds--one() and two()--whose timing is\n//          driven by the metronome to a \"drum beat\"\n//---------------------------------------------------------------------\n\n// sometimes it's helpful to define a custom kind of Event\n// so we can associate our own data with it\nclass MyEvent extends Event\n{\n    // measure number\n    int measure;\n    // smallest beat subdivision within a measure (e.g., 16th notes)\n    // we will assume the event will be broadcast every tick\n    int tick;\n}\n\n// make a shared event that any shred can wait on\nMyEvent PULSE;\n// global bpm variable\n100 => global float BPM;\n// how many ticks per measure?\n16 => float ticksPerMeasure;\n\n// spork timekeeper\nspork ~ metronome();\n// different functions\nspork ~ one() @=> Shred @ shOne;\nspork ~ two() @=> Shred @ shTwo;\n// a function to change the BPM\nspork ~ tempoController();\n\n// keep things running\nwhile( true )\n{\n    1::second => now;\n}\n\n// a thing to change BPM when desired\nfun void tempoController()\n{\n    // a loop to control the BPM\n    while( true )\n    {\n        // every two measures, change the BPM for fun\n        if( PULSE.tick == 0 && (PULSE.measure%2 == 0) )\n        {\n            // randomize BPM lol\n            Math.random2f( 60, 120 ) => BPM;\n            // print BPM\n            <<< \"new BPM:\", BPM >>>;\n        }\n        \n        // wait on the pulse\n        PULSE => now;\n    }\n}\n\n// metronome (our \"conductor\")\nfun void metronome()\n{\n    while( true )\n    {\n        // compute every time in case BPM changes\n        1/BPM * minute => dur BEAT;\n        // assume 4/4, compute durationm of a tick\n        BEAT*4/ticksPerMeasure => dur TICK;\n        \n        // broadcast to all shreds waiting on PULSE\n        PULSE.broadcast();\n        \n        // increment tick count\n        PULSE.tick++;\n        // print\n        cherr <= \".\"; cherr.flush();\n        // if we reached the end of a measure\n        if( PULSE.tick >= ticksPerMeasure )\n        {\n            // increment measure number\n            PULSE.measure++;\n            // reset tick count to 0\n            0 => PULSE.tick;\n            // next line\n            cherr <= IO.newline();\n        }\n    \n        // advance time by a tick duration\n        TICK => now;\n    }\n}\n\n// define function\nfun void one()\n{\n    SndBuf buffy => dac;\n    \"special:dope\" => buffy.read;\n    0 => buffy.gain;\n    \n    while( true )\n    {\n        // wait on the shared event\n        PULSE => now;\n        // play depending on tick number\n        if( PULSE.tick == 0 || PULSE.tick == 8 )\n        {\n            // LOW DOH\n            0 => buffy.pos;\n            .5 => buffy.rate;\n            .5 => buffy.gain;\n        }\n        else if( PULSE.tick == 4 || PULSE.tick == 12 )\n        {\n            0 => buffy.pos;\n            1 => buffy.rate;\n            .5 => buffy.gain;\n        }\n    }\n}\n\n// define function\nfun void two()\n{\n    SndBuf buffy => dac;\n    \"special:dope\" => buffy.read;\n    0 => buffy.gain;\n    \n    while( true )\n    {\n        // wait on the shared event\n        PULSE => now;\n        // in this case play every tick\n        0 => buffy.pos;\n        // HIGH PITCHED DOH\n        2 => buffy.rate;\n        .1 => buffy.gain;\n    }\n}\n",
                "data": []
            }
        },
        {
            "signal.ck": {
                "code": "// signal.ck : signaling events\n\n// declare an event\nEvent e;\n\n// declare function\nfun void hi( Event e )\n{\n    // wait on event e\n    e => now;\n\n    // this only happens AFTER e is signaled\n    <<<\"success\">>>;\n}\n\n// spork shred with e\nspork ~ hi( e );\n\n// yield to give the shred a chance to run (alternative: advance time)\nme.yield();\n\n// signal e\ne.signal();\n\n// advance time to let the other shred run\n// (the parent shred will free the child shred)\n// (alternative: me.yield())\n1::samp => now;\n",
                "data": []
            }
        }
    ],
    "oper": [
        {
            "oper_assign.ck": {
                "code": "// 17.ck : partial array\n\n// assign 1 to newly declared int\n1 => int i;\n\n// increment assign i\n3 +=> i;\n\n// reference assignment\nObject foo @=> Object @ bar;\n\n// (foo bar both reference same object)\n\n// declare int array 2x2\nint x[2][2];\n\n// assign\n2 => x[1][1];\n\n// assign partial array reference to 'y'\nx[1] @=> int y[];\n\n// test\nif( y[1] == 2 ) <<<\"success\">>>;\n",
                "data": []
            }
        },
        {
            "overload_overview.ck": {
                "code": "//-----------------------------------------------------------\n// the general format for overload an operator is as follows:\n//-----------------------------------------------------------\n// let's say we define a custom class...\npublic class Foo { int num; }\n\n// persistent operator overloading (trascends contexts)\n// NOTE the use of 'public' instead of 'fun' -- it's fun for all!\npublic Foo @operator =^( Foo lhs, Foo rhs )\n{ /* do stuff for Foo =^ Foo */ return rhs; }\n\n// LOCAL binary operator overload for '=>' (local to this context)\nfun Foo @operator =>( Foo lhs, Foo rhs )\n{ /* do stuff for Foo => Foo */ return rhs; }\n\n// define binary operator overload for '+'\nfun Foo @operator +( Foo lhs, Foo rhs )\n{ Foo retval; lhs.num + rhs.num => retval.num; return retval; }\n\n// define binary operator overload for '*'\nfun Foo @operator *( Foo lhs, Foo rhs )\n{ Foo retval; lhs.num * rhs.num => retval.num; return retval; }\n\n// define unary operator overload for '!'\nfun int @operator !( Foo foo )\n{ return !foo.num; }\n\n// define postfix operator overload for '++'\nfun Foo @operator ( Foo foo ) ++\n{ foo.num++; return foo; }\n\n//-----------------------------------------------------------\n// using the new overloaded operators\n//-----------------------------------------------------------\n// create 2 Foos\nFoo a, b; 1 => a.num; 2 => b.num;\n// operator in action (follows default ck operator precedence)\na + b * b + a @=> Foo c;\n// post ++ on c\nc++;\n// should print 7\n<<< c.num >>>;\n",
                "data": []
            }
        },
        {
            "overload_gru.ck": {
                "code": "// example overloading the new gruck (graphical chuck) operator,\n// can be overloaded for general-purpose use...\n\n// our example class\nclass Thing { float x; }\n\n// overload gruck operator\nfun Thing @operator -->( Thing lhs, Thing rhs )\n{\n    <<< lhs.x, rhs.x >>>;\n    return rhs;\n}\n\n// set up a few Things\nThing foo; 1 => foo.x;\nThing bar; 2 => bar.x;\nThing zaz; 3 => zaz.x;\n\n// gruck foo to bar\nfoo --> bar;\n\n// gruck foo to bar to zaz\nfoo --> bar --> zaz;\n\n// (should have printed some stuff)\n",
                "data": []
            }
        },
        {
            "overload_class.ck": {
                "code": "// example of operator overloading for custom class\n\n// a custom Number class\nclass Number\n{\n    float num;\n}\n\n// overload binary operator +\nfun Number @operator + ( Number lhs, Number rhs )\n{\n    new Number @=> Number @ n;\n    lhs.num + rhs.num => n.num;\n    return n;\n}\n\n// overload binary operator *\nfun Number @operator * ( Number lhs, Number rhs )\n{\n    new Number @=> Number @ n;\n    lhs.num * rhs.num => n.num;\n    return n;\n}\n\n// overload postfix operator ++\nfun Number @operator ( Number n ) ++\n{\n    1 +=> n.num;\n    return n;\n}\n\n// 2 Numbers\nNumber A; 1 => A.num;\nNumber B; 2 => B.num;\n// print\n<<< (A + B).num >>>;\n\n// add\nA + B @=> Number C;\n// print\n<<< C.num >>>;\n\n// increment\nC++;\n// print\n<<< C.num >>>;\n\n// a more complicated expression\n(A+B)*(A+B) @=> Number D;\n// print\n<<< D.num >>>;\n",
                "data": []
            }
        },
        {
            "overload_pre_post.ck": {
                "code": "// 1) example of overloading on objects that return primitives\n// 2) simultaneous overloading of pre/post for ++\n// 3) example of execution of pre/post increment (same order)\n\npublic class Foo\n{ 0 => int n; }\n\n// unary pre overloading\nfun int @operator !(Foo foo)\n{\n    return !foo.n;\n}\n\n// unary pre overloading\nfun int @operator ++(Foo foo)\n{\n    return ++foo.n;\n}\n\n// unary postfix overloading\nfun int @operator (Foo foo)++\n{\n    return foo.n++;\n}\n\n// make foo\nFoo a;\n// should print: 1 1 2 2 2 3\n<<< !a, ++a, ++a, a.n, a++, a.n >>>;\n",
                "data": []
            }
        },
        {
            "oper_arith_chuck.ck": {
                "code": "// use a variety of arithmetic chuck operators \n// to directly modify a value\n2 => int i;\n<<<i>>>;\n\n5 +=> i; // 7\n<<<i>>>;\n3 -=> i; // 4\n<<<i>>>;\n12 *=> i; // 48\n<<<i>>>;\n3 /=> i; // 16\n<<<i>>>;\n7 |=> i; // 10000 | 00111 = 10111 = 23\n<<<i>>>;\n14 &=> i; // 10111 & 01110 = 00110 = 6; \n<<<i>>>;\n31 ^=> i; // 00110 ^ 11111 = 11001 = 25;\n<<<i>>>;\nif ( i == 25 ) <<<\"success!\">>>;\n",
                "data": []
            }
        },
        {
            "oper_logic.ck": {
                "code": "// chuck logical operators\n\n<<<\"AND\">>>;\n<<<true && true>>>;\n<<<true && false>>>;\n\n<<<\"OR\">>>;\n<<<false || false>>>;\n<<<true || false>>>;\n\n<<<\"==\">>>;\n<<< 2 + 2 == 4>>>;\n<<< 2 + 2 == 5>>>;\n\n<<<\"!=\">>>;\n<<< 2 + 2 != 5>>>;\n<<< 2 + 2 != 4>>>;\n",
                "data": []
            }
        },
        {
            "oper_post_inc.ck": {
                "code": "// post increment operator\n\n// starting value\n4 => int i;\n// assign, then increment i\ni++ => int j;\n\n// print (i should be 1 higher than j)\n<<< i >>>;\n<<< j >>>;\n",
                "data": []
            }
        },
        {
            "overload_public.ck": {
                "code": "// global operator overloading using the 'public' keyword\n// overloading an operator in one context, and using it in another\n\n// a custom class\npublic class Foo\n{ 5 => int n; }\n\n// binary operator overloading\n// NOTE the use of 'public' keyword\npublic int @operator +(Foo lhs, Foo rhs)\n{\n    return lhs.n + rhs.n;\n}\n\n// binary unary prefix overloading\npublic int @operator !(Foo foo)\n{\n    return !foo.n;\n}\n\n// binary unary postfix overloading\npublic int @operator (Foo foo) ++\n{\n    return foo.n++;\n}\n\n// use the overloading in a different code context\n// (could be another file; here we use Machine.eval())\nMachine.eval( \"Foo a, b; <<<a++, !b, a+b>>>;\" );\n",
                "data": []
            }
        },
        {
            "oper_pre_inc.ck": {
                "code": "// ++i\n\n4 => int i;\n++i => int j;\n\n<<<\"printing i, j\">>>;\n<<<i>>>;\n<<<j>>>;\nif ( i == 5 && j == 5 ) <<<\"success\">>>;\n",
                "data": []
            }
        }
    ],
    "func": [
        {
            "func_overload_multi.ck": {
                "code": "// func_overload_multi.ck : function overloading\n\nfun void bar()\n{\n    <<<1>>>;\n}\n\nfun void bar( int i )\n{\n    <<<2>>>;\n}\n\nfun void bar( string s )\n{\n    <<<3>>>;\n}\n\nclass X\n{\n    fun void foo()\n    { <<<\"X.foo()\">>>; }\n\n    fun void foo( int i )\n    { <<<\"X.foo(int)\">>>; }\n\n    fun void foo( int a, int b )\n    { <<<\"X.foo(int, int)\">>>; }\n}\n\nclass Y extends X\n{\n    fun void foo()\n    { <<<\"Y.foo()\">>>; }\n\n    fun void foo( int a, int b )\n    { <<<\"Y.foo(int, int)\">>>; }\n}\n\nY y;\ny.foo();\ny.foo( 1 );\ny.foo( 1, 2 );\n\nX x;\nx.foo( 1, 2 );\n\nbar();\nbar(1);\nbar(\"a\");\n",
                "data": []
            }
        },
        {
            "func_void.ck": {
                "code": "// chucking ()\n\nfun void foo() { <<< \"hi!\" >>>; }\n\n// call foo\nfoo();\n\n// call foo\n() => foo;\n",
                "data": []
            }
        },
        {
            "func_recursion.ck": {
                "code": "// recursive function\n\nfun int factorial( int x )\n{ \n    if ( x <= 1 ) return 1; \n    else return x * factorial ( x-1 );\n}\n\n// call\nfactorial ( 5 ) => int answer;\n\n// test\nif ( answer == 120 ) <<<\"success\">>>;\n\n",
                "data": []
            }
        },
        {
            "func_overload.ck": {
                "code": "// 35.ck : overloading functions\n\n\nfun void foo( int a, int b )\n{ <<<\"success\">>>; }\n\nfun void foo( int a )\n{ foo( a, a ); }\n\n// call\nfoo( 2 );\n",
                "data": []
            }
        },
        {
            "func_doozey.ck": {
                "code": "// adapted from Mike McGonagle's bug report\n\nclass B1\n{\n    fun void f(float f[])\n    {\n        <<< \"in B1.f\", \"\" >>>;\n    }\n}\n\nclass E1 extends B1\n{\n    fun void f(float x, float y, float z)\n    {\n        <<< \"in E1.f\", \"\" >>>;\n    }\n}\n\nclass B2\n{\n    fun void f(float x, float y, float z)\n    {\n        <<< \"in B2.f\", \"\" >>>;\n    }\n}\n\nclass E2 extends B2\n{\n    fun void f(float f[])\n    {\n        <<< \"in E2.f\", \"\" >>>;\n    }\n}\n\nB1 b1;\nB2 b2;\nE1 e1;\nE2 e2;\n\n[ 0.1, 0.3, 0.7 ] @=> float myArray[];\n\nb1.f( myArray );       // in B1.f - correct\ne1.f( myArray );       // in B1.f - correct\ne1.f( 0.7, .553, 77 ); // in E1.f - correct\nb2.f( 0.7, .553, 77 ); // in B2.f - correct\ne2.f( 0.7, .553, 77 ); // in B2.f - correct\ne2.f( myArray );       // in E2.f - correct\n\n",
                "data": []
            }
        },
        {
            "func_overload_member.ck": {
                "code": "// 34.ck : function overloading\n\n// declare class\nclass X\n{\n    // delcare foo\n    fun void foo( int a )\n    { <<<a>>>; }\n\n    // delcare foo with different arguments\n    fun void foo( int a, int b )\n    { <<<\"success\">>>; }\n}\n\n// extend X\nclass Y extends X\n{\n    fun void foo( int a )\n    { <<<a+1>>>; }\n}\n\n// instantiate a Y\nY y;\n\n// call the right one, hopefully\ny.foo( 3, 5 );\n",
                "data": []
            }
        },
        {
            "func_obj_arg.ck": {
                "code": "// class with function taking class as argument\n\nclass Other\n{ \n    10 => int x;\n    int y;\n}\n\nclass X\n{ \n    int x;\n    int y;\n\n    public void set( Other a )\n    { \n        a.x => x;\n        a.y => y;\n    }\n} \n\n// instantiate\nOther a;\nX x;\n\n// call the function\nx.set(a);\n\n// test\nif( a.x == 10 ) <<<\"success\">>>;\n",
                "data": []
            }
        }
    ],
    "ai": [
        "pca",
        "knn",
        "features",
        "genre-classify",
        "svm",
        "hmm",
        "wekinator",
        "mlp"
    ]
}