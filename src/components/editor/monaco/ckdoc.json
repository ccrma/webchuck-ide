{
    "@array": {
        "title": "**Array Class**",
        "description": "Storage construct for sequential data of the same type; can also be used as an associative map data structure; also can be used as a stack with << operator to append/push and popBack to pop.",
        "constructors": [],
        "examples": [
            "Examples: \t [array_append.ck](https://chuck.stanford.edu/doc/examples/array/array_append.ck), [array_argument.ck](https://chuck.stanford.edu/doc/examples/array/array_argument.ck), [array_assign.ck](https://chuck.stanford.edu/doc/examples/array/array_assign.ck), [array_associative.ck](https://chuck.stanford.edu/doc/examples/array/array_associative.ck), [array_capacity.ck](https://chuck.stanford.edu/doc/examples/array/array_capacity.ck), [array_dynamic.ck](https://chuck.stanford.edu/doc/examples/array/array_dynamic.ck), [array_erase.ck](https://chuck.stanford.edu/doc/examples/array/array_erase.ck), [array_erase2.ck](https://chuck.stanford.edu/doc/examples/array/array_erase2.ck), [array_mdim.ck](https://chuck.stanford.edu/doc/examples/array/array_mdim.ck), [array_mmixed.ck](https://chuck.stanford.edu/doc/examples/array/array_mmixed.ck), [array_negative.ck](https://chuck.stanford.edu/doc/examples/array/array_negative.ck), [array_range.ck](https://chuck.stanford.edu/doc/examples/array/array_range.ck), [array_resize.ck](https://chuck.stanford.edu/doc/examples/array/array_resize.ck), [array_reverse.ck](https://chuck.stanford.edu/doc/examples/array/array_reverse.ck), [array_shuffle.ck](https://chuck.stanford.edu/doc/examples/array/array_shuffle.ck), [array_sort.ck](https://chuck.stanford.edu/doc/examples/array/array_sort.ck), [array_storage.ck](https://chuck.stanford.edu/doc/examples/array/array_storage.ck), [array_sub_assign.ck](https://chuck.stanford.edu/doc/examples/array/array_sub_assign.ck), [array_zero.ck](https://chuck.stanford.edu/doc/examples/array/array_zero.ck)"
        ],
        "functions": [
            "**Methods:**",
            "```chuck\nint cap()\n```\n(deprecated) For historical/compatibilty reasons, .cap() is always equal to .size(); instead of using .cap(), it is recommended to explicitly use .size() or .capacity().",
            "```chuck\nint capacity(int val)\n```\nEnsure capacity of the array (number of addressable elements).",
            "```chuck\nint capacity()\n```\nGet current capacity of the array (number of addressable elements).",
            "```chuck\nvoid clear()\n```\nClear the contents of the array.",
            "```chuck\nint erase(int position)\n```\nRemove element at 'position' from the array (same as popOut(int)).",
            "```chuck\nint erase(int begin, int end)\n```\nRemove element(s) in the range [begin,end).",
            "```chuck\nint erase(string key)\n```\n(map only) Erase all elements with the specified key.",
            "```chuck\nvoid getKeys(string[] keys)\n```\nReturn all keys found in associative array in keys.",
            "```chuck\nint isInMap(string key)\n```\n(map only) test if 'key' is in the map; (historical) this was renamed from .find() to avoid confusion with the vector part of array.",
            "```chuck\nvoid popBack()\n```\nRemove the last element of the array.",
            "```chuck\nvoid popFront()\n```\nRemove the first element of the array.",
            "```chuck\nvoid popOut(int position)\n```\nRemove the element at 'position' from the array (same as erase(int)).",
            "```chuck\nvoid reset()\n```\nReset array size to 0, set capacity to (at least) 8.",
            "```chuck\nvoid reverse()\n```\nReverses the array in-place.",
            "```chuck\nvoid shuffle()\n```\nShuffle the contents of the array.",
            "```chuck\nint size()\n```\nGet the number of elements in the array.",
            "```chuck\nint size(int newSize)\n```\nSet the size of the array. If the new size is less than the current size, elements will be deleted from the end; if the new size is larger than the current size, 0 or null elements will be added to the end.",
            "```chuck\nvoid sort()\n```\nSort the contents of the array in ascending order.",
            "```chuck\nvoid zero()\n```\nZero out the contents of the array; size is unchanged."
        ],
        "link": "[More...](https://chuck.stanford.edu/doc/reference/base.html#@array)"
    },
    "ABSaturator": {
        "title": "**Abel/Berners' Saturator**",
        "description": "Soft clip saturating distortion, based on examples from Abel/Berners' Music 424 course at Stanford.",
        "constructors": [
            "**Constructors:**",
            "```chuck\nABSaturator()\n```\n"
        ],
        "examples": [
            "Examples: \t [ABSaturator.ck](https://chuck.stanford.edu/doc/examples/effects/ABSaturator.ck)"
        ],
        "functions": [
            "**Methods:**",
            "```chuck\nfloat dcOffset(float arg)\n```\nConstant linear offset applied to the signal. A small offset will introduce odd harmonics into the distoration spectrum, whereas a zero offset will have only even harmonics.",
            "```chuck\nfloat dcOffset()\n```\nConstant linear offset applied to the signal. A small offset will introduce odd harmonics into the distoration spectrum, whereas a zero offset will have only even harmonics.",
            "```chuck\nfloat drive(float arg)\n```\nInput gain into the distortion section, in decibels. Controls overall amount of distortion.",
            "```chuck\nfloat drive()\n```\nInput gain into the distortion section, in decibels. Controls overall amount of distortion."
        ],
        "link": "[More...](https://chuck.stanford.edu/doc/reference/chugins.html#ABSaturator)"
    },
    "ADSR": {
        "title": "**ADSR Envelope**",
        "description": "This Envelope subclass implements a traditional ADSR (Attack, Decay, Sustain, Release) envelope. It responds to simple `keyOn` and `keyOff` messages, keeping track of its state. by Perry R. Cook and Gary P. Scavone, 1995 - 2002.",
        "constructors": [
            "**Constructors:**",
            "```chuck\nADSR()\n```\nDefault constructor for ADSR.",
            "```chuck\nADSR(dur attack, dur decay, float sustain, dur release)\n```\nConstruct an ADSR with attack, decay, sustain, and release values. Attack, decay, and release values are durations; sustain is a float value typically between 0 and 1.",
            "```chuck\nADSR(float attack, float decay, float sustain, float release)\n```\nConstruct an ADSR with attack, decay, sustain, and release values. Attack, decay, and release values are in seconds; sustain is a float value typically between 0 and 1."
        ],
        "examples": [
            "Examples: \t [adsr.ck](https://chuck.stanford.edu/doc/examples/basic/adsr.ck), [blit2.ck](https://chuck.stanford.edu/doc/examples/basic/blit2.ck)"
        ],
        "functions": [
            "**Methods:**",
            "```chuck\nfloat attackRate(float value)\n```\nSet attack rate.",
            "```chuck\nfloat attackRate()\n```\nGet attack rate.",
            "```chuck\ndur attackTime(dur value)\n```\nSet attack time.",
            "```chuck\ndur attackTime()\n```\nGet attack time.",
            "```chuck\nfloat decayRate(float value)\n```\nSet decay rate.",
            "```chuck\nfloat decayRate()\n```\nGet decay rate.",
            "```chuck\ndur decayTime(dur value)\n```\nSet decay time.",
            "```chuck\ndur decayTime()\n```\nGet decay time.",
            "```chuck\nfloat releaseRate(float value)\n```\nSet release rate.",
            "```chuck\nfloat releaseRate()\n```\nGet release rate.",
            "```chuck\ndur releaseTime(dur value)\n```\nSet release time.",
            "```chuck\ndur releaseTime()\n```\nGet release time.",
            "```chuck\nvoid set(float attackTime, float decayTime, float sustainLevel, float releaseTime)\n```\nSet attack, decay, sustain, and release all at once (in seconds).",
            "```chuck\nvoid set(dur attackDuration, dur decayDuration, float sustainLevel, dur releaseDuration)\n```\nSet attack, decay, sustain, and release all at once.",
            "```chuck\nint state()\n```\nGet state; attack=0, decay=1, sustain=2, release=3, done=4.",
            "```chuck\nfloat sustainLevel(float value)\n```\nSet sustain level.",
            "```chuck\nfloat sustainLevel()\n```\nGet sustain level."
        ],
        "link": "[More...](https://chuck.stanford.edu/doc/reference/ugens-basic.html#ADSR)"
    },
    "AI": {
        "title": "**AI Class Library**",
        "description": "AI class library.",
        "constructors": [],
        "examples": [],
        "functions": [],
        "link": "[More...](https://chuck.stanford.edu/doc/reference/ai.html#AI)"
    },
    "AmbPan3": {
        "title": "**3D Ambisonic Panner**",
        "description": "Third-order ambisonics panner (https://en.wikipedia.org/wiki/Ambisonics)",
        "constructors": [
            "**Constructors:**",
            "```chuck\nAmbPan3()\n```\n"
        ],
        "examples": [
            "Examples: \t [AmbPan3-CCRMA.ck](https://chuck.stanford.edu/doc/examples/spatial/AmbPan3-CCRMA.ck)"
        ],
        "functions": [
            "**Methods:**",
            "```chuck\nfloat azimuth(float arg)\n```\nSet horizontal angle of point source.",
            "```chuck\nfloat azimuth()\n```\nGet horizontal angle of point source.",
            "```chuck\nvoid channelMap(int[] arg)\n```\nSet the mapping of channels for the amibsonic system.",
            "```chuck\nfloat elevation(float arg)\n```\nSet vertical angle of point source.",
            "```chuck\nfloat elevation()\n```\nGet vertical angle of point source."
        ],
        "link": "[More...](https://chuck.stanford.edu/doc/reference/chugins.html#AmbPan3)"
    },
    "AutoCorr": {
        "title": "**Autocorrelation**",
        "description": "A unit analyzer that computes auto-correlation of the incoming analysis frame.",
        "constructors": [
            "**Constructors:**",
            "```chuck\nAutoCorr()\n```\nDefault constructor for AutoCorr."
        ],
        "examples": [
            "Examples: \t [autocorr.ck](https://chuck.stanford.edu/doc/examples/analysis/autocorr.ck)"
        ],
        "functions": [
            "**Methods:**",
            "```chuck\nint normalize(int flag)\n```\n",
            "```chuck\nint normalize()\n```\n",
            "```chuck\nfloat[] compute(float[] input, int normalize, float[] output)\n```\n"
        ],
        "link": "[More...](https://chuck.stanford.edu/doc/reference/uanae.html#AutoCorr)"
    },
    "BLT": {
        "title": "**Band-Limited Oscillator Base Class**",
        "description": "Super-class for band-limited oscillators.",
        "constructors": [
            "**Constructors:**",
            "```chuck\nBLT()\n```\nDefault constructor for BLT."
        ],
        "examples": [],
        "functions": [
            "**Methods:**",
            "```chuck\nfloat freq(float value)\n```\nSet frequency.",
            "```chuck\nfloat freq()\n```\nSet frequency.",
            "```chuck\nint harmonics(int value)\n```\nSet harmonics.",
            "```chuck\nint harmonics()\n```\nGet harmonics.",
            "```chuck\nfloat phase(float value)\n```\nSet phase.",
            "```chuck\nfloat phase()\n```\nGet phase."
        ],
        "link": "[More...](https://chuck.stanford.edu/doc/reference/ugens-stk.html#BLT)"
    },
    "BPF": {
        "title": "**Band-Pass Filter**",
        "description": "A bandpass filter (2nd order Butterworth).",
        "constructors": [
            "**Constructors:**",
            "```chuck\nBPF()\n```\nDefault constructor for BPF."
        ],
        "examples": [
            "Examples: \t [bpf.ck](https://chuck.stanford.edu/doc/examples/filter/bpf.ck)"
        ],
        "functions": [
            "**Methods:**",
            "```chuck\nfloat Q(float val)\n```\nSet filter resonance.",
            "```chuck\nfloat Q()\n```\nGet filter resonance.",
            "```chuck\nfloat freq(float val)\n```\nSet filter center frequency.",
            "```chuck\nfloat freq()\n```\nSet filter center frequency.",
            "```chuck\nvoid set(float freq, float Q)\n```\nGet filter frequency and resonance at the same time."
        ],
        "link": "[More...](https://chuck.stanford.edu/doc/reference/ugens-filters.html#BPF)"
    },
    "BRF": {
        "title": "**Band-Reject Filter**",
        "description": "A band-reject filter (2nd order Butterworth).",
        "constructors": [
            "**Constructors:**",
            "```chuck\nBRF()\n```\nDefault constructor for BRF."
        ],
        "examples": [
            "Examples: \t [brf.ck](https://chuck.stanford.edu/doc/examples/filter/brf.ck)"
        ],
        "functions": [
            "**Methods:**",
            "```chuck\nfloat Q(float val)\n```\nSet filter resonance.",
            "```chuck\nfloat Q()\n```\nGet filter resonance.",
            "```chuck\nfloat freq(float val)\n```\nSet filter center frequency.",
            "```chuck\nfloat freq()\n```\nGet filter center frequency.",
            "```chuck\nvoid set(float freq, float Q)\n```\nSet filter frequency and resonance at the same time."
        ],
        "link": "[More...](https://chuck.stanford.edu/doc/reference/ugens-filters.html#BRF)"
    },
    "BandedWG": {
        "title": "**Banded Waveguide**",
        "description": "This class uses banded waveguide techniques to model a variety of sounds, including bowed bars, glasses, and bowls. For more information, see Essl, G. and Cook, P. 'Banded Waveguides: Towards Physical Modelling of Bar Percussion Instruments', Proceedings of the 1999 International Computer Music Conference. Control Change Numbers: - Bow Pressure = 2 - Bow Motion = 4 - Strike Position = 8 (not implemented) - Vibrato Frequency = 11 - Gain = 1 - Bow Velocity = 128 - Instrument Presets = 16 - Uniform Bar = 0 - Tuned Bar = 1 - Glass Harmonica = 2 - Tibetan Bowl = 3 by Georg Essl, 1999 - 2002. Modified for Stk 4.0 by Gary Scavone.",
        "constructors": [
            "**Constructors:**",
            "```chuck\nBandedWG()\n```\nDefault constructor for BandedWG."
        ],
        "examples": [
            "Examples: \t [band-o-matic.ck](https://chuck.stanford.edu/doc/examples/stk/band-o-matic.ck), [bandedwg.ck](https://chuck.stanford.edu/doc/examples/stk/bandedwg.ck), [bandedwg2.ck](https://chuck.stanford.edu/doc/examples/stk/bandedwg2.ck)"
        ],
        "functions": [
            "**Methods:**",
            "```chuck\nfloat bowMotion(float value)\n```\nSet bow motion, [0.0-1.0].",
            "```chuck\nfloat bowMotion()\n```\nGet bow motion, [0.0-1.0].",
            "```chuck\nfloat bowPressure(float value)\n```\nSet bow pressure, [0.0-1.0].",
            "```chuck\nfloat bowPressure()\n```\nGet bow pressure, [0.0-1.0].",
            "```chuck\nfloat bowRate(float value)\n```\nSet bowing rate (seconds).",
            "```chuck\nfloat bowRate()\n```\nGet bowing rate (seconds).",
            "```chuck\nfloat integrationConstant(float value)\n```\nSet integration constant, vibrato frequency.",
            "```chuck\nfloat integrationConstant()\n```\nGet integration constant, vibrato frequency.",
            "```chuck\nfloat modesGain(float value)\n```\nSet amplitude for modes.",
            "```chuck\nfloat modesGain()\n```\nGet amplitude for modes.",
            "```chuck\nfloat pluck(float value)\n```\nPluck instrument, [0.0-1.0].",
            "```chuck\nint preset(int value)\n```\nSet instrument preset, (0-3, see above).",
            "```chuck\nint preset()\n```\nGet instrument preset, (0-3, see above).",
            "```chuck\nfloat startBowing(float value)\n```\nStart bowing, [0.0-1.0].",
            "```chuck\nfloat stopBowing(float value)\n```\nStop bowing, [0.0-1.0].",
            "```chuck\nfloat strikePosition(float value)\n```\nSet strike position, [0.0-1.0].",
            "```chuck\nfloat strikePosition()\n```\nGet strike position, [0.0-1.0]."
        ],
        "link": "[More...](https://chuck.stanford.edu/doc/reference/ugens-stk.html#BandedWG)"
    },
    "BeeThree": {
        "title": "**STK Organ**",
        "description": "STK Hammond-oid organ FM synthesis instrument. This class implements a simple 4 operator topology, also referred to as algorithm 8 of the TX81Z. Algorithm 8 is :     1 --.   2 -\\|   +-> Out   3 -/|   4 --.   Control Change Numbers: - Operator 4 (feedback) Gain = 2 (.controlOne) - Operator 3 Gain = 4 (.controlTwo) - LFO Speed = 11 - LFO Depth = 1 - ADSR 2 & 4 Target = 128 The basic Chowning/Stanford FM patent expired in 1995, but there exist follow-on patents, mostly assigned to Yamaha. If you are of the type who should worry about this (making money) worry away. by Perry R. Cook and Gary P. Scavone, 1995 - 2002.",
        "constructors": [
            "**Constructors:**",
            "```chuck\nBeeThree()\n```\nDefault constructor for BeeThree."
        ],
        "examples": [
            "Examples: \t [keyboard-organ.ck](https://chuck.stanford.edu/doc/examples/hid/keyboard-organ.ck)"
        ],
        "functions": [],
        "link": "[More...](https://chuck.stanford.edu/doc/reference/ugens-stk.html#BeeThree)"
    },
    "BiQuad": {
        "title": "**BiQuad Filter**",
        "description": "A BiQuad (two-pole, two-zero) filter section from STK. A method is provided for creating a resonance in the frequency response while maintaining a constant filter gain.",
        "constructors": [
            "**Constructors:**",
            "```chuck\nBiQuad()\n```\nDefault constructor for BiQuad."
        ],
        "examples": [
            "Examples: \t [wind.ck](https://chuck.stanford.edu/doc/examples/basic/wind.ck), [moe.ck](https://chuck.stanford.edu/doc/examples/basic/moe.ck)"
        ],
        "functions": [
            "**Methods:**",
            "```chuck\nfloat a0(float value)\n```\nSet filter coefficient.",
            "```chuck\nfloat a0()\n```\nGet filter coefficient.",
            "```chuck\nfloat a1(float value)\n```\nSet filter coefficient.",
            "```chuck\nfloat a1()\n```\nGet filter coefficient.",
            "```chuck\nfloat a2(float value)\n```\nSet filter coefficient.",
            "```chuck\nfloat a2()\n```\nGet filter coefficient.",
            "```chuck\nfloat b0(float value)\n```\nSet filter coefficient.",
            "```chuck\nfloat b0()\n```\nGet filter coefficient.",
            "```chuck\nfloat b1(float value)\n```\nSet filter coefficient.",
            "```chuck\nfloat b1()\n```\nGet filter coefficient.",
            "```chuck\nfloat b2(float value)\n```\nSet filter coefficient.",
            "```chuck\nfloat b2()\n```\nGet filter coefficient.",
            "```chuck\nint eqzs(int value)\n```\nEnable equal-gain zeroes.",
            "```chuck\nint norm(int value)\n```\nToggle normalization.",
            "```chuck\nint norm()\n```\nGet normalization setting.",
            "```chuck\nfloat pfreq(float freq)\n```\nSet resonance frequency (poles).",
            "```chuck\nfloat pfreq()\n```\nGet resonance frequency (poles).",
            "```chuck\nfloat prad(float value)\n```\nSet Pole radius (values greater than 1 will be unstable).",
            "```chuck\nfloat prad()\n```\nGet pole radius.",
            "```chuck\nfloat pregain(float level)\n```\nSet pregain.",
            "```chuck\nfloat pregain()\n```\nGet pregain.",
            "```chuck\nfloat zfreq(float freq)\n```\nSet notch frequency.",
            "```chuck\nfloat zfreq()\n```\nGet notch frequency.",
            "```chuck\nfloat zrad(float value)\n```\nSet zero radius.",
            "```chuck\nfloat zrad()\n```\nGet zero radius."
        ],
        "link": "[More...](https://chuck.stanford.edu/doc/reference/ugens-filters.html#BiQuad)"
    },
    "Bitcrusher": {
        "title": "**Bitcrusher Effect**",
        "description": "Applies aliased downsampling and sample-width reduction to create a variety of distortion effects.",
        "constructors": [
            "**Constructors:**",
            "```chuck\nBitcrusher()\n```\n"
        ],
        "examples": [
            "Examples: \t [Bitcrusher.ck](https://chuck.stanford.edu/doc/examples/effects/Bitcrusher.ck)"
        ],
        "functions": [
            "**Methods:**",
            "```chuck\nint bits(int arg)\n```\nNumber of bits to reduce signal to [1-32].",
            "```chuck\nint bits()\n```\nNumber of bits to reduce signal to [1-32].",
            "```chuck\nint downsample(int arg)\n```\nFactor by which to downsample signal by decimation [&ge;1].",
            "```chuck\nint downsample()\n```\nFactor by which to downsample signal by decimation [&ge;1].",
            "```chuck\nint downsampleFactor(int arg)\n```\nFactor by which to downsample signal by decimation [&ge;1].",
            "```chuck\nint downsampleFactor()\n```\nFactor by which to downsample signal by decimation [&ge;1]."
        ],
        "link": "[More...](https://chuck.stanford.edu/doc/reference/chugins.html#Bitcrusher)"
    },
    "Blit": {
        "title": "**Band-Limited Impulse Train**",
        "description": "This class generates a band-limited impulse train using a closed-form algorithm reported by Stilson and Smith in 'Alias-Free Digital Synthesis of Classic Analog Waveforms', 1996. The user can specify both the fundamental frequency of the impulse train and the number of harmonics contained in the resulting signal. The signal is normalized so that the peak value is +/-1.0. If `nHarmonics` is 0, then the signal will contain all harmonics up to half the sample rate. Note, however, that this setting may produce aliasing in the signal when the frequency is changing (no automatic modification of the number of harmonics is performed by the `setFrequency()` function). Original code by Robin Davies, 2005. Revisions by Gary Scavone for STK, 2005.",
        "constructors": [
            "**Constructors:**",
            "```chuck\nBlit()\n```\nDefault constructor for Blit."
        ],
        "examples": [
            "Examples: \t [blit.ck](https://chuck.stanford.edu/doc/examples/basic/blit.ck), [blit2.ck](https://chuck.stanford.edu/doc/examples/basic/blit2.ck), [foo2.ck](https://chuck.stanford.edu/doc/examples/basic/foo2.ck)"
        ],
        "functions": [],
        "link": "[More...](https://chuck.stanford.edu/doc/reference/ugens-stk.html#Blit)"
    },
    "BlitSaw": {
        "title": "**Band-Limited Sawtooth Oscillator**",
        "description": "This class generates a band-limited sawtooth waveform using a closed-form algorithm reported by Stilson and Smith in 'Alias-Free Digital Synthesis of Classic Analog Waveforms', 1996. The user can specify both the fundamental frequency of the sawtooth and the number of harmonics contained in the resulting signal. If `nHarmonics` is 0, then the signal will contain all harmonics up to half the sample rate. Note, however, that this setting may produce aliasing in the signal when the frequency is changing (no automatic modification of the number of harmonics is performed by the `setFrequency()` function). Based on initial code of Robin Davies, 2005. Modified algorithm code by Gary Scavone, 2005.",
        "constructors": [
            "**Constructors:**",
            "```chuck\nBlitSaw()\n```\nDefault constructor for BlitSaw."
        ],
        "examples": [],
        "functions": [],
        "link": "[More...](https://chuck.stanford.edu/doc/reference/ugens-stk.html#BlitSaw)"
    },
    "BlitSquare": {
        "title": "**Band-Limited Square Wave Oscillator**",
        "description": "This class generates a band-limited square wave signal. It is derived in part from the approach reported by Stilson and Smith in 'Alias-Free Digital Synthesis of Classic Analog Waveforms', 1996. The algorithm implemented in this class uses a SincM function with an even M value to achieve a bipolar bandlimited impulse train. This signal is then integrated to achieve a square waveform. The integration process has an associated DC offset but that is subtracted off the output signal. The user can specify both the fundamental frequency of the waveform and the number of harmonics contained in the resulting signal. If `nHarmonics` is 0, then the signal will contain all harmonics up to half the sample rate. Note, however, that this setting may produce aliasing in the signal when the frequency is changing (no automatic modification of the number of harmonics is performed by the `setFrequency()` function). Based on initial code of Robin Davies, 2005. Modified algorithm code by Gary Scavone, 2005.",
        "constructors": [
            "**Constructors:**",
            "```chuck\nBlitSquare()\n```\nDefault constructor for BlitSquare."
        ],
        "examples": [],
        "functions": [],
        "link": "[More...](https://chuck.stanford.edu/doc/reference/ugens-stk.html#BlitSquare)"
    },
    "BlowBotl": {
        "title": "**STK Blow Bottle**",
        "description": "This class implements a helmholtz resonator (biquad filter) with a polynomial jet excitation (a la Cook). Control Change Numbers: - Noise Gain = 4 - Vibrato Frequency = 11 - Vibrato Gain = 1 - Volume = 128 by Perry R. Cook and Gary P. Scavone, 1995 - 2002.",
        "constructors": [
            "**Constructors:**",
            "```chuck\nBlowBotl()\n```\nDefault constructor for BlowBotl."
        ],
        "examples": [
            "Examples: \t [blowbotl.ck](https://chuck.stanford.edu/doc/examples/stk/blowbotl.ck), [blowbotl2.ck](https://chuck.stanford.edu/doc/examples/stk/blowbotl2.ck)"
        ],
        "functions": [
            "**Methods:**",
            "```chuck\nfloat noiseGain(float value)\n```\nSet noise component gain, [0.0-1.0].",
            "```chuck\nfloat noiseGain()\n```\nGet noise component gain, [0.0-1.0].",
            "```chuck\nfloat rate(float value)\n```\nSet rate of attack.",
            "```chuck\nfloat rate()\n```\nGet rate of attack.",
            "```chuck\nfloat startBlowing(float value)\n```\nStart blowing, [0.0-1.0].",
            "```chuck\nfloat stopBlowing(float value)\n```\nStop blowing, [0.0-1.0].",
            "```chuck\nfloat vibratoFreq(float value)\n```\nSet vibrato frequency (Hz).",
            "```chuck\nfloat vibratoFreq()\n```\nGet vibrato frequency (Hz).",
            "```chuck\nfloat vibratoGain(float value)\n```\nSet vibrato gain, [0.0-1.0].",
            "```chuck\nfloat vibratoGain()\n```\nGet vibrato gain, [0.0-1.0].",
            "```chuck\nfloat volume(float value)\n```\nSet volume, [0.0-1.0].",
            "```chuck\nfloat volume()\n```\nGet volume, [0.0-1.0]."
        ],
        "link": "[More...](https://chuck.stanford.edu/doc/reference/ugens-stk.html#BlowBotl)"
    },
    "BlowHole": {
        "title": "**STK Blow Hole**",
        "description": "This class is based on the clarinet model, with the addition of a two-port register hole and a three-port dynamic tonehole implementation, as discussed by Scavone and Cook (1998). In this implementation, the distances between the reed/register hole and tonehole/bell are fixed. As a result, both the tonehole and register hole will have variable influence on the playing frequency, which is dependent on the length of the air column. In addition, the highest playing freqeuency is limited by these fixed lengths. This is a digital waveguide model, making its use possibly subject to patents held by Stanford University, Yamaha, and others. Control Change Numbers: - Reed Stiffness = 2 - Noise Gain = 4 - Tonehole State = 11 - Register State = 1 - Breath Pressure = 128 Perry R. Cook and Gary P. Scavone, 1995 - 2002.",
        "constructors": [
            "**Constructors:**",
            "```chuck\nBlowHole()\n```\nDefault constructor for BlowHole."
        ],
        "examples": [
            "Examples: \t [blowhole.ck](https://chuck.stanford.edu/doc/examples/stk/blowhole.ck), [blowhole2.ck](https://chuck.stanford.edu/doc/examples/stk/blowhole2.ck)"
        ],
        "functions": [
            "**Methods:**",
            "```chuck\nfloat noiseGain(float value)\n```\nSet noise component gain, [0.0-1.0].",
            "```chuck\nfloat noiseGain()\n```\nGet noise component gain, [0.0-1.0].",
            "```chuck\nfloat pressure(float value)\n```\nSet pressure, [0.0-1.0].",
            "```chuck\nfloat pressure()\n```\nGet pressure, [0.0-1.0].",
            "```chuck\nfloat rate(float value)\n```\nSet rate of attack, [0.0-1.0].",
            "```chuck\nfloat rate()\n```\nGet rate of attack, [0.0-1.0].",
            "```chuck\nfloat reed(float value)\n```\nSet reed stiffness, [0.0-1.0].",
            "```chuck\nfloat reed()\n```\nGet reed stiffness, [0.0-1.0].",
            "```chuck\nfloat startBlowing(float value)\n```\nStart blowing, [0.0-1.0].",
            "```chuck\nfloat stopBlowing(float value)\n```\nStop blowing, [0.0-1.0].",
            "```chuck\nfloat tonehole(float value)\n```\nSet tonehole size, [0.0-1.0].",
            "```chuck\nfloat tonehole()\n```\nGet tonehole size, [0.0-1.0].",
            "```chuck\nfloat vent(float value)\n```\nSet vent frequency, [0.0-1.0].",
            "```chuck\nfloat vent()\n```\nGet vent frequency, [0.0-1.0]."
        ],
        "link": "[More...](https://chuck.stanford.edu/doc/reference/ugens-stk.html#BlowHole)"
    },
    "Bowed": {
        "title": "**STK Bowed String**",
        "description": "This class implements a bowed string model, a la Smith (1986), after McIntyre, Schumacher, Woodhouse (1983). This is a digital waveguide model, making its use possibly subject to patents held by Stanford University, Yamaha, and others. Control Change Numbers: - Bow Pressure = 2 - Bow Position = 4 - Vibrato Frequency = 11 - Vibrato Gain = 1 - Volume = 128 by Perry R. Cook and Gary P. Scavone, 1995 - 2002.",
        "constructors": [
            "**Constructors:**",
            "```chuck\nBowed()\n```\nDefault constructor for Bowed."
        ],
        "examples": [
            "Examples: \t [bowed.ck](https://chuck.stanford.edu/doc/examples/stk/bowed.ck), [bowed2.ck](https://chuck.stanford.edu/doc/examples/stk/bowed2.ck)"
        ],
        "functions": [
            "**Methods:**",
            "```chuck\nfloat bowPosition(float value)\n```\nSet bow position, [0.0-1.0].",
            "```chuck\nfloat bowPosition()\n```\nGet bow position, [0.0-1.0].",
            "```chuck\nfloat bowPressure(float value)\n```\nSet bow pressure, [0.0-1.0].",
            "```chuck\nfloat bowPressure()\n```\nGet bow pressure, [0.0-1.0].",
            "```chuck\nfloat startBowing(float value)\n```\nStart bowing, [0.0-1.0].",
            "```chuck\nfloat stopBowing(float value)\n```\nStop bowing, [0.0-1.0].",
            "```chuck\nfloat vibratoFreq(float value)\n```\nSet vibrato frequency (Hz).",
            "```chuck\nfloat vibratoFreq()\n```\nGet vibrato frequency (Hz).",
            "```chuck\nfloat vibratoGain(float value)\n```\nSet vibrato gain, [0.0-1.0].",
            "```chuck\nfloat vibratoGain()\n```\nGet vibrato gain, [0.0-1.0].",
            "```chuck\nfloat volume(float value)\n```\nSet volume, [0.0-1.0].",
            "```chuck\nfloat volume()\n```\nGet volume, [0.0-1.0]."
        ],
        "link": "[More...](https://chuck.stanford.edu/doc/reference/ugens-stk.html#Bowed)"
    },
    "Brass": {
        "title": "**STK Brass**",
        "description": "This class implements a simple brass instrument waveguide model, a la Cook (TBone, HosePlayer). This is a digital waveguide model, making its use possibly subject to patents held by Stanford University, Yamaha, and others. Control Change Numbers: - Lip Tension = 2 - Slide Length = 4 - Vibrato Frequency = 11 - Vibrato Gain = 1 - Volume = 128 by Perry R. Cook and Gary P. Scavone, 1995 - 2002.",
        "constructors": [
            "**Constructors:**",
            "```chuck\nBrass()\n```\nDefault constructor for Brass."
        ],
        "examples": [
            "Examples: \t [brass.ck](https://chuck.stanford.edu/doc/examples/stk/brass.ck), [brass2.ck](https://chuck.stanford.edu/doc/examples/stk/brass2.ck)"
        ],
        "functions": [
            "**Methods:**",
            "```chuck\nfloat clear(float value)\n```\nClear instrument.",
            "```chuck\nfloat lip(float value)\n```\nSet lip tension, [0.0-1.0].",
            "```chuck\nfloat lip()\n```\nGet lip tension, [0.0-1.0].",
            "```chuck\nfloat rate(float value)\n```\nSet rate of attack (seconds).",
            "```chuck\nfloat rate()\n```\nGet rate of attack (seconds).",
            "```chuck\nfloat slide(float value)\n```\nSet slide length, [0.0-1.0].",
            "```chuck\nfloat slide()\n```\nGet slide length, [0.0-1.0].",
            "```chuck\nfloat startBlowing(float value)\n```\nStart blowing, [0.0-1.0].",
            "```chuck\nfloat stopBlowing(float value)\n```\nStop blowing, [0.0-1.0].",
            "```chuck\nfloat vibratoFreq(float value)\n```\nSet vibrato frequency (Hz).",
            "```chuck\nfloat vibratoFreq()\n```\nGet vibrato frequency (Hz).",
            "```chuck\nfloat vibratoGain(float value)\n```\nSet vibrato gain, [0.0-1.0].",
            "```chuck\nfloat vibratoGain()\n```\nGet vibrato gain, [0.0-1.0].",
            "```chuck\nfloat volume(float value)\n```\nSet volume, [0.0-1.0].",
            "```chuck\nfloat volume()\n```\nGet volume, [0.0-1.0]."
        ],
        "link": "[More...](https://chuck.stanford.edu/doc/reference/ugens-stk.html#Brass)"
    },
    "CKDoc": {
        "title": "**ChucK Documentation Generator**",
        "description": "A ChucK documentation generator. Based on Spencer Salazar's ckdoc utility.",
        "constructors": [
            "**Constructors:**",
            "```chuck\nCKDoc()\n```\nDefault constructor for CKDoc."
        ],
        "examples": [],
        "functions": [
            "**Methods:**",
            "```chuck\nvoid addGroup(Type[] types, string name, string shortName, string description)\n```\nAdd a group of types to be documented, including group 'name', a 'shortName' to be used for any files, and a group 'description'.",
            "```chuck\nvoid addGroup(string[] typeNames, string name, string shortName, string description)\n```\nAdd a group of types (by type name) to be documented, including group 'name', a 'shortName' to be used for any files, and a group 'description'.",
            "```chuck\nvoid addGroupExternal(string name, string URL, string description, string longDesc)\n```\nAdd a group documention at an external URL location.",
            "```chuck\nvoid clear()\n```\nClear all added groups.",
            "```chuck\nstring examplesRoot(string path)\n```\nSet the examples directory root path; returns what was set.",
            "```chuck\nstring examplesRoot()\n```\nGet the current examples directory root path.",
            "```chuck\nstring genCSS()\n```\nGenerate CSS; return as string.",
            "```chuck\nvoid genGroups(string[] results)\n```\nGenerate documentation for all added groups, return each in a separate entry.",
            "```chuck\nstring genIndex(string indexTitle)\n```\nGenerate top-level index; return as string.",
            "```chuck\nstring genType(Type type)\n```\nGenerate documentation for a single Type.",
            "```chuck\nstring genType(string typeName)\n```\nGenerate documentation for a single Type (by name).",
            "```chuck\nint numGroups()\n```\nGet the number of groups added.",
            "```chuck\nint outputFormat(int which)\n```\nSet which output format to use; see CKDoc.HTML, CKDoc.TEXT, CKDoc.MARKDOWN, CKDoc.JSON.",
            "```chuck\nint outputFormat()\n```\nSet which output format is selected; see CKDoc.HTML, CKDoc.TEXT, CKDoc.MARKDOWN, CKDoc.JSON.",
            "```chuck\nint outputToDir(string path, string indexTitle)\n```\nGenerate everything as files into the output directory.",
            "```chuck\nint sort(int toggle)\n```\nEnable or disable alphabetical sorting of functions and variables.",
            "```chuck\nint sort()\n```\nGet the current status of alphabetical sorting."
        ],
        "link": "[More...](https://chuck.stanford.edu/doc/reference/utils.html#CKDoc)"
    },
    "CNoise": {
        "title": "**Colored Noise Generator**",
        "description": "A noise generator with multiple noise synthesis modes.",
        "constructors": [
            "**Constructors:**",
            "```chuck\nCNoise()\n```\nDefault constructor for CNoise.",
            "```chuck\nCNoise(string mode)\n```\nConstruct a CNoise with synthesis mode. Supported modes are \"white\", \"pink\", \"flip\", and \"xor\"."
        ],
        "examples": [],
        "functions": [
            "**Methods:**",
            "```chuck\nfloat fprob(float fprob)\n```\nProbability [0-1] used for calculating XOR noise.",
            "```chuck\nstring mode(string mode)\n```\nNoise synthesis mode. Supported modes are \"white\", \"pink\", \"flip\", and \"xor\"."
        ],
        "link": "[More...](https://chuck.stanford.edu/doc/reference/ugens-basic.html#CNoise)"
    },
    "Centroid": {
        "title": "**Spectral Centroid Analyzer**",
        "description": "A unit analyzer that computes the spectral centroid from a magnitude spectrum (either from incoming UAna or manually given), and outputs a single number.",
        "constructors": [
            "**Constructors:**",
            "```chuck\nCentroid()\n```\nDefault constructor for Centroid."
        ],
        "examples": [
            "Examples: \t [centroid.ck](https://chuck.stanford.edu/doc/examples/ai/features/centroid.ck), [feature-extract.ck](https://chuck.stanford.edu/doc/examples/ai/genre-classify/feature-extract.ck), [genre-classify.ck](https://chuck.stanford.edu/doc/examples/ai/genre-classify/genre-classify.ck)"
        ],
        "functions": [
            "**Methods:**",
            "```chuck\nfloat compute(float[] input)\n```\nManually computes the centroid from a float array."
        ],
        "link": "[More...](https://chuck.stanford.edu/doc/reference/uanae.html#Centroid)"
    },
    "Chorus": {
        "title": "**Chorus Effect**",
        "description": "A chorus effect. by Perry R. Cook and Gary P. Scavone, 1995 - 2002.",
        "constructors": [
            "**Constructors:**",
            "```chuck\nChorus()\n```\nDefault constructor for Chorus."
        ],
        "examples": [
            "Examples: \t [chorus.ck](https://chuck.stanford.edu/doc/examples/effects/chorus.ck)"
        ],
        "functions": [
            "**Methods:**",
            "```chuck\ndur baseDelay(dur value)\n```\nSet base delay.",
            "```chuck\ndur baseDelay()\n```\nGet base delay.",
            "```chuck\nvoid max(dur baseDelay, float modDepth)\n```\n",
            "```chuck\nfloat mix(float value)\n```\nSet effect mix.",
            "```chuck\nfloat mix()\n```\nGet effect mix.",
            "```chuck\nfloat modDepth(float value)\n```\nSet modulation depth.",
            "```chuck\nfloat modDepth()\n```\nGet modulation depth.",
            "```chuck\nfloat modFreq(float value)\n```\nSet modulation frequency.",
            "```chuck\nfloat modFreq()\n```\nGet modulation frequency."
        ],
        "link": "[More...](https://chuck.stanford.edu/doc/reference/ugens-stk.html#Chorus)"
    },
    "Chroma": {
        "title": "**Chroma Feature Analyzer**",
        "description": "A unit analyzer that computes the Chroma features from a magnitude spectrum (either from an incoming UAna, or given manually), and outputs a vector of coefficients.",
        "constructors": [
            "**Constructors:**",
            "```chuck\nChroma()\n```\nDefault constructor for Chroma."
        ],
        "examples": [
            "Examples: \t [chroma.ck](https://chuck.stanford.edu/doc/examples/ai/features/chroma.ck)"
        ],
        "functions": [
            "**Methods:**",
            "```chuck\nfloat compute(float[] input, float[] output)\n```\nManually computes the Chroma of the input (an FFT spectrum), and stores the results in the output array (Chroma coefficients).",
            "```chuck\nint highOctNum(int high_oct_num)\n```\nSet the highest octave number for Chroma analysis.",
            "```chuck\nint highOctNum()\n```\nGet the highest octave number for Chroma analysis.",
            "```chuck\nint lowOctNum(int low_oct_num)\n```\nSet the lowest octave number for Chroma analysis.",
            "```chuck\nint lowOctNum()\n```\nGet the lowest octave number for Chroma analysis.",
            "```chuck\nfloat sampleRate(float sample_rate)\n```\nSet the sample rate for Chroma analysis.",
            "```chuck\nfloat sampleRate()\n```\nGet the sample rate for Chroma analysis."
        ],
        "link": "[More...](https://chuck.stanford.edu/doc/reference/uanae.html#Chroma)"
    },
    "Chugen": {
        "title": "**User-Created UGen**",
        "description": "Base class for user-created in-language unit generators.",
        "constructors": [
            "**Constructors:**",
            "```chuck\nChugen()\n```\nDefault constructor for Chugen."
        ],
        "examples": [
            "Examples: \t [chugen.ck](https://chuck.stanford.edu/doc/examples/extend/chugen.ck)"
        ],
        "functions": [],
        "link": "[More...](https://chuck.stanford.edu/doc/reference/ugens-basic.html#Chugen)"
    },
    "Chugraph": {
        "title": "**Subgraph-Based User-Created UGen**",
        "description": "Base class for subgraph-based user-created in-language unit generators.",
        "constructors": [
            "**Constructors:**",
            "```chuck\nChugraph()\n```\nDefault constructor for Chugraph."
        ],
        "examples": [
            "Examples: \t [chugraph.ck](https://chuck.stanford.edu/doc/examples/extend/chugraph.ck), [dinky.ck](https://chuck.stanford.edu/doc/examples/class/dinky.ck), [try.ck](https://chuck.stanford.edu/doc/examples/class/try.ck), [ks-chord.ck](https://chuck.stanford.edu/doc/examples/deep/ks-chord.ck)"
        ],
        "functions": [],
        "link": "[More...](https://chuck.stanford.edu/doc/reference/ugens-basic.html#Chugraph)"
    },
    "Clarinet": {
        "title": "**STK Clarinet**",
        "description": "This class implements a simple clarinet physical model, as discussed by Smith (1986), McIntyre, Schumacher, Woodhouse (1983), and others. This is a digital waveguide model, making its use possibly subject to patents held by Stanford University, Yamaha, and others. Control Change Numbers: - Reed Stiffness = 2 - Noise Gain = 4 - Vibrato Frequency = 11 - Vibrato Gain = 1 - Breath Pressure = 128 by Perry R. Cook and Gary P. Scavone, 1995 - 2002.",
        "constructors": [
            "**Constructors:**",
            "```chuck\nClarinet()\n```\nDefault constructor for Clarinet."
        ],
        "examples": [
            "Examples: \t [clarinet.ck](https://chuck.stanford.edu/doc/examples/stk/clarinet.ck), [clarinet2.ck](https://chuck.stanford.edu/doc/examples/stk/clarinet2.ck), [polyfony2.ck](https://chuck.stanford.edu/doc/examples/midi/polyfony2.ck)"
        ],
        "functions": [
            "**Methods:**",
            "```chuck\nfloat clear(float value)\n```\nClear instrument.",
            "```chuck\nfloat noiseGain(float value)\n```\nSet noise component gain, [0.0-1.0].",
            "```chuck\nfloat noiseGain()\n```\nGet noise component gain, [0.0-1.0].",
            "```chuck\nfloat pressure(float value)\n```\nSet pressure, [0.0-1.0].",
            "```chuck\nfloat pressure()\n```\nGet pressure, [0.0-1.0].",
            "```chuck\nfloat rate(float value)\n```\nSet rate of attack (seconds).",
            "```chuck\nfloat rate()\n```\nGet rate of attack (seconds).",
            "```chuck\nfloat reed(float value)\n```\nSet reed stiffness, [0.0-1.0].",
            "```chuck\nfloat reed()\n```\nGet reed stiffness, [0.0-1.0].",
            "```chuck\nfloat startBlowing(float value)\n```\nStart blowing, [0.0-1.0].",
            "```chuck\nfloat stopBlowing(float value)\n```\nStop blowing, [0.0-1.0].",
            "```chuck\nfloat vibratoFreq(float value)\n```\nSet vibrato frequency (Hz).",
            "```chuck\nfloat vibratoFreq()\n```\nGet vibrato frequency (Hz).",
            "```chuck\nfloat vibratoGain(float value)\n```\nSet vibrato gain, [0.0-1.0].",
            "```chuck\nfloat vibratoGain()\n```\nGet vibrato gain, [0.0-1.0]."
        ],
        "link": "[More...](https://chuck.stanford.edu/doc/reference/ugens-stk.html#Clarinet)"
    },
    "ConsoleInput": {
        "title": "**Console Input Utility**",
        "description": "(Terminal only) a utility for prompting user input on the command line.",
        "constructors": [
            "**Constructors:**",
            "```chuck\nConsoleInput()\n```\nDefault constructor for ConsoleInput."
        ],
        "examples": [
            "Examples: \t [readline.ck](https://chuck.stanford.edu/doc/examples/string/readline.ck), [word2vec-prompt.ck](https://chuck.stanford.edu/doc/examples/ai/word2vec/word2vec-prompt.ck), [poem-ungenerate.ck](https://chuck.stanford.edu/doc/examples/ai/word2vec/poem-ungenerate.ck)"
        ],
        "functions": [
            "**Methods:**",
            "```chuck\nint can_wait()\n```\n(internal) used by virtual machine for synthronization.",
            "```chuck\nstring getLine()\n```\nReturn the next line of input as a string.",
            "```chuck\nint more()\n```\nReturn whether there is more input to read.",
            "```chuck\nEvent prompt()\n```\nReturn an Event to wait on.",
            "```chuck\nEvent prompt(string what)\n```\nPrint a prompt text and return an Event to wait on."
        ],
        "link": "[More...](https://chuck.stanford.edu/doc/reference/utils.html#ConsoleInput)"
    },
    "CurveTable": {
        "title": "**Curve Table**",
        "description": "Constructs a wavetable composed of segments of variable times, values, and curvatures. Coefficients are specified as a single linear array of triplets of [ time, value, curvature ] followed by a final duple of [ time, value ] to specify the final value of the table. time values are expressed in unitless, ascending values. For curvature equal to 0, the segment is a line; for curvature less than 0, the segment is a convex curve; for curvature greater than 0, the segment is a concave curve.",
        "constructors": [
            "**Constructors:**",
            "```chuck\nCurveTable()\n```\nDefault constructor for CurveTable."
        ],
        "examples": [
            "Examples: \t [GenX-CurveTable-test.ck](https://chuck.stanford.edu/doc/examples/special/GenX-CurveTable-test.ck)"
        ],
        "functions": [
            "**Methods:**",
            "```chuck\nfloat[] coefs(float[] v)\n```\nSet lookup table coefficients."
        ],
        "link": "[More...](https://chuck.stanford.edu/doc/reference/ugens-advanced.html#CurveTable)"
    },
    "DCT": {
        "title": "**Discrete Cosine Transform**",
        "description": "Computes the Discrete Cosine Transform on incoming audio samples, and outputs the result via its UAnaBlob as real values in the D.C. spectrum. A buffering mechanism maintains the previous DCT size # of samples, allowing DCT to be taken at any point in time, on demand (via .upchuck() or by upchucking a downstream UAna; see UAna documentation). The window size (along with an arbitrary window shape) is controlled via the .window method. The hop size is complete dynamic, and is throttled by how time is advanced.",
        "constructors": [
            "**Constructors:**",
            "```chuck\nDCT()\n```\nDefault constructor for DCT."
        ],
        "examples": [
            "Examples: \t [dct.ck](https://chuck.stanford.edu/doc/examples/analysis/dct.ck)"
        ],
        "functions": [
            "**Methods:**",
            "```chuck\nint size(int size)\n```\nSet the DCT size.",
            "```chuck\nint size()\n```\nGet the DCT size.",
            "```chuck\nvoid spectrum(float[] buffer)\n```\nManually retrieve the results of a transform.",
            "```chuck\nvoid transform(float[] from)\n```\nManually take DCT (as opposed to using .upchuck() / upchuck operator).",
            "```chuck\nfloat[] window(float[] win)\n```\nSet/get the transform window/size.",
            "```chuck\nint windowSize()\n```\nGet the current window size."
        ],
        "link": "[More...](https://chuck.stanford.edu/doc/reference/uanae.html#DCT)"
    },
    "Delay": {
        "title": "**Digital Delay Line**",
        "description": "A non-interpolating digital delay-line. A fixed maximum length of 4095 and a delay of zero is set using the default constructor. Alternatively, the delay and maximum length can be set during instantiation with an overloaded constructor. A non-interpolating delay line is typically used in fixed delay-length applications, such as for reverberation. by Perry R. Cook and Gary P. Scavone, 1995 - 2002.",
        "constructors": [
            "**Constructors:**",
            "```chuck\nDelay()\n```\nDefault constructor for Delay.",
            "```chuck\nDelay(dur delay)\n```\nConstruct a Delay with delay length and, implicitly, delay max.",
            "```chuck\nDelay(dur delay, dur max)\n```\nConstruct a Delay with delay length and delay max."
        ],
        "examples": [
            "Examples: \t [comb.ck](https://chuck.stanford.edu/doc/examples/basic/comb.ck), [plu.ck](https://chuck.stanford.edu/doc/examples/deep/plu.ck)"
        ],
        "functions": [
            "**Methods:**",
            "```chuck\nvoid clear()\n```\nClear delay line.",
            "```chuck\ndur delay(dur value)\n```\nSet length of delay.",
            "```chuck\ndur delay()\n```\nGet length of delay.",
            "```chuck\ndur max(dur value)\n```\nSet max delay (buffer size).",
            "```chuck\ndur max()\n```\nGet max delay (buffer size).",
            "```chuck\nvoid set(dur delay, dur max)\n```\nSet delay length and delay max; delay should be <= max."
        ],
        "link": "[More...](https://chuck.stanford.edu/doc/reference/ugens-basic.html#Delay)"
    },
    "DelayA": {
        "title": "**All-Pass Interpolating Delay Line**",
        "description": "A fractional-length digital delay-line using a first-order allpass filter. A fixed maximum length of 4095 and a delay of 0.5 is set using the default constructor. Alternatively, the delay and maximum length can be set during instantiation with an overloaded constructor. An allpass filter has unity magnitude gain but variable phase delay properties, making it useful in achieving fractional delays without affecting a signal's frequency magnitude response. In order to achieve a maximally flat phase delay response, the minimum delay possible in this implementation is limited to a value of 0.5. by Perry R. Cook and Gary P. Scavone, 1995 - 2002.",
        "constructors": [
            "**Constructors:**",
            "```chuck\nDelayA()\n```\nDefault constructor for DelayA.",
            "```chuck\nDelayA(dur delay)\n```\nConstruct a DelayA with delay length and, implicitly, delay max.",
            "```chuck\nDelayA(dur delay, dur max)\n```\nConstruct a DelayA with delay length and delay max."
        ],
        "examples": [
            "Examples: \t [ks-chord.ck](https://chuck.stanford.edu/doc/examples/deep/ks-chord.ck)"
        ],
        "functions": [
            "**Methods:**",
            "```chuck\nvoid clear()\n```\nClear delay line.",
            "```chuck\ndur delay(dur value)\n```\nSet length of delay.",
            "```chuck\ndur delay()\n```\nGet length of delay.",
            "```chuck\ndur max(dur value)\n```\nSet max delay (buffer size).",
            "```chuck\ndur max()\n```\nGet max delay (buffer size).",
            "```chuck\nvoid set(dur delay, dur max)\n```\nSet delay length and delay max; delay should be <= max."
        ],
        "link": "[More...](https://chuck.stanford.edu/doc/reference/ugens-basic.html#DelayA)"
    },
    "DelayL": {
        "title": "**Linear Interpolating Delay Line**",
        "description": "A fractional-length digital delay-line using first-order linear interpolation. A fixed maximum length of 4095 and a delay of zero is set using the default constructor. Alternatively, the delay and maximum length can be set during instantiation with an overloaded constructor. Linear interpolation is an efficient technique for achieving fractional delay lengths, though it does introduce high-frequency signal attenuation to varying degrees depending on the fractional delay setting. The use of higher order Lagrange interpolators can typically improve (minimize) this attenuation characteristic. by Perry R. Cook and Gary P. Scavone, 1995 - 2002.",
        "constructors": [
            "**Constructors:**",
            "```chuck\nDelayL()\n```\nDefault constructor for DelayL.",
            "```chuck\nDelayL(dur delay)\n```\nConstruct a DelayL with delay length and, implicitly, delay max.",
            "```chuck\nDelayL(dur delay, dur max)\n```\nConstruct a DelayL with delay length and delay max."
        ],
        "examples": [
            "Examples: \t [delay.ck](https://chuck.stanford.edu/doc/examples/basic/delay.ck), [delay2.ck](https://chuck.stanford.edu/doc/examples/basic/delay2.ck), [i-robot.ck](https://chuck.stanford.edu/doc/examples/basic/i-robot.ck), [we-robot.ck](https://chuck.stanford.edu/doc/examples/multi/we-robot.ck), [xcorr.ck](https://chuck.stanford.edu/doc/examples/analysis/xcorr.ck), [poem-i-feel.ck](https://chuck.stanford.edu/doc/examples/ai/word2vec/poem-i-feel.ck)"
        ],
        "functions": [
            "**Methods:**",
            "```chuck\nvoid clear()\n```\nClear delay line.",
            "```chuck\ndur delay(dur value)\n```\nSet length of delay.",
            "```chuck\ndur delay()\n```\nGet length of delay.",
            "```chuck\ndur max(dur value)\n```\nSet max delay (buffer size).",
            "```chuck\ndur max()\n```\nGet max delay (buffer size).",
            "```chuck\nvoid set(dur delay, dur max)\n```\nSet delay length and delay max; delay should be <= max."
        ],
        "link": "[More...](https://chuck.stanford.edu/doc/reference/ugens-basic.html#DelayL)"
    },
    "Dyno": {
        "title": "**Dynamics Processor**",
        "description": "A dynamics processor. Includes presets for limiter, compressor, expander, noise gate, and ducker.",
        "constructors": [
            "**Constructors:**",
            "```chuck\nDyno()\n```\nDefault constructor for Dyno."
        ],
        "examples": [
            "Examples: \t [Dyno-compress.ck](https://chuck.stanford.edu/doc/examples/special/Dyno-compress.ck), [Dyno-duck.ck](https://chuck.stanford.edu/doc/examples/special/Dyno-duck.ck), [Dyno-limit.ck](https://chuck.stanford.edu/doc/examples/special/Dyno-limit.ck)"
        ],
        "functions": [
            "**Methods:**",
            "```chuck\ndur attackTime(dur aTime)\n```\nSet duration for the envelope to move linearly from current value to the absolute value of the signal's amplitude.",
            "```chuck\ndur attackTime()\n```\nGet duration for the envelope to move linearly from current value to the absolute value of the signal's amplitude.",
            "```chuck\nvoid compress()\n```\nSet parameters to default compressor values: slopeAbove = 0.5, slopeBelow = 1.0, thresh = 0.5, attackTime = 5 ms, releaseTime = 500 ms, externalSideInput = 0 (false)",
            "```chuck\nvoid duck()\n```\nSet parameters to default ducker values: slopeAbove = 0.5, slopeBelow = 1.0, thresh = 0.5, attackTime = 10 ms, releaseTime = 1000 ms, externalSideInput = 1 (true)",
            "```chuck\nvoid expand()\n```\nSet parameters to default expander values: slopeAbove = 2.0, slopeBelow = 1.0, thresh = 0.5, attackTime = 20 ms, releaseTime = 400 ms, externalSideInput = 0 (false)",
            "```chuck\nint externalSideInput(int externalSideInput)\n```\nSet to true to cue the amplitude envelope off sideInput instead of the input signal. Note that this means you will need to manually set sideInput every so often.",
            "```chuck\nint externalSideInput()\n```\nGet externalSideInput state. If set to true, the amplitude envelope will be cued off sideInput instead of the input signal. Note that this means you will need to manually set sideInput every so often.",
            "```chuck\nvoid gate()\n```\nSet parameters to default noise gate values: slopeAbove = 1.0, slopeBelow = 1.0E08, thresh = 0.1, attackTime = 11 ms, releaseTime = 100 ms, externalSideInput = 0 (false)",
            "```chuck\nvoid limit()\n```\nSet parameters to default limiter values: slopeAbove = 0.1, slopeBelow = 1.0, thresh = 0.5, attackTime = 5 ms, releaseTime = 300 ms, externalSideInput = 0 (false)",
            "```chuck\nfloat ratio(float ratio)\n```\nAn alternate way of setting slopeAbove and slopeBelow; sets slopeBelow to 1.0 and slopeAbove to 1.0 / ratio.",
            "```chuck\nfloat ratio()\n```\nGet the ratio set by .ratio(float); slopeBelow to 1.0 and slopeAbove to 1.0 / ratio.",
            "```chuck\ndur releaseTime(dur rTime)\n```\nSet duration for the envelope to decay down to around 1/10 of its current amplitude, if not brought back up by the signal.",
            "```chuck\ndur releaseTime()\n```\nGet duration for the envelope to decay down to around 1/10 of its current amplitude, if not brought back up by the signal.",
            "```chuck\nfloat sideInput(float sideInput)\n```\nIf externalSideInput is set to true, replace the signal being processed as the input to the amplitude envelope.",
            "```chuck\nfloat sideInput()\n```\nIf externalSideInput is set to true, replaces the signal being processed as the input to the amplitude envelope.",
            "```chuck\nfloat slopeAbove(float slopeAbove)\n```\nSet the slope of the output gain vs the input envelope's level when the envelope is above thresh.",
            "```chuck\nfloat slopeAbove()\n```\nGet the slope of the output gain vs the input envelope's level when the envelope is above thresh.",
            "```chuck\nfloat slopeBelow(float slopeBelow)\n```\nSet the slope of the output gain vs the input envelope's level when the envelope is below thresh.",
            "```chuck\nfloat slopeBelow()\n```\nGet the slope of the output gain vs the input envelope's level when the envelope is below thresh.",
            "```chuck\nfloat thresh(float thresh)\n```\nSet threshold, above which to stop using slopeBelow and start using slopeAbove to determine output gain vs input gain.",
            "```chuck\nfloat thresh()\n```\nGet threshold, above which to stop using slopeBelow and start using slopeAbove to determine output gain vs input gain."
        ],
        "link": "[More...](https://chuck.stanford.edu/doc/reference/ugens-advanced.html#Dyno)"
    },
    "Echo": {
        "title": "**Echo Effect**",
        "description": "An echo effect. by Perry R. Cook and Gary P. Scavone, 1995 - 2002.",
        "constructors": [
            "**Constructors:**",
            "```chuck\nEcho()\n```\nDefault constructor for Echo.",
            "```chuck\nEcho(dur delay)\n```\nConstruct an Echo with delay length and, implicitly, delay max.",
            "```chuck\nEcho(dur delay, dur max)\n```\nConstruct an Echo with delay length and delay max."
        ],
        "examples": [
            "Examples: \t [echo.ck](https://chuck.stanford.edu/doc/examples/basic/echo.ck), [rhodey.ck](https://chuck.stanford.edu/doc/examples/stk/rhodey.ck), [wurley2.ck](https://chuck.stanford.edu/doc/examples/stk/wurley2.ck)"
        ],
        "functions": [
            "**Methods:**",
            "```chuck\ndur delay(dur value)\n```\nSet length of echo.",
            "```chuck\ndur delay()\n```\nGet length of echo.",
            "```chuck\ndur max(dur value)\n```\nSet max delay (buffer size).",
            "```chuck\ndur max()\n```\nGet max delay (buffer size).",
            "```chuck\nfloat mix(float value)\n```\nSet mix level (wet/dry).",
            "```chuck\nfloat mix()\n```\nGet mix level (wet/dry).",
            "```chuck\nvoid set(dur delay, dur max)\n```\nSet delay length and delay max; delay should be <= max."
        ],
        "link": "[More...](https://chuck.stanford.edu/doc/reference/ugens-basic.html#Echo)"
    },
    "Elliptic": {
        "title": "**Elliptic Filter**",
        "description": "Elliptic implements cascaded IIR filters and a built-in elliptical filter design. It is capable of low-pass, high-pass, or bandpass filtering with very steep slopes. The atten determines how much of the signal is attenuated outside the passband. Elliptic filters come with a trade-off for their steep slopes: they have a certain amount of ripple outside the passbands. A very small ripple (0.1 or 0.2 dB) produces very little ringing, whereas a large ripple (eg. 20 dB) produces a very strong harmonic ring. The filter design algorithm sometimes can't fulfill the design criteria -- a particular combination of cutoff frequencies, ripple, and attenuation. If that happens, the user is warned that the filter is not initialized, and the filter is bypassed. This may happen, for instance, if you ask for a very steep attenuation with very low ripple.",
        "constructors": [
            "**Constructors:**",
            "```chuck\nElliptic()\n```\n"
        ],
        "examples": [
            "Examples: \t [Elliptic-help.ck](https://chuck.stanford.edu/doc/examples/filter/Elliptic-help.ck)"
        ],
        "functions": [
            "**Methods:**",
            "```chuck\nfloat atten(float arg)\n```\nSet filter attenuation in dB. Default 90.0.",
            "```chuck\nfloat atten()\n```\nGet filter attenuation in dB.",
            "```chuck\nvoid bpf(float stop, float hip, float lop)\n```\nCreate a band-pass filter.",
            "```chuck\nint bypass(int arg)\n```\nSet switch bypass. 1 is on, 0 is off. Default 0.",
            "```chuck\nint bypass()\n```\nGet switch bypass. 1 is on, 0 is off.",
            "```chuck\nvoid hpf(float stop, float pass)\n```\nCreate a high-pass filter.",
            "```chuck\nvoid lpf(float stop, float pass)\n```\nCreate a low-pass filter.",
            "```chuck\nfloat ripple(float arg)\n```\nSet filter ripple in dB. Default 0.2.",
            "```chuck\nfloat ripple()\n```\nGet filter ripple in dB."
        ],
        "link": "[More...](https://chuck.stanford.edu/doc/reference/chugins.html#Elliptic)"
    },
    "Envelope": {
        "title": "**Envelope Generator**",
        "description": "This class implements a simple envelope generator which is capable of ramping to a target value by a specified rate. It also responds to simple `keyOn` and `keyOff` messages, ramping to 1.0 on `keyOn` and to 0.0 on `keyOff`. by Perry R. Cook and Gary P. Scavone, 1995 - 2002.",
        "constructors": [
            "**Constructors:**",
            "```chuck\nEnvelope()\n```\nDefault constructor for Envelope.",
            "```chuck\nEnvelope(dur durationToTarget)\n```\nConstruct an Envelope with duration to reach target (assumed to be 1.0); FYI this does not start the Envelope until .keyOn() is called.",
            "```chuck\nEnvelope(float secondsToTarget)\n```\nConstruct an Envelope with duration (in seconds) to reach target (assumed to be 1.0); FYI this does not start the Envelope until .keyOn() is called.",
            "```chuck\nEnvelope(dur durationToTarget, float target)\n```\nConstruct an Envelope with duration to reach target; FYI this does not start the Envelope until .keyOn() is called.",
            "```chuck\nEnvelope(float secondsToTarget, float target)\n```\nConstruct an Envelope with duration (in seconds) to reach target; FYI this does not start the Envelope until .keyOn() is called."
        ],
        "examples": [
            "Examples: \t [envelope.ck](https://chuck.stanford.edu/doc/examples/basic/envelope.ck), [envelope2.ck](https://chuck.stanford.edu/doc/examples/basic/envelope2.ck), [chirp2.ck](https://chuck.stanford.edu/doc/examples/basic/chirp2.ck), [say-chu.ck](https://chuck.stanford.edu/doc/examples/deep/say-chu.ck)"
        ],
        "functions": [
            "**Methods:**",
            "```chuck\ndur duration(dur value)\n```\nSet duration to reach target.",
            "```chuck\ndur duration()\n```\nGet duration to reach target.",
            "```chuck\nint keyOff()\n```\nGet keyOff state.",
            "```chuck\nint keyOff(int value)\n```\nRamp to 0.0.",
            "```chuck\nint keyOn()\n```\nGet keyOn state.",
            "```chuck\nint keyOn(int value)\n```\nRamp to 1.0.",
            "```chuck\ndur ramp(dur durationToTarget, float target)\n```\nOver the given duration, ramp toward the specified target; returns the given duration.",
            "```chuck\ndur ramp(float secondsToTarget, float target)\n```\nOver the given duration (in seconds), ramp toward the specified target; returns the given duration.",
            "```chuck\nfloat rate(float value)\n```\nSet rate of change.",
            "```chuck\nfloat rate()\n```\nGet rate of change.",
            "```chuck\nfloat target(float value)\n```\nSet value to ramp to.",
            "```chuck\nfloat target()\n```\nGet value to ramp to.",
            "```chuck\nfloat time(float value)\n```\nSet time to reach target (in seconds).",
            "```chuck\nfloat time()\n```\nGet time to reach target (in seconds).",
            "```chuck\nfloat value(float value)\n```\nSet immediate value.",
            "```chuck\nfloat value()\n```\nGet immediate value."
        ],
        "link": "[More...](https://chuck.stanford.edu/doc/reference/ugens-basic.html#Envelope)"
    },
    "Event": {
        "title": "**ChucK Event Class**",
        "description": "A mechanism for precise synchronization across shreds.",
        "constructors": [
            "**Constructors:**",
            "```chuck\nEvent()\n```\nDefault constructor for Event."
        ],
        "examples": [
            "Examples: \t [broadcast.ck](https://chuck.stanford.edu/doc/examples/event/broadcast.ck), [signal.ck](https://chuck.stanford.edu/doc/examples/event/signal.ck), [signal4.ck](https://chuck.stanford.edu/doc/examples/event/signal4.ck), [event-extend.ck](https://chuck.stanford.edu/doc/examples/event/event-extend.ck), [event-extend2.ck](https://chuck.stanford.edu/doc/examples/event/event-extend2.ck), [event-x-bpm-1.ck](https://chuck.stanford.edu/doc/examples/event/event-x-bpm-1.ck), [event-x-bpm-2.ck](https://chuck.stanford.edu/doc/examples/event/event-x-bpm-2.ck)"
        ],
        "functions": [
            "**Methods:**",
            "```chuck\nvoid broadcast()\n```\nSignal all shreds that are waiting on this event.",
            "```chuck\nint can_wait()\n```\nCan the event can be waited on? (internal) used by virtual machine for synchronization.",
            "```chuck\nvoid signal()\n```\nSignal one shred that is waiting on this event.",
            "```chuck\nvoid waiting_on()\n```\n(internal) used by virtual machine to be notified when a shred starts waiting on this Event."
        ],
        "link": "[More...](https://chuck.stanford.edu/doc/reference/base.html#Event)"
    },
    "ExpDelay": {
        "title": "**Exponential Delay**",
        "description": "Feedback delay at exponentially changing delay times.",
        "constructors": [
            "**Constructors:**",
            "```chuck\nExpDelay()\n```\n"
        ],
        "examples": [
            "Examples: \t [ExpDelay.ck](https://chuck.stanford.edu/doc/examples/effects/ExpDelay.ck)"
        ],
        "functions": [
            "**Methods:**",
            "```chuck\nfloat ampcurve(float ampcurve)\n```\nSet steepness of amplitude decay [0.0001-inf].",
            "```chuck\nfloat ampcurve()\n```\nGet steepness of amplitude decay [0.0001-inf].",
            "```chuck\ndur delay(dur delay)\n```\nSet duration of delay.",
            "```chuck\ndur delay()\n```\nGet duration of delay.",
            "```chuck\nfloat durcurve(float durcurve)\n```\nSet steepness of delay curve [0.0001-inf]:    1 = steady    <1 = starts fast and slows down    >1 = starts slow and speeds up.",
            "```chuck\nfloat durcurve()\n```\nGet steepness of delay curve [0.0001-inf].",
            "```chuck\ndur max(dur max)\n```\nSet maximum possible delay duration.",
            "```chuck\ndur max()\n```\nGet maximum possible delay duration.",
            "```chuck\nfloat mix(float mix)\n```\nSet dry/wet mix [0-1].",
            "```chuck\nfloat mix()\n```\nGet dry/wet mix [0-1].",
            "```chuck\nint reps(int reps)\n```\nSet number of repetitions.",
            "```chuck\nint reps()\n```\nGet number of repetitions."
        ],
        "link": "[More...](https://chuck.stanford.edu/doc/reference/chugins.html#ExpDelay)"
    },
    "ExpEnv": {
        "title": "**Exponential Envelope**",
        "description": "ChucK Simple Decaying Exponential Envelope UGen Simple single time constant exponential decay, applied to any signal passed through it. Obeys: value, T60, radius, and keyOn Especially useful for Modal synthesis. One of these for each mode: SinOsc s => ExpEnv e => dac; Also useful for noise excitation pulse, using it like: Noise n => ExpEnv e => dac;.",
        "constructors": [
            "**Constructors:**",
            "```chuck\nExpEnv()\n```\n"
        ],
        "examples": [
            "Examples: \t [ExpEnv.ck](https://chuck.stanford.edu/doc/examples/effects/ExpEnv.ck), [ExpEnv-modes.ck](https://chuck.stanford.edu/doc/examples/effects/ExpEnv-modes.ck)"
        ],
        "functions": [
            "**Methods:**",
            "```chuck\ndur T60(dur arg)\n```\nSet T60 delay time (time for sounds to decay by 60dB.",
            "```chuck\ndur T60()\n```\nGet T60 delay time (time for sounds to decay by 60dB.",
            "```chuck\nint keyOn(int arg)\n```\n",
            "```chuck\nfloat radius(float arg)\n```\n",
            "```chuck\nfloat radius()\n```\n",
            "```chuck\nfloat value(float arg)\n```\n",
            "```chuck\nfloat value()\n```\n"
        ],
        "link": "[More...](https://chuck.stanford.edu/doc/reference/chugins.html#ExpEnv)"
    },
    "FFT": {
        "title": "**Fast Fourier Transform**",
        "description": "Computes the Fast Fourier Transform on incoming audio samples, and outputs the result via its UAnaBlob as both the complex spectrum and the magnitude spectrum. A buffering mechanism maintains the previous FFTsize # of samples, allowing FFT's to be taken at any point in time, on demand (via .upchuck() or by upchucking a downstream UAna. The window size (along with an arbitrary window shape) is controlled via the .window method. The hop size is complete dynamic, and is throttled by how time is advanced.",
        "constructors": [
            "**Constructors:**",
            "```chuck\nFFT()\n```\nDefault constructor for FFT."
        ],
        "examples": [
            "Examples: \t [fft.ck](https://chuck.stanford.edu/doc/examples/analysis/fft.ck), [fft2.ck](https://chuck.stanford.edu/doc/examples/analysis/fft2.ck), [fft3.ck](https://chuck.stanford.edu/doc/examples/analysis/fft3.ck), [ifft.ck](https://chuck.stanford.edu/doc/examples/analysis/ifft.ck), [feature-extract.ck](https://chuck.stanford.edu/doc/examples/ai/genre-classify/feature-extract.ck), [genre-classify.ck](https://chuck.stanford.edu/doc/examples/ai/genre-classify/genre-classify.ck)"
        ],
        "functions": [
            "**Methods:**",
            "```chuck\nint size(int size)\n```\nSet the FFT-size.",
            "```chuck\nint size()\n```\nGet the FFT-size.",
            "```chuck\nvoid spectrum(complex[] buffer)\n```\nManually retrieve the results of a transform.",
            "```chuck\nvoid transform(float[] from)\n```\nManually take FFT (as opposed to using .upchuck() / upchuck operator)",
            "```chuck\nfloat[] window(float[] win)\n```\nSet/get the transform window/size.",
            "```chuck\nint windowSize()\n```\nGet the current window size."
        ],
        "link": "[More...](https://chuck.stanford.edu/doc/reference/uanae.html#FFT)"
    },
    "FIR": {
        "title": "**Finite Impulse Response Filter**",
        "description": "Yo! This here is a ChugIn for ChucK. It's a general-purpose FIR filter. You make a new one: FIR myFilter; Then specify order: N => myFilter.order;.",
        "constructors": [
            "**Constructors:**",
            "```chuck\nFIR()\n```\n"
        ],
        "examples": [
            "Examples: \t [FIR-convolve-homer.ck](https://chuck.stanford.edu/doc/examples/filter/FIR-convolve-homer.ck), [FIR-greyhole-down-up-decimate.ck](https://chuck.stanford.edu/doc/examples/filter/FIR-greyhole-down-up-decimate.ck), [FIR-sinc-explicit.ck](https://chuck.stanford.edu/doc/examples/filter/FIR-sinc-explicit.ck)"
        ],
        "functions": [
            "**Methods:**",
            "```chuck\nint bpHetero(float freq)\n```\nCosine modulate lowpass filter to freq.",
            "```chuck\nfloat coeff(int idx, float coeff)\n```\nSet filter idx's coefficient to coeff.",
            "```chuck\nfloat coeff(int idx)\n```\nSet filter idx's coefficient.",
            "```chuck\nint gaussian(float cutoff_freq)\n```\nCreate a gaussian lowpass filter with cutoff cutoff_freq.",
            "```chuck\nint hpHetero()\n```\nCosine modulate lowpass filter to 1/2 the sample rate.",
            "```chuck\nint order(int arg)\n```\nSet filter's order.",
            "```chuck\nint order()\n```\nGet filter's order.",
            "```chuck\nint sinc(float cutoff_freq)\n```\nCreate a sinc lowpass filter with cutoff cutoff_freq."
        ],
        "link": "[More...](https://chuck.stanford.edu/doc/reference/chugins.html#FIR)"
    },
    "FM": {
        "title": "**STK FM Synthesis**",
        "description": "STK FM synthesis super class. You should NOT need to use this UGen directly. Please refer to the documentation on FM subclasses instead. This class controls an arbitrary number of waves and envelopes, determined via a constructor argument. Control Change Numbers: - Control One = 2 - Control Two = 4 - LFO Speed = 11 - LFO Depth = 1 - ADSR 2 & 4 Target = 128 The basic Chowning/Stanford FM patent expired in 1995, but there exist follow-on patents, mostly assigned to Yamaha. If you are of the type who should worry about this (making money) worry away. by Perry R. Cook and Gary P. Scavone, 1995 - 2002.",
        "constructors": [
            "**Constructors:**",
            "```chuck\nFM()\n```\nDefault constructor for FM."
        ],
        "examples": [],
        "functions": [
            "**Methods:**",
            "```chuck\nfloat afterTouch(float value)\n```\nSet aftertouch, [0.0-1.0].",
            "```chuck\nfloat afterTouch()\n```\nGet aftertouch, [0.0-1.0].",
            "```chuck\nfloat controlOne(float value)\n```\nSet control one [instrument specific].",
            "```chuck\nfloat controlOne()\n```\nGet control one [instrument specific].",
            "```chuck\nfloat controlTwo(float value)\n```\nSet control two [instrument specific].",
            "```chuck\nfloat controlTwo()\n```\nGet control two [instrument specific].",
            "```chuck\nfloat getFMTableGain(int index)\n```\nGet table gain lookup.",
            "```chuck\nfloat getFMTableSusLevel(int index)\n```\nGet sustain level lookup.",
            "```chuck\nfloat getFMTableTime(int index)\n```\nGet table time lookup.",
            "```chuck\nfloat lfoDepth(float value)\n```\nSet modulation depth, [0.0-1.0].",
            "```chuck\nfloat lfoDepth()\n```\nGet modulation depth, [0.0-1.0].",
            "```chuck\nfloat lfoSpeed(float value)\n```\nSet modulation speed (Hz).",
            "```chuck\nfloat lfoSpeed()\n```\nGet modulation speed (Hz).",
            "```chuck\nfloat op4Feedback(float value)\n```\nSet operator 4 feedback.",
            "```chuck\nfloat op4Feedback()\n```\nGet operator 4 feedback.",
            "```chuck\nfloat opADSR(int opNum, float attack, float decay, float sustain, float release)\n```\nSet operator ADSR: attack (sec), decay (sec), sustain [0.0-1.0], release (sec).",
            "```chuck\nfloat opAM(int opNum, float value)\n```\nSet operator amplitude modulation.",
            "```chuck\nfloat opAM(int opNum)\n```\nGet operator amplitude modulation.",
            "```chuck\nfloat opGain(int opNum, float value)\n```\nSet operator gain.",
            "```chuck\nfloat opGain(int opNum)\n```\nGet gperator gain.",
            "```chuck\nfloat opRatio(int opNum, float ratio)\n```\nSet operator frequency ratio.",
            "```chuck\nfloat opRatio(int opNum)\n```\nGet operator frequency ratio.",
            "```chuck\nfloat opWave(int opNum, int wave)\n```\nSet operator waveform [1-8]."
        ],
        "link": "[More...](https://chuck.stanford.edu/doc/reference/ugens-stk.html#FM)"
    },
    "FMVoices": {
        "title": "**STK FM Voices**",
        "description": "STK singing FM synthesis instrument. This class implements 3 carriers and a common modulator, also referred to as algorithm 6 of the TX81Z. Algorithm 6 is :     ___//->1 -\\   4-||-->2 - +-> Out   ___\\->3 -//   Control Change Numbers: - Vowel = 2 (.controlOne) - Spectral Tilt = 4 (.controlTwo) - LFO Speed = 11 - LFO Depth = 1 - ADSR 2 & 4 Target = 128 The basic Chowning/Stanford FM patent expired in 1995, but there exist follow-on patents, mostly assigned to Yamaha. If you are of the type who should worry about this (making money) worry away. by Perry R. Cook and Gary P. Scavone, 1995 - 2002.",
        "constructors": [
            "**Constructors:**",
            "```chuck\nFMVoices()\n```\nDefault constructor for FMVoices."
        ],
        "examples": [],
        "functions": [
            "**Methods:**",
            "```chuck\nfloat adsrTarget(float value)\n```\nSet ADSR targets, [0.0-1.0].",
            "```chuck\nfloat adsrTarget()\n```\nGet ADSR targets, [0.0-1.0].",
            "```chuck\nfloat spectralTilt(float value)\n```\nSet spectral tilt, [0.0-1.0].",
            "```chuck\nfloat spectralTilt()\n```\nGet spectral tilt, [0.0-1.0].",
            "```chuck\nfloat vowel(float value)\n```\nSet vowel, [0.0-1.0].",
            "```chuck\nfloat vowel()\n```\nGet vowel, [0.0-1.0]."
        ],
        "link": "[More...](https://chuck.stanford.edu/doc/reference/ugens-stk.html#FMVoices)"
    },
    "FeatureCollector": {
        "title": "**UAna Feature Collector**",
        "description": "Turns UAna input into a single feature vector, upon .upchuck()",
        "constructors": [
            "**Constructors:**",
            "```chuck\nFeatureCollector()\n```\nDefault constructor for FeatureCollector."
        ],
        "examples": [
            "Examples: \t [feature-extract.ck](https://chuck.stanford.edu/doc/examples/ai/genre-classify/feature-extract.ck), [genre-classify.ck](https://chuck.stanford.edu/doc/examples/ai/genre-classify/genre-classify.ck), [concat.ck](https://chuck.stanford.edu/doc/examples/analysis/concat.ck)"
        ],
        "functions": [],
        "link": "[More...](https://chuck.stanford.edu/doc/reference/uanae.html#FeatureCollector)"
    },
    "FileIO": {
        "title": "**File Input and Output**",
        "description": "File input and output utilities for reading, writing, seeking, etc. See examples for usage.",
        "constructors": [
            "**Constructors:**",
            "```chuck\nFileIO()\n```\nDefault constructor for FileIO."
        ],
        "examples": [
            "Examples: \t [chout.ck](https://chuck.stanford.edu/doc/examples/io/chout.ck), [read-float.ck](https://chuck.stanford.edu/doc/examples/io/read-float.ck), [read-int.ck](https://chuck.stanford.edu/doc/examples/io/read-int.ck), [read-line.ck](https://chuck.stanford.edu/doc/examples/io/read-line.ck), [read-str.ck](https://chuck.stanford.edu/doc/examples/io/read-str.ck), [read-tokens.ck](https://chuck.stanford.edu/doc/examples/io/read-tokens.ck), [seek.ck](https://chuck.stanford.edu/doc/examples/io/seek.ck), [write.ck](https://chuck.stanford.edu/doc/examples/io/write.ck), [write2.ck](https://chuck.stanford.edu/doc/examples/io/write2.ck), [write-auto.ck](https://chuck.stanford.edu/doc/examples/io/write-auto.ck), [read-byte.ck](https://chuck.stanford.edu/doc/examples/io/read-byte.ck), [write-byte.ck](https://chuck.stanford.edu/doc/examples/io/write-byte.ck)"
        ],
        "functions": [
            "**Methods:**",
            "```chuck\nstring autoExtension()\n```\nGet auto extension for \"special:auto\" filename generation (applicable to file writing only).",
            "```chuck\nstring autoPrefix()\n```\nGet auto prefix for \"special:auto\" filename generation (applicable to file writing only).",
            "```chuck\nvoid autoPrefixExtension(string prefix, string extension)\n```\nSet auto prefix and extension for \"special:auto\" filename generation (applicable to file writing only).",
            "```chuck\nvoid close()\n```\nClose (and flush) the currently open file.",
            "```chuck\nstring[] dirList()\n```\nGet an array of file names in an open directory.",
            "```chuck\nint eof()\n```\nReturn whether end-of-file has been reached; the opposite of .more().",
            "```chuck\nstring filename()\n```\nGet current filename.",
            "```chuck\nvoid flush()\n```\nWrite any buffered output to file.",
            "```chuck\nint good()\n```\nReturns whether the file is ready for reading.",
            "```chuck\nint isDir()\n```\nReturn if the open file is a directory.",
            "```chuck\nint mode(int flag)\n```\nSet file IO mode (IO.MODE_SYNC or IO.MODE_ASYNC).",
            "```chuck\nint mode()\n```\nGet file IO mode (IO.MODE_SYNC or IO.MODE_ASYNC).",
            "```chuck\nint more()\n```\nReturn whether there is more to read; the opposite of .eof().",
            "```chuck\nint open(string path)\n```\nOpen a file by name (and by default in ASCII mode).",
            "```chuck\nint open(string path, int flags)\n```\nOpen a file by name with flags (bitwise combinations of IO.READ, IO.WRITE, IO.READ_WRITE, IO_APPEND, IO.ASCII, IO.BINARY).",
            "```chuck\nfloat readFloat()\n```\nRead and return the next floating point value.",
            "```chuck\nfloat readFloat(int flags)\n```\nRead and return the next floating point value; if binary mode: 'flags' denotes the size of float to read (IO.FLOAT32 or IO.FLOAT64).",
            "```chuck\nint readInt(int flags)\n```\nRead and return an integer; binary mode: 'flags' specifies int size to read (IO.INT8, IO.INT16, IO.INT32 default to unsigned values; for signed integers use IO.SINT8, IO.SINT16, IO.SINT32).",
            "```chuck\nstring readLine()\n```\nRead and return the next line from file.",
            "```chuck\nvoid seek(int pos)\n```\nSeek to a specified byte offset in file.",
            "```chuck\nint size()\n```\nReturn the size of the file in bytes, or -1 if no file is opened or if a directory is opened.",
            "```chuck\nint tell()\n```\nReturn the byte read offset of the file, or -1 if no file is opened.",
            "```chuck\nvoid write(string val)\n```\nWrite a string to file.",
            "```chuck\nvoid write(int val)\n```\nWrite an integer to file.",
            "```chuck\nvoid write(int val, int flags)\n```\nWrite integer value to file; binary mode: int size specified by 'flags' (IO.INT8, IO.INT16, IO.INT32).",
            "```chuck\nvoid write(float val)\n```\nWrite floating point value to file.",
            "```chuck\nvoid write(float val, int flags)\n```\nWrite floating point value to file; binary mode: flags indicate float size (IO.FLOAT32 or IO.FLOAT64).",
            "```chuck\nstring expandPath(string path)\n```\nExpand platform-specific filepath to an absolute path, which is returned. On macOS and Linux expandPath() will attempt to resolve `~` or `~[username]`; on Windows expandPath() will attempt to resolve %USERNAME%. (Known issue: (macOS) expandPath currently introduced an audio click; it recommended to call expandPath() at the beginning; e.g., expanding path ahead of time could avoid a click instead of calling Machine.add() on a filepath with `~`.)"
        ],
        "link": "[More...](https://chuck.stanford.edu/doc/reference/io.html#FileIO)"
    },
    "FilterBasic": {
        "title": "**Filter Base Class**",
        "description": "Base class for basic filters with a notion of center/cutoff frequency and Q.",
        "constructors": [
            "**Constructors:**",
            "```chuck\nFilterBasic()\n```\nDefault constructor for FilterBasic."
        ],
        "examples": [],
        "functions": [
            "**Methods:**",
            "```chuck\nfloat Q(float val)\n```\nSet filter resonance.",
            "```chuck\nfloat Q()\n```\nGet filter resonance.",
            "```chuck\nfloat freq(float val)\n```\nSet filter cutoff/center frequency.",
            "```chuck\nfloat freq()\n```\nGet filter cutoff/center frequency.",
            "```chuck\nvoid set(float freq, float Q)\n```\nSet filter frequency and resonance at the same time."
        ],
        "link": "[More...](https://chuck.stanford.edu/doc/reference/ugens-filters.html#FilterBasic)"
    },
    "FilterStk": {
        "title": "**STK Filter Base Class**",
        "description": "FilterStk is an STK Filter base class inherited by all Stk Filter UGens such as BiQuad, TwoZero, PoleZero, etc. You should NOT need to use this UGen directly. Please refer to the documentation on other filter types instead.",
        "constructors": [
            "**Constructors:**",
            "```chuck\nFilterStk()\n```\nDefault constructor for FilterStk."
        ],
        "examples": [],
        "functions": [
            "**Methods:**",
            "```chuck\nstring coefs(string value)\n```\n"
        ],
        "link": "[More...](https://chuck.stanford.edu/doc/reference/ugens-stk.html#FilterStk)"
    },
    "Flip": {
        "title": "**Signal Flip**",
        "description": "Turn N (size) audio samples into a Unit Analyzer audio analysis frame.",
        "constructors": [
            "**Constructors:**",
            "```chuck\nFlip()\n```\nDefault constructor for Flip."
        ],
        "examples": [
            "Examples: \t [flip.ck](https://chuck.stanford.edu/doc/examples/analysis/flip.ck), [autocorr.ck](https://chuck.stanford.edu/doc/examples/analysis/autocorr.ck), [zerox.ck](https://chuck.stanford.edu/doc/examples/ai/features/zerox.ck)"
        ],
        "functions": [
            "**Methods:**",
            "```chuck\nvoid output(float[] buffer)\n```\nManually take Flip (as opposed to using .upchuck() / upchuck operator)",
            "```chuck\nint size(int size)\n```\nSet the Flip size.",
            "```chuck\nint size()\n```\nGet the Flip size.",
            "```chuck\nvoid transform(float[] from)\n```\nManually take Flip (as opposed to using .upchuck() / upchuck operator).",
            "```chuck\nfloat[] window(float[] win)\n```\nSet/get the transform window/size.",
            "```chuck\nint windowSize()\n```\nGet the current window size."
        ],
        "link": "[More...](https://chuck.stanford.edu/doc/reference/uanae.html#Flip)"
    },
    "Flute": {
        "title": "**STK Flute**",
        "description": "This class implements a simple flute physical model, as discussed by Karjalainen, Smith, Waryznyk, etc. The jet model uses a polynomial, a la Cook. This is a digital waveguide model, making its use possibly subject to patents held by Stanford University, Yamaha, and others. Control Change Numbers: - Jet Delay = 2 - Noise Gain = 4 - Vibrato Frequency = 11 - Vibrato Gain = 1 - Breath Pressure = 128 by Perry R. Cook and Gary P. Scavone, 1995 - 2002.",
        "constructors": [
            "**Constructors:**",
            "```chuck\nFlute()\n```\nDefault constructor for Flute."
        ],
        "examples": [
            "Examples: \t [flute.ck](https://chuck.stanford.edu/doc/examples/stk/flute.ck)"
        ],
        "functions": [
            "**Methods:**",
            "```chuck\nfloat clear(float value)\n```\nClear instrument.",
            "```chuck\nfloat endReflection(float value)\n```\nSet end reflection.",
            "```chuck\nfloat endReflection()\n```\nGet end reflection.",
            "```chuck\nfloat jetDelay(float value)\n```\nSet jet delay.",
            "```chuck\nfloat jetDelay()\n```\nGet jet delay.",
            "```chuck\nfloat jetReflection(float value)\n```\nSet jet reflection.",
            "```chuck\nfloat jetReflection()\n```\nGet jet reflection.",
            "```chuck\nfloat noiseGain(float value)\n```\nSet noise component gain, [0.0-1.0].",
            "```chuck\nfloat noiseGain()\n```\nGet noise component gain, [0.0-1.0].",
            "```chuck\nfloat pressure(float value)\n```\nSet pressure, [0.0-1.0].",
            "```chuck\nfloat pressure()\n```\nGet pressure, [0.0-1.0].",
            "```chuck\nfloat rate(float value)\n```\nSet rate of attack (seconds).",
            "```chuck\nfloat rate()\n```\nGet rate of attack (seconds).",
            "```chuck\nfloat startBlowing(float value)\n```\nStart blowing, [0.0-1.0].",
            "```chuck\nfloat stopBlowing(float value)\n```\nStop blowing, [0.0-1.0].",
            "```chuck\nfloat vibratoFreq(float value)\n```\nSet vibrato frequency (Hz).",
            "```chuck\nfloat vibratoFreq()\n```\nGet vibrato frequency (Hz).",
            "```chuck\nfloat vibratoGain(float value)\n```\nSet vibrato gain, [0.0-1.0].",
            "```chuck\nfloat vibratoGain()\n```\nGet vibrato gain, [0.0-1.0]."
        ],
        "link": "[More...](https://chuck.stanford.edu/doc/reference/ugens-stk.html#Flute)"
    },
    "Flux": {
        "title": "**Spectral Flux Analyzer**",
        "description": "A unit analyzer that computes the spectral flux between successive magnitude spectra (via incoming UAna, or given manually), and outputs a single number.",
        "constructors": [
            "**Constructors:**",
            "```chuck\nFlux()\n```\nDefault constructor for Flux."
        ],
        "examples": [
            "Examples: \t [flux.ck](https://chuck.stanford.edu/doc/examples/ai/features/flux.ck), [flux0.ck](https://chuck.stanford.edu/doc/examples/ai/features/flux0.ck)"
        ],
        "functions": [
            "**Methods:**",
            "```chuck\nvoid reset()\n```\nReset the extractor.",
            "```chuck\nfloat compute(float[] lhs, float[] rhs)\n```\nManually computes the flux between two frames.",
            "```chuck\nfloat compute(float[] lhs, float[] rhs, float[] diff)\n```\nManually computes the flux between two frames, and stores the difference in a third array."
        ],
        "link": "[More...](https://chuck.stanford.edu/doc/reference/uanae.html#Flux)"
    },
    "FoldbackSaturator": {
        "title": "**Foldback Saturator**",
        "description": "Foldback saturator that inverts a signal and multiplies it by an index as it passes a threshold.",
        "constructors": [
            "**Constructors:**",
            "```chuck\nFoldbackSaturator()\n```\n"
        ],
        "examples": [
            "Examples: \t [FoldbackSaturator-index.ck](https://chuck.stanford.edu/doc/examples/effects/FoldbackSaturator-index.ck), [FoldbackSaturator-threshold.ck](https://chuck.stanford.edu/doc/examples/effects/FoldbackSaturator-threshold.ck)"
        ],
        "functions": [
            "**Methods:**",
            "```chuck\nfloat index(float arg)\n```\nThe index that the signal is multiplied by after it is inverted against the threshold. Defaults to 2.0.",
            "```chuck\nfloat index()\n```\nThe index that the signal is multiplied by after it is inverted against the threshold. Defaults to 2.0.",
            "```chuck\nfloat makeupGain(float arg)\n```\nThe amount of makeup gain applied to the signal after processing, multiplied against the reciprocal of the threshold. Defaults to 1.0.",
            "```chuck\nfloat makeupGain()\n```\nThe amount of makeup gain applied to the signal after processing, multiplied against the reciprocal of the threshold. Defaults to 1.0.",
            "```chuck\nfloat threshold(float arg)\n```\nThe threshold (positive and negative) that the signal is inverted against as it is passed. Defaults to 0.6.",
            "```chuck\nfloat threshold()\n```\nThe threshold (positive and negative) that the signal is inverted against as it is passed. Defaults to 0.6."
        ],
        "link": "[More...](https://chuck.stanford.edu/doc/reference/chugins.html#FoldbackSaturator)"
    },
    "FrencHrn": {
        "title": "**STK French Horn**",
        "description": "STK-style French Horn FM synthesis instrument. This class implements 3 cascade operators and a 4th modulator with feedback modulation, also referred to as algorithm 2 of the TX81Z. Algorithm 2 is :     ____4--\\   3--+-->>2-->1-->Out   Control Change Numbers: - Total Modulator Index = 2 (.controlOne) - Modulator Crossfade = 4 (.controlTwo) - LFO Speed = 11 - LFO Depth = 1 - ADSR 2 & 4 Target = 128 The basic Chowning/Stanford FM patent expired in 1995, but there exist follow-on patents, mostly assigned to Yamaha. If you are of the type who should worry about this (making money) worry away. by Perry R. Cook and Gary P. Scavone, 1995 - 2002.",
        "constructors": [
            "**Constructors:**",
            "```chuck\nFrencHrn()\n```\nDefault constructor for FrencHrn."
        ],
        "examples": [
            "Examples: \t [frenchrn-algo2.ck](https://chuck.stanford.edu/doc/examples/stk/frenchrn-algo2.ck)"
        ],
        "functions": [],
        "link": "[More...](https://chuck.stanford.edu/doc/reference/ugens-stk.html#FrencHrn)"
    },
    "FullRect": {
        "title": "**Full Wave Rectifier**",
        "description": "A full wave rectifier.",
        "constructors": [],
        "examples": [],
        "functions": [],
        "link": "[More...](https://chuck.stanford.edu/doc/reference/ugens-basic.html#FullRect)"
    },
    "GVerb": {
        "title": "**GVerb Reverb**",
        "description": "GVerb is a very smooth reverberator with the ability to produce very long reverb times. GVERB is based on the original \"gverb/gigaverb\" by Juhana Sadeharju (kouhia at nic.funet.fi). The code for this version was adapted from RTcmix (http:rtcmix.org), which in turn adapted it from the Max/MSP version by Olaf Mtthes (olaf.matthes at gmx.de).",
        "constructors": [
            "**Constructors:**",
            "```chuck\nGVerb()\n```\n"
        ],
        "examples": [
            "Examples: \t [GVerb.ck](https://chuck.stanford.edu/doc/examples/effects/GVerb.ck)"
        ],
        "functions": [
            "**Methods:**",
            "```chuck\nfloat bandwidth()\n```\nGet the input bandwidth [0 - 1]. Same as damping control, but on the input signal. Default 0.5.",
            "```chuck\nfloat bandwidth(float arg)\n```\nSet the input bandwidth [0 - 1]. Same as damping control, but on the input signal. Default 0.5.",
            "```chuck\nfloat damping()\n```\nGet high frequency rolloff [0 - 1]. 0 damps the reverb signal completely, 1 not at all. Default 0.",
            "```chuck\nfloat damping(float arg)\n```\nSet high frequency rolloff [0 - 1]. 0 damps the reverb signal completely, 1 not at all. Default 0.",
            "```chuck\nfloat dry()\n```\nGet the amount of dry signal [0 - 1]. Default 0.5.",
            "```chuck\nfloat dry(float arg)\n```\nSet the amount of dry signal [0 - 1]. Default 0.5.",
            "```chuck\nfloat early()\n```\nGet the early reflection level [0 - 1]. Default 0.4.",
            "```chuck\nfloat early(float arg)\n```\nSet the early reflection level [0 - 1]. Default 0.4.",
            "```chuck\ndur revtime(dur arg)\n```\nSet reverberation time. Default 5::second.",
            "```chuck\ndur revtime()\n```\nGet reverberation time.",
            "```chuck\nfloat roomsize(float arg)\n```\nSet room size [1.0 - 300.0]. Default 30.0.",
            "```chuck\nfloat roomsize()\n```\nGet room size [1.0 - 300.0].",
            "```chuck\nfloat tail()\n```\nGet the tail level [0 - 1]. Default 0.5.",
            "```chuck\nfloat tail(float arg)\n```\nSet the tail level [0 - 1]. Default 0.5."
        ],
        "link": "[More...](https://chuck.stanford.edu/doc/reference/chugins.html#GVerb)"
    },
    "Gain": {
        "title": "**Gain**",
        "description": "A gain control unit generator. (All unit generators can already change their own gain; this is an explicit way to add multiple outputs together and scale them.)",
        "constructors": [
            "**Constructors:**",
            "```chuck\nGain()\n```\nDefault constructor for Gain.",
            "```chuck\nGain(float gain)\n```\nConstruct a Gain with default value."
        ],
        "examples": [
            "Examples: \t [i-robot.ck](https://chuck.stanford.edu/doc/examples/basic/i-robot.ck)"
        ],
        "functions": [
            "**Methods:**",
            "```chuck\nint buffered(int val)\n```\nSet the unit generator's buffered operation mode, typically used externally from hosts that embed ChucK as a component. If true, the UGen stores a buffer of its most recent samples, which can be fetched using global variables in the host language.",
            "```chuck\nint buffered()\n```\nGet the ugen's buffered operation mode.",
            "```chuck\nUGen chan(int num)\n```\nGet channel (as a UGen) at specified index.",
            "```chuck\nint channels(int num)\n```\nSet number of channels. (currently NOT supported)",
            "```chuck\nint channels()\n```\nGet number of channels.",
            "```chuck\nfloat gain(float val)\n```\nSet the gain of the unit generator.",
            "```chuck\nfloat gain()\n```\nGet the gain of the unit generator.",
            "```chuck\nint isConnectedTo(UGen rhs)\n```\nReturn true if this UGen's output is connected to the input of rhs; if either this UGen or rhs has more than one channel, this function returns true if any connections exist between the channels; return false if there are no connections.",
            "```chuck\nfloat last()\n```\nGet the last sample value of the unit generator.",
            "```chuck\nint op(int val)\n```\nSet the unit generator's operation mode. Accepted values are: 1 (sum inputs), 2 (take difference between first input and subsequent inputs), 3 (multiply inputs), 4 (divide first input by subsequent inputs), 0 (do not synthesize audio, output 0) or -1 (passthrough inputs to output).",
            "```chuck\nint op()\n```\nGet the unit generator's operation mode."
        ],
        "link": "[More...](https://chuck.stanford.edu/doc/reference/ugens-basic.html#Gain)"
    },
    "Gen10": {
        "title": "**Makegen Sinusoidal Lookup Table**",
        "description": "Constructs a lookup table of harmonic partials with specified amplitudes. The amplitude of partial n is specified by the nth element of the coefficients. For example, setting coefs to [ 1 ] will produce a sine wave.",
        "constructors": [
            "**Constructors:**",
            "```chuck\nGen10()\n```\nDefault constructor for Gen10."
        ],
        "examples": [
            "Examples: \t [Gen10-test.ck](https://chuck.stanford.edu/doc/examples/special/Gen10-test.ck)"
        ],
        "functions": [
            "**Methods:**",
            "```chuck\nfloat[] coefs(float[] v)\n```\nSet lookup table coefficients."
        ],
        "link": "[More...](https://chuck.stanford.edu/doc/reference/ugens-advanced.html#Gen10)"
    },
    "Gen17": {
        "title": "**Makegen Chebyshev Polynomial Lookup Table**",
        "description": "Constructs a Chebyshev polynomial wavetable with harmonic partials of specified weights. The weight of partial n is specified by the nth element of the coefficients. Primarily used for waveshaping, driven by a SinOsc instead of a Phasor. See <a href=\"http://crca.ucsd.edu/~msp/techniques/v0.08/book-html/node74.html\">http://crca.ucsd.edu/~msp/techniques/v0.08/book-html/node74.html</a> and <a href=\"http://en.wikipedia.org/wiki/Distortion_synthesis\">http://en.wikipedia.org/wiki/Distortion_synthesis</a> for more information.",
        "constructors": [
            "**Constructors:**",
            "```chuck\nGen17()\n```\nDefault constructor for Gen17."
        ],
        "examples": [
            "Examples: \t [Gen17-test.ck](https://chuck.stanford.edu/doc/examples/special/Gen17-test.ck)"
        ],
        "functions": [
            "**Methods:**",
            "```chuck\nfloat[] coefs(float[] v)\n```\nSet lookup table coefficients."
        ],
        "link": "[More...](https://chuck.stanford.edu/doc/reference/ugens-advanced.html#Gen17)"
    },
    "Gen5": {
        "title": "**Makegen Exponential Line Segment Table**",
        "description": "Constructs a lookup table composed of sequential exponential curves. For a table with N curves, starting value of y', and value yn for lookup index xn, set the coefficients to [ y', y0, x0, ..., yN-1, xN-1 ]. Note that there must be an odd number of coefficients. If an even number of coefficients is specified, behavior is undefined. The sum of xn for 0 &le; n < N must be 1. yn = 0 is approximated as 0.000001 to avoid strange results arising from the nature of exponential curves.",
        "constructors": [
            "**Constructors:**",
            "```chuck\nGen5()\n```\nDefault constructor for Gen5."
        ],
        "examples": [
            "Examples: \t [Gen5-test.ck](https://chuck.stanford.edu/doc/examples/special/Gen5-test.ck)"
        ],
        "functions": [
            "**Methods:**",
            "```chuck\nfloat[] coefs(float[] v)\n```\nSet lookup table coefficients."
        ],
        "link": "[More...](https://chuck.stanford.edu/doc/reference/ugens-advanced.html#Gen5)"
    },
    "Gen7": {
        "title": "**Makegen Line Segment Table**",
        "description": "Constructs a lookup table composed of sequential line segments. For a table with N lines, starting value of y', and value yn for lookupindex xn, set the coefficients to [ y', y0, x0, ..., yN-1, xN-1 ]. Note that there must be an odd number of coefficients. If an even number of coefficients is specified, behavior is undefined. The sum of xn for 0 &le; n < N must be 1.",
        "constructors": [
            "**Constructors:**",
            "```chuck\nGen7()\n```\nDefault constructor for Gen7."
        ],
        "examples": [
            "Examples: \t [Gen7-test.ck](https://chuck.stanford.edu/doc/examples/special/Gen7-test.ck)"
        ],
        "functions": [
            "**Methods:**",
            "```chuck\nfloat[] coefs(float[] v)\n```\nSet lookup table coefficients."
        ],
        "link": "[More...](https://chuck.stanford.edu/doc/reference/ugens-advanced.html#Gen7)"
    },
    "Gen9": {
        "title": "**Makegen Inharmonic Sinusoidal Lookup Table**",
        "description": "Constructs a lookup table of partials with specified amplitudes, phases, and harmonic ratios to the fundamental. Coefficients are specified in triplets of [ ratio, amplitude, phase ] arranged in a single linear array.",
        "constructors": [
            "**Constructors:**",
            "```chuck\nGen9()\n```\nDefault constructor for Gen9."
        ],
        "examples": [
            "Examples: \t [Gen9-test.ck](https://chuck.stanford.edu/doc/examples/special/Gen9-test.ck)"
        ],
        "functions": [
            "**Methods:**",
            "```chuck\nfloat[] coefs(float[] v)\n```\nSet lookup table coefficients."
        ],
        "link": "[More...](https://chuck.stanford.edu/doc/reference/ugens-advanced.html#Gen9)"
    },
    "GenX": {
        "title": "**Makegen Lookup Table**",
        "description": "Ported from rtcmix. See <a href=\"https://web.archive.org/web/20160628032324/http://www.music.columbia.edu/cmix/makegens.html\">  makegens documentation</a>   for more information on the GenX family of UGens. Currently coefficients past   the 100th are ignored.    Lookup can either be done using the lookup() function, or by driving the   table with an input UGen, typically a Phasor. For an input signal between   [ -1, 1 ], using the absolute value for [ -1, 0 ), GenX will output the   table value indexed by the current input.",
        "constructors": [
            "**Constructors:**",
            "```chuck\nGenX()\n```\nDefault constructor for GenX."
        ],
        "examples": [
            "Examples: \t [readme-GenX.ck](https://chuck.stanford.edu/doc/examples/special/readme-GenX.ck)"
        ],
        "functions": [
            "**Methods:**",
            "```chuck\nfloat[] coefs(float[] v)\n```\nSet lookup table coefficients; meaning is dependent on subclass.",
            "```chuck\nfloat lookup(float which)\n```\nGet lookup table value at index i [ -1, 1 ]; absolute value is used in the range [ -1, 0 )"
        ],
        "link": "[More...](https://chuck.stanford.edu/doc/reference/ugens-advanced.html#GenX)"
    },
    "HMM": {
        "title": "**Hidden Markov Model**",
        "description": "A hidden markov model (HMM) utility that generates a sequence of observations based on the training data.",
        "constructors": [
            "**Constructors:**",
            "```chuck\nHMM()\n```\nDefault constructor for HMM."
        ],
        "examples": [
            "Examples: \t [hmm-load.ck](https://chuck.stanford.edu/doc/examples/ai/hmm/hmm-load.ck), [hmm-train.ck](https://chuck.stanford.edu/doc/examples/ai/hmm/hmm-train.ck)"
        ],
        "functions": [
            "**Methods:**",
            "```chuck\nint generate(int length, int[] output)\n```\nGenerate a sequence of observations of the given length.",
            "```chuck\nint load(float[] initiailDistribution, float[][] transitionMatrix, float[][] emissionMatrix)\n```\nInitialize the HMM model with the given initial state distribution, transition matrix, and emission matrix.",
            "```chuck\nint train(int numStates, int numEmissions, int[] observations)\n```\nTrain the HMM model with the given observations."
        ],
        "link": "[More...](https://chuck.stanford.edu/doc/reference/ai.html#HMM)"
    },
    "HPF": {
        "title": "**High-Pass Filter**",
        "description": "A resonant high-pass filter (2nd order Butterworth).",
        "constructors": [
            "**Constructors:**",
            "```chuck\nHPF()\n```\nDefault constructor for HPF."
        ],
        "examples": [
            "Examples: \t [hpf.ck](https://chuck.stanford.edu/doc/examples/filter/hpf.ck), [rhpf.ck](https://chuck.stanford.edu/doc/examples/filter/rhpf.ck)"
        ],
        "functions": [
            "**Methods:**",
            "```chuck\nfloat Q(float val)\n```\nSet filter resonance.",
            "```chuck\nfloat Q()\n```\nGet filter resonance.",
            "```chuck\nfloat freq(float val)\n```\nSet filter cutoff frequency.",
            "```chuck\nfloat freq()\n```\nGet filter cutoff frequency.",
            "```chuck\nvoid set(float freq, float Q)\n```\nSet filter frequency and resonance at the same time."
        ],
        "link": "[More...](https://chuck.stanford.edu/doc/reference/ugens-filters.html#HPF)"
    },
    "HalfRect": {
        "title": "**Half Wave Rectifier**",
        "description": "A half wave rectifier.",
        "constructors": [],
        "examples": [],
        "functions": [],
        "link": "[More...](https://chuck.stanford.edu/doc/reference/ugens-basic.html#HalfRect)"
    },
    "HevyMetl": {
        "title": "**STK Heavy Metal**",
        "description": "A STK heavy metal FM synthesis instrument. This class implements 3 cascade operators with feedback modulation, also referred to as algorithm 3 of the TX81Z. Algorithm 3 is :     ____4--\\   3-->2-- + -->1-->Out   Control Change Numbers: - Total Modulator Index = 2 (.controlOne) - Modulator Crossfade = 4 (.controlTwo) - LFO Speed = 11 - LFO Depth = 1 - ADSR 2 & 4 Target = 128 The basic Chowning/Stanford FM patent expired in 1995, but there exist follow-on patents, mostly assigned to Yamaha. If you are of the type who should worry about this (making money) worry away. by Perry R. Cook and Gary P. Scavone, 1995 - 2002.",
        "constructors": [
            "**Constructors:**",
            "```chuck\nHevyMetl()\n```\nDefault constructor for HevyMetl."
        ],
        "examples": [
            "Examples: \t [hevymetl-algo3.ck](https://chuck.stanford.edu/doc/examples/stk/hevymetl-algo3.ck), [hevymetl-dance-now.ck](https://chuck.stanford.edu/doc/examples/stk/hevymetl-dance-now.ck), [hevymetl-trumpet-algo3.ck](https://chuck.stanford.edu/doc/examples/stk/hevymetl-trumpet-algo3.ck)"
        ],
        "functions": [],
        "link": "[More...](https://chuck.stanford.edu/doc/reference/ugens-stk.html#HevyMetl)"
    },
    "Hid": {
        "title": "**Human-Interface Device (HID)**",
        "description": "Class for interacting with human-interface devices (HIDs) such as keyboards, mice, gamepads, joysticks, etc.",
        "constructors": [
            "**Constructors:**",
            "```chuck\nHid()\n```\nDefault constructor for Hid."
        ],
        "examples": [
            "Examples: \t [kb.ck](https://chuck.stanford.edu/doc/examples/hid/kb.ck), [keyboard-organ.ck](https://chuck.stanford.edu/doc/examples/hid/keyboard-organ.ck), [mouse.ck](https://chuck.stanford.edu/doc/examples/hid/mouse.ck), [mouse-abs.ck](https://chuck.stanford.edu/doc/examples/hid/mouse-abs.ck), [mouse-fm.ck](https://chuck.stanford.edu/doc/examples/hid/mouse-fm.ck), [joy.ck](https://chuck.stanford.edu/doc/examples/hid/joy.ck), [joy-fm.ck](https://chuck.stanford.edu/doc/examples/hid/joy-fm.ck), [joy-noise.ck](https://chuck.stanford.edu/doc/examples/hid/joy-noise.ck), [joy-shake.ck](https://chuck.stanford.edu/doc/examples/hid/joy-shake.ck)"
        ],
        "functions": [
            "**Methods:**",
            "```chuck\nint can_wait()\n```\n(internal) used by virtual machine for synthronization.",
            "```chuck\nint good()\n```\nGet whether a device has been successfully opened on this HID instance.",
            "```chuck\nstring name()\n```\nGet the name of the currently open device; return empty string (\"\") if no device is open on this HID instance.",
            "```chuck\nint num()\n```\nGet the number of the currently open device; returns -1 if no device is open on this HID instance.",
            "```chuck\nint open(int type, int num)\n```\nOpen a HID device by device number ('num') and type ('type'). See static member variables for possible types.",
            "```chuck\nint open(string name)\n```\nOpen a HID device by name.",
            "```chuck\nint openJoystick(int num)\n```\nOpen a joystick/gamepad by device number.",
            "```chuck\nint openJoystick(int num, int suppressErrMsg)\n```\nOpen a joystick/gamepad by device number, with option (true/false) to suppress error messages.",
            "```chuck\nint openKeyboard(int num)\n```\nOpen a keyboard by device number.",
            "```chuck\nint openKeyboard(int num, int suppressErrMsg)\n```\nOpen a keyboard by device number, with option (true/false) to suppress error messages.",
            "```chuck\nint openMouse(int num)\n```\nOpen a mouse/trackpad by device number.",
            "```chuck\nint openMouse(int num, int suppressErrMsg)\n```\nOpen a mouse/trackpad by device number, with option (true/false) to suppress error messages.",
            "```chuck\nint openTiltSensor()\n```\nOpen a tilt-sensor by device number.",
            "```chuck\nvoid printerr(int toPrintOrNot)\n```\nSet whether to print errors (default is YES).",
            "```chuck\nint read(int type, int which, HidMsg msg)\n```\nRead the next HidMsg from device of type 'type' with device id 'which'.",
            "```chuck\nint recv(HidMsg msg)\n```\nReceive the next available HidMsg.",
            "```chuck\nint send(HidMsg msg)\n```\nSend a HidMsg to device; return whether the operation was successful.",
            "```chuck\ndur globalTiltPollRate(dur d)\n```\nSet tilt-sensor poll rate.",
            "```chuck\ndur globalTiltPollRate()\n```\nGet tilt-sensor poll rate.",
            "```chuck\nint[] readTiltSensor()\n```\nRead tilt-sensor and return as an int array.",
            "```chuck\nint startCursorTrack()\n```\nStart cursor tracking; return whether the request was successful.",
            "```chuck\nint stopCursorTrack()\n```\nStop cursor tracking; return whether the request was successful."
        ],
        "link": "[More...](https://chuck.stanford.edu/doc/reference/io.html#Hid)"
    },
    "HidMsg": {
        "title": "**Human-Interface Device (HID) Message**",
        "description": "Helper class for receiving HID information; e.g., which key was pressed, joystick position, etc.",
        "constructors": [
            "**Constructors:**",
            "```chuck\nHidMsg()\n```\nDefault constructor for HidMsg."
        ],
        "examples": [
            "Examples: \t [kb.ck](https://chuck.stanford.edu/doc/examples/hid/kb.ck), [keyboard-organ.ck](https://chuck.stanford.edu/doc/examples/hid/keyboard-organ.ck), [mouse.ck](https://chuck.stanford.edu/doc/examples/hid/mouse.ck), [mouse-abs.ck](https://chuck.stanford.edu/doc/examples/hid/mouse-abs.ck), [mouse-fm.ck](https://chuck.stanford.edu/doc/examples/hid/mouse-fm.ck), [joy.ck](https://chuck.stanford.edu/doc/examples/hid/joy.ck), [joy-fm.ck](https://chuck.stanford.edu/doc/examples/hid/joy-fm.ck), [joy-noise.ck](https://chuck.stanford.edu/doc/examples/hid/joy-noise.ck), [joy-shake.ck](https://chuck.stanford.edu/doc/examples/hid/joy-shake.ck)"
        ],
        "functions": [
            "**Methods:**",
            "```chuck\nint isAxisMotion()\n```\nReturn whether this message is an axis-motion event.",
            "```chuck\nint isButtonDown()\n```\nReturn whether this message is a button-down event.",
            "```chuck\nint isButtonUp()\n```\nReturn whether this message is a button-up event.",
            "```chuck\nint isHatMotion()\n```\nReturn whether this message is a hat-motion event.",
            "```chuck\nint isMouseMotion()\n```\nReturn whether this message is a mouse-motion event.",
            "```chuck\nint isWheelMotion()\n```\nReturn whether this message is a wheel-motion event.",
            "```chuck\nint is_axis_motion()\n```\n(Deprecated; use .isAxisMotion() instead).",
            "```chuck\nint is_button_down()\n```\n(Deprecated; use .isButtonDown() instead).",
            "```chuck\nint is_button_up()\n```\n(Deprecated; use .isButtonUp() instead).",
            "```chuck\nint is_hat_motion()\n```\n(Deprecated; use .isHatMotion() instead).",
            "```chuck\nint is_mouse_motion()\n```\n(Deprecated; use .isMouseMotion() instead)."
        ],
        "link": "[More...](https://chuck.stanford.edu/doc/reference/io.html#HidMsg)"
    },
    "HnkyTonk": {
        "title": "**STK Honky Tonk Piano**",
        "description": "STK-style Honkey Tonk Piano FM synthesis instrument. This class implements 4 cascade operators with feedback modulation, also referred to as algorithm 1 of the TX81Z. Algorithm 1 is :     ____4-->3-->2-->1-->Out   Control Change Numbers: - Total Modulator Index = 2 (.controlOne) - Modulator Crossfade = 4 (.controlTwo) - LFO Speed = 11 - LFO Depth = 1 - ADSR 2 & 4 Target = 128 The basic Chowning/Stanford FM patent expired in 1995, but there exist follow-on patents, mostly assigned to Yamaha. If you are of the type who should worry about this (making money) worry away. by Perry R. Cook and Gary P. Scavone, 1995 - 2002.",
        "constructors": [
            "**Constructors:**",
            "```chuck\nHnkyTonk()\n```\nDefault constructor for HnkyTonk."
        ],
        "examples": [
            "Examples: \t [honkeytonk-algo1.ck](https://chuck.stanford.edu/doc/examples/stk/honkeytonk-algo1.ck), [honkeytonk-algo3.ck](https://chuck.stanford.edu/doc/examples/stk/honkeytonk-algo3.ck)"
        ],
        "functions": [],
        "link": "[More...](https://chuck.stanford.edu/doc/reference/ugens-stk.html#HnkyTonk)"
    },
    "IDCT": {
        "title": "**Inverse Discrete Cosine Transform**",
        "description": "Computes the inverse Discrete Cosine Transform on incoming spectral frames (on demand), and overlap-adds the results into its internal buffer, ready to be sent to other UGen's connected via =>. The window size (along with an arbitrary window shape) is controlled via the .window method.",
        "constructors": [
            "**Constructors:**",
            "```chuck\nIDCT()\n```\nDefault constructor for IDCT."
        ],
        "examples": [],
        "functions": [
            "**Methods:**",
            "```chuck\nvoid samples(float[] buffer)\n```\nManually get result of previous IDCT.",
            "```chuck\nint size(int size)\n```\nSet the IDCT size.",
            "```chuck\nint size()\n```\nGet the IDCT size.",
            "```chuck\nvoid transform(complex[] from)\n```\nManually take IDCT (as opposed to using .upchuck() / upchuck operator).",
            "```chuck\nfloat[] window(float[] win)\n```\nSet/get the transform window/size.",
            "```chuck\nint windowSize()\n```\nGet the current window size."
        ],
        "link": "[More...](https://chuck.stanford.edu/doc/reference/uanae.html#IDCT)"
    },
    "IFFT": {
        "title": "**Inverse Fast Fourier Transform**",
        "description": "Computes the inverse Fast Fourier Transform on incoming spectral frames (on demand), and overlap-adds the results into its internal buffer, ready to be sent to other UGen's connected via =>. The window size (along with an arbitrary window shape) is controlled via the .window method.",
        "constructors": [
            "**Constructors:**",
            "```chuck\nIFFT()\n```\nDefault constructor for IFFT."
        ],
        "examples": [
            "Examples: \t [ifft.ck](https://chuck.stanford.edu/doc/examples/analysis/ifft.ck), [ifft2.ck](https://chuck.stanford.edu/doc/examples/analysis/ifft2.ck), [ifft3.ck](https://chuck.stanford.edu/doc/examples/analysis/ifft3.ck)"
        ],
        "functions": [
            "**Methods:**",
            "```chuck\nvoid samples(float[] buffer)\n```\nManually take IFFT (as opposed to using .upchuck() / upchuck operator)",
            "```chuck\nint size(int size)\n```\nSet the IFFT-size.",
            "```chuck\nint size()\n```\nGet the IFFT-size.",
            "```chuck\nvoid transform(complex[] from)\n```\nManually take IFFT (as opposed to using .upchuck() / upchuck operator)",
            "```chuck\nfloat[] window(float[] win)\n```\nSet/get the transform window/size.",
            "```chuck\nint windowSize()\n```\nGet the current window size."
        ],
        "link": "[More...](https://chuck.stanford.edu/doc/reference/uanae.html#IFFT)"
    },
    "IO": {
        "title": "**Input/Output Base Class**",
        "description": "Base class for other IO classes such as FileIO, StdOut and StdErr. Besides IO.newline(), its unlikely you need to use this class directly.",
        "constructors": [
            "**Constructors:**",
            "```chuck\nIO()\n```\nDefault constructor for IO."
        ],
        "examples": [],
        "functions": [
            "**Methods:**",
            "```chuck\nvoid close()\n```\nClose the currently open IO.",
            "```chuck\nint eof()\n```\nReturn whether end-of-file has been reached; the opposite of .more().",
            "```chuck\nvoid flush()\n```\nWrite any buffered output.",
            "```chuck\nint good()\n```\nReturns whether IO is ready for reading.",
            "```chuck\nint mode(int flag)\n```\nSet the current IO mode; either IO.MODE_ASYNC or IO.MODE_SYNC.",
            "```chuck\nint mode()\n```\nGet the current IO mode; either IO.MODE_ASYNC or IO.MODE_SYNC.",
            "```chuck\nint more()\n```\nReturn whether there is more to read; the opposite of .eof().",
            "```chuck\nfloat readFloat(int flags)\n```\nRead and return the next floating point value; binary mode: 'flags' denotes the size of float to read (IO.FLOAT32 or IO.FLOAT64).",
            "```chuck\nint readInt(int flags)\n```\nRead and return the next integer; binary mode: 'flags' denotes the bit-size of int (IO.INT8, IO.INT16, or IO.INT32).",
            "```chuck\nstring readLine()\n```\nRead until an end-of-line character.",
            "```chuck\nvoid write(string val)\n```\nWrite string 'val'.",
            "```chuck\nvoid write(int val)\n```\nWrite integer 'val'.",
            "```chuck\nvoid write(float val)\n```\nWrite floating point number 'val'.",
            "```chuck\nstring newline()\n```\nNewline character; same as IO.nl().",
            "```chuck\nstring nl()\n```\nNewline character; same as IO.newline()."
        ],
        "link": "[More...](https://chuck.stanford.edu/doc/reference/io.html#IO)"
    },
    "Impulse": {
        "title": "**Impulse Generator**",
        "description": "An impulse generator. Can be used to set the value of the next sample; default for each sample is 0 if not set. Additionally, this can be used to generate a digital signal, one sample at a time.",
        "constructors": [
            "**Constructors:**",
            "```chuck\nImpulse()\n```\nDefault constructor for Impulse."
        ],
        "examples": [
            "Examples: \t [imp.ck](https://chuck.stanford.edu/doc/examples/basic/imp.ck), [comb.ck](https://chuck.stanford.edu/doc/examples/basic/comb.ck), [chant.ck](https://chuck.stanford.edu/doc/examples/deep/chant.ck)"
        ],
        "functions": [
            "**Methods:**",
            "```chuck\nfloat next(float next)\n```\nSet the value of next sample. (Note: if you are using the UGen.last() method to read the output of the impulse, the value set by Impulse.next() does not appear as the output until after the next sample boundary. In this case, there is a consistent 1::samp offset between setting .next(...) and reading that value using .last().)",
            "```chuck\nfloat next()\n```\nGet value of next sample to be generated."
        ],
        "link": "[More...](https://chuck.stanford.edu/doc/reference/ugens-basic.html#Impulse)"
    },
    "JCRev": {
        "title": "**John Chowning's Reverberator**",
        "description": "John Chowning's reverberator class. This class is derived from the CLM NRev function, which is based on the use of networks of simple allpass and comb delay filters. This particular arrangement consists of 6 comb filters in parallel, followed by 3 allpass filters, a lowpass filter, and another allpass in series, followed by two allpass filters in parallel with corresponding right and left outputs. by Perry R. Cook and Gary P. Scavone, 1995 - 2002.",
        "constructors": [
            "**Constructors:**",
            "```chuck\nJCRev()\n```\nDefault constructor for JCRev."
        ],
        "examples": [
            "Examples: \t [reverb.ck](https://chuck.stanford.edu/doc/examples/effects/reverb.ck), [otf_06.ck](https://chuck.stanford.edu/doc/examples/otf_06.ck), [otf_07.ck](https://chuck.stanford.edu/doc/examples/otf_07.ck)"
        ],
        "functions": [
            "**Methods:**",
            "```chuck\nfloat mix(float value)\n```\nSet mix level.",
            "```chuck\nfloat mix()\n```\nGet mix level."
        ],
        "link": "[More...](https://chuck.stanford.edu/doc/reference/ugens-stk.html#JCRev)"
    },
    "KBHit": {
        "title": "**Keyboard Hit**",
        "description": "KBHit (terminal only) is a simple mechanism for capturing keyboard input; for a more flexible mechanism, see HID. (On Linux, KBHit does not require granting device permissions; it works out of the box.)",
        "constructors": [
            "**Constructors:**",
            "```chuck\nKBHit()\n```\nDefault constructor for KBHit."
        ],
        "examples": [
            "Examples: \t [kbhit.ck](https://chuck.stanford.edu/doc/examples/hid/kbhit/kbhit.ck), [kbhit2.ck](https://chuck.stanford.edu/doc/examples/hid/kbhit/kbhit2.ck), [clix.ck](https://chuck.stanford.edu/doc/examples/hid/kbhit/clix.ck), [clix2.ck](https://chuck.stanford.edu/doc/examples/hid/kbhit/clix2.ck), [clix3.ck](https://chuck.stanford.edu/doc/examples/hid/kbhit/clix3.ck)"
        ],
        "functions": [
            "**Methods:**",
            "```chuck\nint can_wait()\n```\n(internal) used by virtual machine for synthronization.",
            "```chuck\nint getchar()\n```\nGet the ASCII value of the last keyboard press.",
            "```chuck\nEvent hit()\n```\nReturn itself as an Event to wait on; this is largely unnecessary as the KBHit instance can be directly => to 'now'.",
            "```chuck\nint more()\n```\nReturn whether there are unprocessed KBHit events (e.g., if a user presses multiple keys at once).",
            "```chuck\nvoid off()\n```\nDisable the KBHit.",
            "```chuck\nvoid on()\n```\nEnable the KBHit.",
            "```chuck\nvoid state()\n```\nGet whether the KBHit is currently enabled."
        ],
        "link": "[More...](https://chuck.stanford.edu/doc/reference/io.html#KBHit)"
    },
    "KNN": {
        "title": "**K-Nearest Neighbors**",
        "description": "A basic k-NN utility that searches for k nearest neighbors from a set of observations / feature vectors. (Also see KNN2. The differrence between KNN and KNN2 is that KNN does not deal with labels whereas KNN2 is designed to work with labels.)",
        "constructors": [
            "**Constructors:**",
            "```chuck\nKNN()\n```\nDefault constructor for KNN."
        ],
        "examples": [
            "Examples: \t [knn-search.ck](https://chuck.stanford.edu/doc/examples/ai/knn/knn-search.ck)"
        ],
        "functions": [
            "**Methods:**",
            "```chuck\nvoid search(float[] query, int k, int[] indices)\n```\nSearch for the 'k' nearest neighbors of 'query' and return their corresponding indices.",
            "```chuck\nvoid search(float[] query, int k, int[] indices, float[][] observations)\n```\nSearch for the 'k' nearest neighbors of 'query' and return their corresponding indices and observations.",
            "```chuck\nint train(float[][] x)\n```\nTrain the KNN model with the given observations 'x'",
            "```chuck\nvoid weigh(float[] weights)\n```\nSet the weights for each dimension in the data."
        ],
        "link": "[More...](https://chuck.stanford.edu/doc/reference/ai.html#KNN)"
    },
    "KNN2": {
        "title": "**K-Nearest Neighbors (Labels)**",
        "description": "A k-NN utility that predicts probabilities of class membership based on distances from a test input to its k nearest neighbors. (Also see KNN. The differrence between KNN and KNN2 is that KNN does not deal with labels whereas KNN2 is designed to work with labels.)",
        "constructors": [
            "**Constructors:**",
            "```chuck\nKNN2()\n```\nDefault constructor for KNN2."
        ],
        "examples": [
            "Examples: \t [knn2-classify.ck](https://chuck.stanford.edu/doc/examples/ai/knn/knn2-classify.ck), [knn2-search.ck](https://chuck.stanford.edu/doc/examples/ai/knn/knn2-search.ck)"
        ],
        "functions": [
            "**Methods:**",
            "```chuck\nint predict(float[] query, int k, float[] prob)\n```\nPredict the output probabilities 'prob' given unlabeled test input 'query' based on distances to 'k' nearest neighbors.",
            "```chuck\nvoid search(float[] query, int k, int[] labels)\n```\nSearch for the 'k' nearest neighbors of 'query' and return their labels.",
            "```chuck\nvoid search(float[] query, int k, int[] labels, int[] indices)\n```\nSearch for the 'k' nearest neighbors of 'query' and return their labels and indices.",
            "```chuck\nvoid search(float[] query, int k, int[] labels, int[] indices, float[][] observations)\n```\nSearch for the 'k' nearest neighbors of 'query' and return their labels, indices, and observations.",
            "```chuck\nint train(float[][] x, int[] labels)\n```\nTrain the KNN model with the given observations 'x' and corresponding labels.",
            "```chuck\nvoid weigh(float[] weights)\n```\nSet the weights for each dimension in the data."
        ],
        "link": "[More...](https://chuck.stanford.edu/doc/reference/ai.html#KNN2)"
    },
    "KasFilter": {
        "title": "**Kassel Filter**",
        "description": "Under-sampling-based resonant lowpass filter, based on two sample & holds with a cosine crossfading between them. Each S&H samples at the moment it's faded out. The frequency of the crossfading and sampling of the input sets the cutoff. This leads to a infinitely steep cutoff, at the price of aliasing. Negative feedback is used for resonance at the cutoff frequency, a technique that I believe is new here. In addition to the traditional modulation options waveshaping of the crossfading signal is provided. This leads to distortion at the cutoff frequency. At extreme values (and assuming no feedback is used) that makes the effect closer to traditional under-sampling. Linear interpolation is used on the input signal to avoid the S&Hs being quantised to ChucK's sample rate; This technique causes quite a few interesting artifacts that result from the ratio between the frequency of the input and the cutoff frequency. To emphasise those it makes sense to try to minimise artifacts induced by the digital environment itself. Thanks to Rob Hordijk for sharing his insights there.",
        "constructors": [
            "**Constructors:**",
            "```chuck\nKasFilter()\n```\n"
        ],
        "examples": [
            "Examples: \t [KasFilter.ck](https://chuck.stanford.edu/doc/examples/filter/KasFilter.ck)"
        ],
        "functions": [
            "**Methods:**",
            "```chuck\nfloat accent(float arg)\n```\nSets the amount of waveshaping on the crossfading sine [0 - 1]. 1 is close to regular under-sampling (if no resonance is used).",
            "```chuck\nfloat accent()\n```\nGets the amount of waveshaping on the crossfading sine [0 - 1]. 1 is close to regular under-sampling (if no resonance is used).",
            "```chuck\nfloat freq(float arg)\n```\nSets the cutoff frequency. This sets both the frequency at which the two sample & holds sample the input signal and the frequency of the sine that crossfades between them.",
            "```chuck\nfloat freq()\n```\nGets the cutoff frequency. This sets both the frequency at which the two sample & holds sample the input signal and the frequency of the sine that crossfades between them.",
            "```chuck\nfloat resonance(float arg)\n```\nSets the resonance, which is implemented as negative feedback [0 - 0.95].",
            "```chuck\nfloat resonance()\n```\nGets the resonance, which is implemented as negative feedback [0 - 0.95]."
        ],
        "link": "[More...](https://chuck.stanford.edu/doc/reference/chugins.html#KasFilter)"
    },
    "KrstlChr": {
        "title": "**STK Crystal Choir**",
        "description": "STK-style \"Crystal Choir\" FM synthesis instrument. This class implements 3 parallel operators with being modulated (feedback modulation), also referred to as algorithm 7 of the TX81Z. Algorithm 7 is :     1 -\\   2 - +-> Out   4-->3 -/    Control Change Numbers: - Total Modulator Index = 2 (.controlOne) - Modulator Crossfade = 4 (.controlTwo) - LFO Speed = 11 - LFO Depth = 1 - ADSR 2 & 4 Target = 128 The basic Chowning/Stanford FM patent expired in 1995, but there exist follow-on patents, mostly assigned to Yamaha. If you are of the type who should worry about this (making money) worry away. by Perry R. Cook and Gary P. Scavone, 1995 - 2002.",
        "constructors": [
            "**Constructors:**",
            "```chuck\nKrstlChr()\n```\nDefault constructor for KrstlChr."
        ],
        "examples": [
            "Examples: \t [krstlchr-algo7.ck](https://chuck.stanford.edu/doc/examples/stk/krstlchr-algo7.ck)"
        ],
        "functions": [],
        "link": "[More...](https://chuck.stanford.edu/doc/reference/ugens-stk.html#KrstlChr)"
    },
    "Kurtosis": {
        "title": "**Kurtosis Analyzer**",
        "description": "A unit analyzer that computes the kurtosis of a given input array, and outputs a single number.",
        "constructors": [
            "**Constructors:**",
            "```chuck\nKurtosis()\n```\nDefault constructor for Kurtosis."
        ],
        "examples": [
            "Examples: \t [kurtosis.ck](https://chuck.stanford.edu/doc/examples/ai/features/kurtosis.ck)"
        ],
        "functions": [
            "**Methods:**",
            "```chuck\nfloat compute(float[] input)\n```\nManually computes the kurtosis of a given input array."
        ],
        "link": "[More...](https://chuck.stanford.edu/doc/reference/uanae.html#Kurtosis)"
    },
    "LPF": {
        "title": "**Low-Pass Filter**",
        "description": "A resonant low-pass filter (2nd order Butterworth).",
        "constructors": [
            "**Constructors:**",
            "```chuck\nLPF()\n```\nDefault constructor for LPF."
        ],
        "examples": [
            "Examples: \t [lpf.ck](https://chuck.stanford.edu/doc/examples/filter/lpf.ck), [rlpf.ck](https://chuck.stanford.edu/doc/examples/filter/rlpf.ck)"
        ],
        "functions": [
            "**Methods:**",
            "```chuck\nfloat Q(float val)\n```\nSet filter resonance.",
            "```chuck\nfloat Q()\n```\nGet filter resonance.",
            "```chuck\nfloat freq(float val)\n```\nSet filter cutoff frequency.",
            "```chuck\nfloat freq()\n```\nGet filter cutoff frequency.",
            "```chuck\nvoid set(float freq, float Q)\n```\nSet filter frequency and resonance at the same time."
        ],
        "link": "[More...](https://chuck.stanford.edu/doc/reference/ugens-filters.html#LPF)"
    },
    "LiSa": {
        "title": "**Live Sampling UGen**",
        "description": "LiSa provides basic live sampling functionality,  and is also often used for granular synthesis.  An internal buffer stores samples chucked to LiSa's input.  Segments of this buffer can be played back, with ramping and  speed/direction control.  Multiple voice facility is built in, allowing for a single  LiSa object to serve as a source for sample layering and  granular textures.  by Dan Trueman (2007)   See also: a slowly growing <a target=\"_blank\" href=\"../program/lisa/tutorial-1.html\">tutorial</a>  | <a target=\"_blank\" href=\"../examples/#lisa\">LiSa examples</a> in the ChucK distribution | <a target=\"_blank\" href=\"https://www.youtube.com/watch?v=7F75v_73pF4\">video tutorial</a> by Clint Hoagland.",
        "constructors": [
            "**Constructors:**",
            "```chuck\nLiSa()\n```\nDefault constructor for LiSa."
        ],
        "examples": [
            "Examples: \t [LiSa-munger1.ck](https://chuck.stanford.edu/doc/examples/special/LiSa-munger1.ck), [LiSa-munger2.ck](https://chuck.stanford.edu/doc/examples/special/LiSa-munger2.ck), [LiSa-munger3.ck](https://chuck.stanford.edu/doc/examples/special/LiSa-munger3.ck), [LiSa-load.ck](https://chuck.stanford.edu/doc/examples/special/LiSa-load.ck), [LiSa-simplelooping.ck](https://chuck.stanford.edu/doc/examples/special/LiSa-simplelooping.ck), [LiSa-trigger.ck](https://chuck.stanford.edu/doc/examples/special/LiSa-trigger.ck), [LiSa-track1.ck](https://chuck.stanford.edu/doc/examples/special/LiSa-track1.ck), [LiSa-track2.ck](https://chuck.stanford.edu/doc/examples/special/LiSa-track2.ck), [LiSa-track3.ck](https://chuck.stanford.edu/doc/examples/special/LiSa-track3.ck), [LiSa-track4.ck](https://chuck.stanford.edu/doc/examples/special/LiSa-track4.ck), [LiSa-track5.ck](https://chuck.stanford.edu/doc/examples/special/LiSa-track5.ck), [LiSa-stereo.ck](https://chuck.stanford.edu/doc/examples/special/LiSa-stereo.ck), [scream-o-matic.ck](https://chuck.stanford.edu/doc/examples/special/scream-o-matic/scream-o-matic.ck), [twilight-granular-kb.ck](https://chuck.stanford.edu/doc/examples/special/twilight/twilight-granular-kb.ck), [twilight-granular-kb-interp.ck](https://chuck.stanford.edu/doc/examples/special/twilight/twilight-granular-kb-interp.ck)"
        ],
        "functions": [
            "**Methods:**",
            "```chuck\nint bi(int voice, int val)\n```\nFor particular voice (arg 1), turn on/off bidirectional playback.",
            "```chuck\nint bi(int val)\n```\nFor particular voice (arg 1), get bidirectional playback status.",
            "```chuck\nint bi()\n```\nGet birectional playback status.",
            "```chuck\nvoid clear()\n```\nClear recording buffer.",
            "```chuck\ndur duration(dur val)\n```\nSet buffer size; required to allocate memory, also resets all parameter values to default.",
            "```chuck\ndur duration()\n```\nGet buffer size.",
            "```chuck\nfloat feedback(float val)\n```\nSet feedback amount when overdubbing (loop recording; how much to retain).",
            "```chuck\nfloat feedback()\n```\nGet feedback amount when overdubbing (loop recording; how much to retain).",
            "```chuck\nint getVoice()\n```\nReturn an available voice (one that is not currently playing). Return -1 if no voice is available.",
            "```chuck\nint getbi(int voice)\n```\nTurn on/off bidirectional playback (voice 0).",
            "```chuck\nint loop0(int val)\n```\nTurn on/off looping (voice 0).",
            "```chuck\nint loop0()\n```\nGet looping status (voice 0).",
            "```chuck\nint loop(int voice, int val)\n```\nFor particular voice (arg 1), turn on/off looping.",
            "```chuck\nint loop(int voice)\n```\nFor particular voice (arg 1), get looping status.",
            "```chuck\ndur loopEnd(int voice, dur val)\n```\nFor particular voice (arg 1), set loop ending point for playback. only applicable when .loop(voice, 1).",
            "```chuck\ndur loopEnd(int voice)\n```\nFor particular voice (arg 1), get loop ending point for playback. only applicable when .loop(voice, 1).",
            "```chuck\ndur loopEnd(dur val)\n```\nSet loop ending point for playback (voice 0). only applicable when 1 => loop.",
            "```chuck\ndur loopEnd()\n```\nGet loop ending point for playback (voice 0). only applicable when 1 => loop.",
            "```chuck\ndur loopEndRec(dur val)\n```\nSet end point in buffer for loop recording.",
            "```chuck\ndur loopEndRec()\n```\nGet end point in buffer for loop recording.",
            "```chuck\nint loopRec(int val)\n```\nTurn on/off loop recording.",
            "```chuck\nint loopRec()\n```\nGet loop recording status.",
            "```chuck\ndur loopStart(int voice, dur val)\n```\nFor particular voice (arg 1), set loop starting point for playback. only applicable when .loop(voice, 1).",
            "```chuck\ndur loopStart(int voice)\n```\nFor particular voice (arg 1), get loop starting point for playback. only applicable when .loop(voice, 1).",
            "```chuck\ndur loopStart(dur val)\n```\nSet loop starting point for playback (voice 0). only applicable when 1 => loop.",
            "```chuck\ndur loopStart()\n```\nGet loop starting point for playback (voice 0). only applicable when 1 => loop.",
            "```chuck\nint maxVoices(int val)\n```\nSet the maximum number of voices allowable; 10 by default (256 is the current hardwired internal limit).",
            "```chuck\nint maxVoices()\n```\nGet the maximum number of voices allowable; 10 by default (256 is the current hardwired internal limit).",
            "```chuck\nfloat pan(int voice, float val)\n```\nFor particular voice (arg 1), set panning value [0.0, number of channels - 1.0].",
            "```chuck\nfloat pan(int voice)\n```\nFor particular voice (arg 1), get panning value.",
            "```chuck\nfloat pan(float val)\n```\nFor voice 0, set panning value [0.0, number of channels - 1.0].",
            "```chuck\nfloat pan()\n```\nFor voice 0, get panning value.",
            "```chuck\nint play(int voice, int toggle)\n```\nFor particular voice (arg 1), turn on/off sample playback.",
            "```chuck\nint play(int toggle)\n```\nTurn on/off sample playback (voice 0)",
            "```chuck\ndur playPos(int voice, dur val)\n```\nFor particular voice (arg 1), set playback position.",
            "```chuck\ndur playPos(int voice)\n```\nFor particular voice (arg 1), get playback position.",
            "```chuck\ndur playPos(dur val)\n```\nSet playback position (voice 0).",
            "```chuck\ndur playPos()\n```\nGet playback position (voice 0).",
            "```chuck\nint playing(int val)\n```\nGet playing status.",
            "```chuck\nvoid rampDown(int voice, dur val)\n```\nFor particular voice (arg 1), turn off sample playback, with ramp.",
            "```chuck\nvoid rampDown(dur val)\n```\nTurn off sample playback, with ramp (voice 0).",
            "```chuck\nvoid rampUp(int voice, dur val)\n```\nFor particular voice (arg 1), turn on sample playback, with ramp.",
            "```chuck\nvoid rampUp(dur val)\n```\nTurn on sample playback, with ramp (voice 0).",
            "```chuck\nfloat rate(int voice, float val)\n```\nFor particular voice (arg 1), set playback rate.",
            "```chuck\nfloat rate(int voice)\n```\nFor particular voice (arg 1), get playback rate.",
            "```chuck\nfloat rate(float val)\n```\nSet playback rate (voice 0). Note that the int/float type for this method will determine whether the rate is being set (float, for voice 0) or read (int, for voice number).",
            "```chuck\nfloat rate()\n```\nGet playback rate (voice 0).",
            "```chuck\ndur recPos(dur val)\n```\nSet record position.",
            "```chuck\ndur recPos()\n```\nGet record position.",
            "```chuck\ndur recRamp(dur val)\n```\nSet ramping when recording (from 0 to loopEndRec).",
            "```chuck\nint record(int toggle)\n```\nTurn recording on and off.",
            "```chuck\nint sync(int val)\n```\nSet input mode; (0) input is recorded to internal buffer, (1) input sets playback position [0,1] (phase value between loopStart and loopEnd for all active voices), (2) input sets playback position, interpreted as a time value in samples (only works with voice 0)",
            "```chuck\nint sync()\n```\nGet input mode; (0) input is recorded to internal buffer, (1) input sets playback position [0,1] (phase value between loopStart and loopEnd for all active voices), (2) input sets playback position, interpreted as a time value in samples (only works with voice 0)",
            "```chuck\nint track(int val)\n```\nIdentical to sync.",
            "```chuck\nint track()\n```\nIdentical to sync.",
            "```chuck\ndur value(int voice, dur val)\n```\nFor particular voice (arg 1), get value from the voice.",
            "```chuck\ndur value(dur val)\n```\nGet value from voice 0.",
            "```chuck\nfloat valueAt(float val, dur index)\n```\nSet value directly in record buffer.",
            "```chuck\nfloat valueAt(dur index)\n```\nGet value directly from record buffer.",
            "```chuck\nfloat voiceGain(int voice, float val)\n```\nFor particular voice (arg 1), set gain.",
            "```chuck\nfloat voiceGain(int voice)\n```\nSet playback gain (voice 0).",
            "```chuck\nfloat voicePan(int voice, float val)\n```\nFor particular voice (arg 1), set panning value [0.0, number of channels - 1.0].",
            "```chuck\nfloat voicePan(int voice)\n```\nFor particular voice (arg 1), get panning value."
        ],
        "link": "[More...](https://chuck.stanford.edu/doc/reference/ugens-advanced.html#LiSa)"
    },
    "LiSa10": {
        "title": "**Live Sampling UGen 10-channel**",
        "description": "A (li)ve (sa)mpling unit generator (10-channel edition); also popularly used for granular synthesis.",
        "constructors": [
            "**Constructors:**",
            "```chuck\nLiSa10()\n```\nDefault constructor for LiSa10."
        ],
        "examples": [],
        "functions": [
            "**Methods:**",
            "```chuck\nint bi(int voice, int val)\n```\nFor particular voice (arg 1), turn on/off bidirectional playback.",
            "```chuck\nint bi(int val)\n```\nFor particular voice (arg 1), get bidirectional playback status.",
            "```chuck\nint bi()\n```\nGet birectional playback status.",
            "```chuck\nvoid clear()\n```\nClear recording buffer.",
            "```chuck\ndur duration(dur val)\n```\nSet buffer size; required to allocate memory, also resets all parameter values to default.",
            "```chuck\ndur duration()\n```\nGet buffer size.",
            "```chuck\nfloat feedback(float val)\n```\nSet feedback amount when overdubbing (loop recording; how much to retain).",
            "```chuck\nfloat feedback()\n```\nGet feedback amount when overdubbing (loop recording; how much to retain).",
            "```chuck\nint getVoice()\n```\nReturn an available voice (one that is not currently playing). Return -1 if no voice is available.",
            "```chuck\nint getbi(int voice)\n```\nTurn on/off bidirectional playback (voice 0).",
            "```chuck\nint loop0(int val)\n```\nTurn on/off looping (voice 0).",
            "```chuck\nint loop0()\n```\nGet looping status (voice 0).",
            "```chuck\nint loop(int voice, int val)\n```\nFor particular voice (arg 1), turn on/off looping.",
            "```chuck\nint loop(int voice)\n```\nFor particular voice (arg 1), get looping status.",
            "```chuck\ndur loopEnd(int voice, dur val)\n```\nFor particular voice (arg 1), set loop ending point for playback. only applicable when .loop(voice, 1).",
            "```chuck\ndur loopEnd(int voice)\n```\nFor particular voice (arg 1), get loop ending point for playback. only applicable when .loop(voice, 1).",
            "```chuck\ndur loopEnd(dur val)\n```\nSet loop ending point for playback (voice 0). only applicable when 1 => loop.",
            "```chuck\ndur loopEnd()\n```\nGet loop ending point for playback (voice 0). only applicable when 1 => loop.",
            "```chuck\ndur loopEndRec(dur val)\n```\nSet end point in buffer for loop recording.",
            "```chuck\ndur loopEndRec()\n```\nGet end point in buffer for loop recording.",
            "```chuck\nint loopRec(int val)\n```\nTurn on/off loop recording.",
            "```chuck\nint loopRec()\n```\nGet loop recording status.",
            "```chuck\ndur loopStart(int voice, dur val)\n```\nFor particular voice (arg 1), set loop starting point for playback. only applicable when .loop(voice, 1).",
            "```chuck\ndur loopStart(int voice)\n```\nFor particular voice (arg 1), get loop starting point for playback. only applicable when .loop(voice, 1).",
            "```chuck\ndur loopStart(dur val)\n```\nSet loop starting point for playback (voice 0). only applicable when 1 => loop.",
            "```chuck\ndur loopStart()\n```\nGet loop starting point for playback (voice 0). only applicable when 1 => loop.",
            "```chuck\nint maxVoices(int val)\n```\nSet the maximum number of voices allowable; 10 by default (256 is the current hardwired internal limit).",
            "```chuck\nint maxVoices()\n```\nGet the maximum number of voices allowable; 10 by default (256 is the current hardwired internal limit).",
            "```chuck\nfloat pan(int voice, float val)\n```\nFor particular voice (arg 1), set panning value [0.0, number of channels - 1.0].",
            "```chuck\nfloat pan(int voice)\n```\nFor particular voice (arg 1), get panning value.",
            "```chuck\nfloat pan(float val)\n```\nFor voice 0, set panning value [0.0, number of channels - 1.0].",
            "```chuck\nfloat pan()\n```\nFor voice 0, get panning value.",
            "```chuck\nint play(int voice, int toggle)\n```\nFor particular voice (arg 1), turn on/off sample playback.",
            "```chuck\nint play(int toggle)\n```\nTurn on/off sample playback (voice 0)",
            "```chuck\ndur playPos(int voice, dur val)\n```\nFor particular voice (arg 1), set playback position.",
            "```chuck\ndur playPos(int voice)\n```\nFor particular voice (arg 1), get playback position.",
            "```chuck\ndur playPos(dur val)\n```\nSet playback position (voice 0).",
            "```chuck\ndur playPos()\n```\nGet playback position (voice 0).",
            "```chuck\nint playing(int val)\n```\nGet playing status.",
            "```chuck\nvoid rampDown(int voice, dur val)\n```\nFor particular voice (arg 1), turn off sample playback, with ramp.",
            "```chuck\nvoid rampDown(dur val)\n```\nTurn off sample playback, with ramp (voice 0).",
            "```chuck\nvoid rampUp(int voice, dur val)\n```\nFor particular voice (arg 1), turn on sample playback, with ramp.",
            "```chuck\nvoid rampUp(dur val)\n```\nTurn on sample playback, with ramp (voice 0).",
            "```chuck\nfloat rate(int voice, float val)\n```\nFor particular voice (arg 1), set playback rate.",
            "```chuck\nfloat rate(int voice)\n```\nFor particular voice (arg 1), get playback rate.",
            "```chuck\nfloat rate(float val)\n```\nSet playback rate (voice 0). Note that the int/float type for this method will determine whether the rate is being set (float, for voice 0) or read (int, for voice number).",
            "```chuck\nfloat rate()\n```\nGet playback rate (voice 0).",
            "```chuck\ndur recPos(dur val)\n```\nSet record position.",
            "```chuck\ndur recPos()\n```\nGet record position.",
            "```chuck\ndur recRamp(dur val)\n```\nSet ramping when recording (from 0 to loopEndRec).",
            "```chuck\nint record(int toggle)\n```\nTurn recording on and off.",
            "```chuck\nint sync(int val)\n```\nSet input mode; (0) input is recorded to internal buffer, (1) input sets playback position [0,1] (phase value between loopStart and loopEnd for all active voices), (2) input sets playback position, interpreted as a time value in samples (only works with voice 0)",
            "```chuck\nint sync()\n```\nGet input mode; (0) input is recorded to internal buffer, (1) input sets playback position [0,1] (phase value between loopStart and loopEnd for all active voices), (2) input sets playback position, interpreted as a time value in samples (only works with voice 0)",
            "```chuck\nint track(int val)\n```\nIdentical to sync.",
            "```chuck\nint track()\n```\nIdentical to sync.",
            "```chuck\ndur value(int voice, dur val)\n```\nFor particular voice (arg 1), get value from the voice.",
            "```chuck\ndur value(dur val)\n```\nGet value from voice 0.",
            "```chuck\nfloat valueAt(float val, dur index)\n```\nSet value directly in record buffer.",
            "```chuck\nfloat valueAt(dur index)\n```\nGet value directly from record buffer.",
            "```chuck\nfloat voiceGain(int voice, float val)\n```\nFor particular voice (arg 1), set gain.",
            "```chuck\nfloat voiceGain(int voice)\n```\nSet playback gain (voice 0).",
            "```chuck\nfloat voicePan(int voice, float val)\n```\nFor particular voice (arg 1), set panning value [0.0, number of channels - 1.0].",
            "```chuck\nfloat voicePan(int voice)\n```\nFor particular voice (arg 1), get panning value."
        ],
        "link": "[More...](https://chuck.stanford.edu/doc/reference/ugens-advanced.html#LiSa10)"
    },
    "LiSa16": {
        "title": "**Live Sampling UGen 16-channel**",
        "description": "A (li)ve (sa)mpling unit generator (16-channel edition); also popularly used for granular synthesis.",
        "constructors": [
            "**Constructors:**",
            "```chuck\nLiSa16()\n```\nDefault constructor for LiSa16."
        ],
        "examples": [],
        "functions": [
            "**Methods:**",
            "```chuck\nint bi(int voice, int val)\n```\nFor particular voice (arg 1), turn on/off bidirectional playback.",
            "```chuck\nint bi(int val)\n```\nFor particular voice (arg 1), get bidirectional playback status.",
            "```chuck\nint bi()\n```\nGet birectional playback status.",
            "```chuck\nvoid clear()\n```\nClear recording buffer.",
            "```chuck\ndur duration(dur val)\n```\nSet buffer size; required to allocate memory, also resets all parameter values to default.",
            "```chuck\ndur duration()\n```\nGet buffer size.",
            "```chuck\nfloat feedback(float val)\n```\nSet feedback amount when overdubbing (loop recording; how much to retain).",
            "```chuck\nfloat feedback()\n```\nGet feedback amount when overdubbing (loop recording; how much to retain).",
            "```chuck\nint getVoice()\n```\nReturn an available voice (one that is not currently playing). Return -1 if no voice is available.",
            "```chuck\nint getbi(int voice)\n```\nTurn on/off bidirectional playback (voice 0).",
            "```chuck\nint loop0(int val)\n```\nTurn on/off looping (voice 0).",
            "```chuck\nint loop0()\n```\nGet looping status (voice 0).",
            "```chuck\nint loop(int voice, int val)\n```\nFor particular voice (arg 1), turn on/off looping.",
            "```chuck\nint loop(int voice)\n```\nFor particular voice (arg 1), get looping status.",
            "```chuck\ndur loopEnd(int voice, dur val)\n```\nFor particular voice (arg 1), set loop ending point for playback. only applicable when .loop(voice, 1).",
            "```chuck\ndur loopEnd(int voice)\n```\nFor particular voice (arg 1), get loop ending point for playback. only applicable when .loop(voice, 1).",
            "```chuck\ndur loopEnd(dur val)\n```\nSet loop ending point for playback (voice 0). only applicable when 1 => loop.",
            "```chuck\ndur loopEnd()\n```\nGet loop ending point for playback (voice 0). only applicable when 1 => loop.",
            "```chuck\ndur loopEndRec(dur val)\n```\nSet end point in buffer for loop recording.",
            "```chuck\ndur loopEndRec()\n```\nGet end point in buffer for loop recording.",
            "```chuck\nint loopRec(int val)\n```\nTurn on/off loop recording.",
            "```chuck\nint loopRec()\n```\nGet loop recording status.",
            "```chuck\ndur loopStart(int voice, dur val)\n```\nFor particular voice (arg 1), set loop starting point for playback. only applicable when .loop(voice, 1).",
            "```chuck\ndur loopStart(int voice)\n```\nFor particular voice (arg 1), get loop starting point for playback. only applicable when .loop(voice, 1).",
            "```chuck\ndur loopStart(dur val)\n```\nSet loop starting point for playback (voice 0). only applicable when 1 => loop.",
            "```chuck\ndur loopStart()\n```\nGet loop starting point for playback (voice 0). only applicable when 1 => loop.",
            "```chuck\nint maxVoices(int val)\n```\nSet the maximum number of voices allowable; 10 by default (256 is the current hardwired internal limit).",
            "```chuck\nint maxVoices()\n```\nGet the maximum number of voices allowable; 10 by default (256 is the current hardwired internal limit).",
            "```chuck\nfloat pan(int voice, float val)\n```\nFor particular voice (arg 1), set panning value [0.0, number of channels - 1.0].",
            "```chuck\nfloat pan(int voice)\n```\nFor particular voice (arg 1), get panning value.",
            "```chuck\nfloat pan(float val)\n```\nFor voice 0, set panning value [0.0, number of channels - 1.0].",
            "```chuck\nfloat pan()\n```\nFor voice 0, get panning value.",
            "```chuck\nint play(int voice, int toggle)\n```\nFor particular voice (arg 1), turn on/off sample playback.",
            "```chuck\nint play(int toggle)\n```\nTurn on/off sample playback (voice 0)",
            "```chuck\ndur playPos(int voice, dur val)\n```\nFor particular voice (arg 1), set playback position.",
            "```chuck\ndur playPos(int voice)\n```\nFor particular voice (arg 1), get playback position.",
            "```chuck\ndur playPos(dur val)\n```\nSet playback position (voice 0).",
            "```chuck\ndur playPos()\n```\nGet playback position (voice 0).",
            "```chuck\nint playing(int val)\n```\nGet playing status.",
            "```chuck\nvoid rampDown(int voice, dur val)\n```\nFor particular voice (arg 1), turn off sample playback, with ramp.",
            "```chuck\nvoid rampDown(dur val)\n```\nTurn off sample playback, with ramp (voice 0).",
            "```chuck\nvoid rampUp(int voice, dur val)\n```\nFor particular voice (arg 1), turn on sample playback, with ramp.",
            "```chuck\nvoid rampUp(dur val)\n```\nTurn on sample playback, with ramp (voice 0).",
            "```chuck\nfloat rate(int voice, float val)\n```\nFor particular voice (arg 1), set playback rate.",
            "```chuck\nfloat rate(int voice)\n```\nFor particular voice (arg 1), get playback rate.",
            "```chuck\nfloat rate(float val)\n```\nSet playback rate (voice 0). Note that the int/float type for this method will determine whether the rate is being set (float, for voice 0) or read (int, for voice number).",
            "```chuck\nfloat rate()\n```\nGet playback rate (voice 0).",
            "```chuck\ndur recPos(dur val)\n```\nSet record position.",
            "```chuck\ndur recPos()\n```\nGet record position.",
            "```chuck\ndur recRamp(dur val)\n```\nSet ramping when recording (from 0 to loopEndRec).",
            "```chuck\nint record(int toggle)\n```\nTurn recording on and off.",
            "```chuck\nint sync(int val)\n```\nSet input mode; (0) input is recorded to internal buffer, (1) input sets playback position [0,1] (phase value between loopStart and loopEnd for all active voices), (2) input sets playback position, interpreted as a time value in samples (only works with voice 0)",
            "```chuck\nint sync()\n```\nGet input mode; (0) input is recorded to internal buffer, (1) input sets playback position [0,1] (phase value between loopStart and loopEnd for all active voices), (2) input sets playback position, interpreted as a time value in samples (only works with voice 0)",
            "```chuck\nint track(int val)\n```\nIdentical to sync.",
            "```chuck\nint track()\n```\nIdentical to sync.",
            "```chuck\ndur value(int voice, dur val)\n```\nFor particular voice (arg 1), get value from the voice.",
            "```chuck\ndur value(dur val)\n```\nGet value from voice 0.",
            "```chuck\nfloat valueAt(float val, dur index)\n```\nSet value directly in record buffer.",
            "```chuck\nfloat valueAt(dur index)\n```\nGet value directly from record buffer.",
            "```chuck\nfloat voiceGain(int voice, float val)\n```\nFor particular voice (arg 1), set gain.",
            "```chuck\nfloat voiceGain(int voice)\n```\nSet playback gain (voice 0).",
            "```chuck\nfloat voicePan(int voice, float val)\n```\nFor particular voice (arg 1), set panning value [0.0, number of channels - 1.0].",
            "```chuck\nfloat voicePan(int voice)\n```\nFor particular voice (arg 1), get panning value."
        ],
        "link": "[More...](https://chuck.stanford.edu/doc/reference/ugens-advanced.html#LiSa16)"
    },
    "LiSa2": {
        "title": "**Live Sampling UGen 2-channel**",
        "description": "A (li)ve (sa)mpling unit generator (stereo edition); also popularly used for granular synthesis.",
        "constructors": [
            "**Constructors:**",
            "```chuck\nLiSa2()\n```\nDefault constructor for LiSa2."
        ],
        "examples": [
            "Examples: \t [LiSa-stereo.ck](https://chuck.stanford.edu/doc/examples/special/LiSa-stereo.ck)"
        ],
        "functions": [
            "**Methods:**",
            "```chuck\nint bi(int voice, int val)\n```\nFor particular voice (arg 1), turn on/off bidirectional playback.",
            "```chuck\nint bi(int val)\n```\nFor particular voice (arg 1), get bidirectional playback status.",
            "```chuck\nint bi()\n```\nGet birectional playback status.",
            "```chuck\nvoid clear()\n```\nClear recording buffer.",
            "```chuck\ndur duration(dur val)\n```\nSet buffer size; required to allocate memory, also resets all parameter values to default.",
            "```chuck\ndur duration()\n```\nGet buffer size.",
            "```chuck\nfloat feedback(float val)\n```\nSet feedback amount when overdubbing (loop recording; how much to retain).",
            "```chuck\nfloat feedback()\n```\nGet feedback amount when overdubbing (loop recording; how much to retain).",
            "```chuck\nint getVoice()\n```\nReturn an available voice (one that is not currently playing). Return -1 if no voice is available.",
            "```chuck\nint getbi(int voice)\n```\nTurn on/off bidirectional playback (voice 0).",
            "```chuck\nint loop0(int val)\n```\nTurn on/off looping (voice 0).",
            "```chuck\nint loop0()\n```\nGet looping status (voice 0).",
            "```chuck\nint loop(int voice, int val)\n```\nFor particular voice (arg 1), turn on/off looping.",
            "```chuck\nint loop(int voice)\n```\nFor particular voice (arg 1), get looping status.",
            "```chuck\ndur loopEnd(int voice, dur val)\n```\nFor particular voice (arg 1), set loop ending point for playback. only applicable when .loop(voice, 1).",
            "```chuck\ndur loopEnd(int voice)\n```\nFor particular voice (arg 1), get loop ending point for playback. only applicable when .loop(voice, 1).",
            "```chuck\ndur loopEnd(dur val)\n```\nSet loop ending point for playback (voice 0). only applicable when 1 => loop.",
            "```chuck\ndur loopEnd()\n```\nGet loop ending point for playback (voice 0). only applicable when 1 => loop.",
            "```chuck\ndur loopEndRec(dur val)\n```\nSet end point in buffer for loop recording.",
            "```chuck\ndur loopEndRec()\n```\nGet end point in buffer for loop recording.",
            "```chuck\nint loopRec(int val)\n```\nTurn on/off loop recording.",
            "```chuck\nint loopRec()\n```\nGet loop recording status.",
            "```chuck\ndur loopStart(int voice, dur val)\n```\nFor particular voice (arg 1), set loop starting point for playback. only applicable when .loop(voice, 1).",
            "```chuck\ndur loopStart(int voice)\n```\nFor particular voice (arg 1), get loop starting point for playback. only applicable when .loop(voice, 1).",
            "```chuck\ndur loopStart(dur val)\n```\nSet loop starting point for playback (voice 0). only applicable when 1 => loop.",
            "```chuck\ndur loopStart()\n```\nGet loop starting point for playback (voice 0). only applicable when 1 => loop.",
            "```chuck\nint maxVoices(int val)\n```\nSet the maximum number of voices allowable; 10 by default (256 is the current hardwired internal limit).",
            "```chuck\nint maxVoices()\n```\nGet the maximum number of voices allowable; 10 by default (256 is the current hardwired internal limit).",
            "```chuck\nfloat pan(int voice, float val)\n```\nFor particular voice (arg 1), set panning value [0.0, number of channels - 1.0].",
            "```chuck\nfloat pan(int voice)\n```\nFor particular voice (arg 1), get panning value.",
            "```chuck\nfloat pan(float val)\n```\nFor voice 0, set panning value [0.0, number of channels - 1.0].",
            "```chuck\nfloat pan()\n```\nFor voice 0, get panning value.",
            "```chuck\nint play(int voice, int toggle)\n```\nFor particular voice (arg 1), turn on/off sample playback.",
            "```chuck\nint play(int toggle)\n```\nTurn on/off sample playback (voice 0)",
            "```chuck\ndur playPos(int voice, dur val)\n```\nFor particular voice (arg 1), set playback position.",
            "```chuck\ndur playPos(int voice)\n```\nFor particular voice (arg 1), get playback position.",
            "```chuck\ndur playPos(dur val)\n```\nSet playback position (voice 0).",
            "```chuck\ndur playPos()\n```\nGet playback position (voice 0).",
            "```chuck\nint playing(int val)\n```\nGet playing status.",
            "```chuck\nvoid rampDown(int voice, dur val)\n```\nFor particular voice (arg 1), turn off sample playback, with ramp.",
            "```chuck\nvoid rampDown(dur val)\n```\nTurn off sample playback, with ramp (voice 0).",
            "```chuck\nvoid rampUp(int voice, dur val)\n```\nFor particular voice (arg 1), turn on sample playback, with ramp.",
            "```chuck\nvoid rampUp(dur val)\n```\nTurn on sample playback, with ramp (voice 0).",
            "```chuck\nfloat rate(int voice, float val)\n```\nFor particular voice (arg 1), set playback rate.",
            "```chuck\nfloat rate(int voice)\n```\nFor particular voice (arg 1), get playback rate.",
            "```chuck\nfloat rate(float val)\n```\nSet playback rate (voice 0). Note that the int/float type for this method will determine whether the rate is being set (float, for voice 0) or read (int, for voice number).",
            "```chuck\nfloat rate()\n```\nGet playback rate (voice 0).",
            "```chuck\ndur recPos(dur val)\n```\nSet record position.",
            "```chuck\ndur recPos()\n```\nGet record position.",
            "```chuck\ndur recRamp(dur val)\n```\nSet ramping when recording (from 0 to loopEndRec).",
            "```chuck\nint record(int toggle)\n```\nTurn recording on and off.",
            "```chuck\nint sync(int val)\n```\nSet input mode; (0) input is recorded to internal buffer, (1) input sets playback position [0,1] (phase value between loopStart and loopEnd for all active voices), (2) input sets playback position, interpreted as a time value in samples (only works with voice 0)",
            "```chuck\nint sync()\n```\nGet input mode; (0) input is recorded to internal buffer, (1) input sets playback position [0,1] (phase value between loopStart and loopEnd for all active voices), (2) input sets playback position, interpreted as a time value in samples (only works with voice 0)",
            "```chuck\nint track(int val)\n```\nIdentical to sync.",
            "```chuck\nint track()\n```\nIdentical to sync.",
            "```chuck\ndur value(int voice, dur val)\n```\nFor particular voice (arg 1), get value from the voice.",
            "```chuck\ndur value(dur val)\n```\nGet value from voice 0.",
            "```chuck\nfloat valueAt(float val, dur index)\n```\nSet value directly in record buffer.",
            "```chuck\nfloat valueAt(dur index)\n```\nGet value directly from record buffer.",
            "```chuck\nfloat voiceGain(int voice, float val)\n```\nFor particular voice (arg 1), set gain.",
            "```chuck\nfloat voiceGain(int voice)\n```\nSet playback gain (voice 0).",
            "```chuck\nfloat voicePan(int voice, float val)\n```\nFor particular voice (arg 1), set panning value [0.0, number of channels - 1.0].",
            "```chuck\nfloat voicePan(int voice)\n```\nFor particular voice (arg 1), get panning value."
        ],
        "link": "[More...](https://chuck.stanford.edu/doc/reference/ugens-advanced.html#LiSa2)"
    },
    "LiSa6": {
        "title": "**Live Sampling UGen 6-channel**",
        "description": "A (li)ve (sa)mpling unit generator (6-channel edition); also popularly used for granular synthesis.",
        "constructors": [
            "**Constructors:**",
            "```chuck\nLiSa6()\n```\nDefault constructor for LiSa6."
        ],
        "examples": [],
        "functions": [
            "**Methods:**",
            "```chuck\nint bi(int voice, int val)\n```\nFor particular voice (arg 1), turn on/off bidirectional playback.",
            "```chuck\nint bi(int val)\n```\nFor particular voice (arg 1), get bidirectional playback status.",
            "```chuck\nint bi()\n```\nGet birectional playback status.",
            "```chuck\nvoid clear()\n```\nClear recording buffer.",
            "```chuck\ndur duration(dur val)\n```\nSet buffer size; required to allocate memory, also resets all parameter values to default.",
            "```chuck\ndur duration()\n```\nGet buffer size.",
            "```chuck\nfloat feedback(float val)\n```\nSet feedback amount when overdubbing (loop recording; how much to retain).",
            "```chuck\nfloat feedback()\n```\nGet feedback amount when overdubbing (loop recording; how much to retain).",
            "```chuck\nint getVoice()\n```\nReturn an available voice (one that is not currently playing). Return -1 if no voice is available.",
            "```chuck\nint getbi(int voice)\n```\nTurn on/off bidirectional playback (voice 0).",
            "```chuck\nint loop0(int val)\n```\nTurn on/off looping (voice 0).",
            "```chuck\nint loop0()\n```\nGet looping status (voice 0).",
            "```chuck\nint loop(int voice, int val)\n```\nFor particular voice (arg 1), turn on/off looping.",
            "```chuck\nint loop(int voice)\n```\nFor particular voice (arg 1), get looping status.",
            "```chuck\ndur loopEnd(int voice, dur val)\n```\nFor particular voice (arg 1), set loop ending point for playback. only applicable when .loop(voice, 1).",
            "```chuck\ndur loopEnd(int voice)\n```\nFor particular voice (arg 1), get loop ending point for playback. only applicable when .loop(voice, 1).",
            "```chuck\ndur loopEnd(dur val)\n```\nSet loop ending point for playback (voice 0). only applicable when 1 => loop.",
            "```chuck\ndur loopEnd()\n```\nGet loop ending point for playback (voice 0). only applicable when 1 => loop.",
            "```chuck\ndur loopEndRec(dur val)\n```\nSet end point in buffer for loop recording.",
            "```chuck\ndur loopEndRec()\n```\nGet end point in buffer for loop recording.",
            "```chuck\nint loopRec(int val)\n```\nTurn on/off loop recording.",
            "```chuck\nint loopRec()\n```\nGet loop recording status.",
            "```chuck\ndur loopStart(int voice, dur val)\n```\nFor particular voice (arg 1), set loop starting point for playback. only applicable when .loop(voice, 1).",
            "```chuck\ndur loopStart(int voice)\n```\nFor particular voice (arg 1), get loop starting point for playback. only applicable when .loop(voice, 1).",
            "```chuck\ndur loopStart(dur val)\n```\nSet loop starting point for playback (voice 0). only applicable when 1 => loop.",
            "```chuck\ndur loopStart()\n```\nGet loop starting point for playback (voice 0). only applicable when 1 => loop.",
            "```chuck\nint maxVoices(int val)\n```\nSet the maximum number of voices allowable; 10 by default (256 is the current hardwired internal limit).",
            "```chuck\nint maxVoices()\n```\nGet the maximum number of voices allowable; 10 by default (256 is the current hardwired internal limit).",
            "```chuck\nfloat pan(int voice, float val)\n```\nFor particular voice (arg 1), set panning value [0.0, number of channels - 1.0].",
            "```chuck\nfloat pan(int voice)\n```\nFor particular voice (arg 1), get panning value.",
            "```chuck\nfloat pan(float val)\n```\nFor voice 0, set panning value [0.0, number of channels - 1.0].",
            "```chuck\nfloat pan()\n```\nFor voice 0, get panning value.",
            "```chuck\nint play(int voice, int toggle)\n```\nFor particular voice (arg 1), turn on/off sample playback.",
            "```chuck\nint play(int toggle)\n```\nTurn on/off sample playback (voice 0)",
            "```chuck\ndur playPos(int voice, dur val)\n```\nFor particular voice (arg 1), set playback position.",
            "```chuck\ndur playPos(int voice)\n```\nFor particular voice (arg 1), get playback position.",
            "```chuck\ndur playPos(dur val)\n```\nSet playback position (voice 0).",
            "```chuck\ndur playPos()\n```\nGet playback position (voice 0).",
            "```chuck\nint playing(int val)\n```\nGet playing status.",
            "```chuck\nvoid rampDown(int voice, dur val)\n```\nFor particular voice (arg 1), turn off sample playback, with ramp.",
            "```chuck\nvoid rampDown(dur val)\n```\nTurn off sample playback, with ramp (voice 0).",
            "```chuck\nvoid rampUp(int voice, dur val)\n```\nFor particular voice (arg 1), turn on sample playback, with ramp.",
            "```chuck\nvoid rampUp(dur val)\n```\nTurn on sample playback, with ramp (voice 0).",
            "```chuck\nfloat rate(int voice, float val)\n```\nFor particular voice (arg 1), set playback rate.",
            "```chuck\nfloat rate(int voice)\n```\nFor particular voice (arg 1), get playback rate.",
            "```chuck\nfloat rate(float val)\n```\nSet playback rate (voice 0). Note that the int/float type for this method will determine whether the rate is being set (float, for voice 0) or read (int, for voice number).",
            "```chuck\nfloat rate()\n```\nGet playback rate (voice 0).",
            "```chuck\ndur recPos(dur val)\n```\nSet record position.",
            "```chuck\ndur recPos()\n```\nGet record position.",
            "```chuck\ndur recRamp(dur val)\n```\nSet ramping when recording (from 0 to loopEndRec).",
            "```chuck\nint record(int toggle)\n```\nTurn recording on and off.",
            "```chuck\nint sync(int val)\n```\nSet input mode; (0) input is recorded to internal buffer, (1) input sets playback position [0,1] (phase value between loopStart and loopEnd for all active voices), (2) input sets playback position, interpreted as a time value in samples (only works with voice 0)",
            "```chuck\nint sync()\n```\nGet input mode; (0) input is recorded to internal buffer, (1) input sets playback position [0,1] (phase value between loopStart and loopEnd for all active voices), (2) input sets playback position, interpreted as a time value in samples (only works with voice 0)",
            "```chuck\nint track(int val)\n```\nIdentical to sync.",
            "```chuck\nint track()\n```\nIdentical to sync.",
            "```chuck\ndur value(int voice, dur val)\n```\nFor particular voice (arg 1), get value from the voice.",
            "```chuck\ndur value(dur val)\n```\nGet value from voice 0.",
            "```chuck\nfloat valueAt(float val, dur index)\n```\nSet value directly in record buffer.",
            "```chuck\nfloat valueAt(dur index)\n```\nGet value directly from record buffer.",
            "```chuck\nfloat voiceGain(int voice, float val)\n```\nFor particular voice (arg 1), set gain.",
            "```chuck\nfloat voiceGain(int voice)\n```\nSet playback gain (voice 0).",
            "```chuck\nfloat voicePan(int voice, float val)\n```\nFor particular voice (arg 1), set panning value [0.0, number of channels - 1.0].",
            "```chuck\nfloat voicePan(int voice)\n```\nFor particular voice (arg 1), get panning value."
        ],
        "link": "[More...](https://chuck.stanford.edu/doc/reference/ugens-advanced.html#LiSa6)"
    },
    "LiSa8": {
        "title": "**Live Sampling UGen 8-channel**",
        "description": "A (li)ve (sa)mpling unit generator (8-channel edition); also popularly used for granular synthesis.",
        "constructors": [
            "**Constructors:**",
            "```chuck\nLiSa8()\n```\nDefault constructor for LiSa8."
        ],
        "examples": [],
        "functions": [
            "**Methods:**",
            "```chuck\nint bi(int voice, int val)\n```\nFor particular voice (arg 1), turn on/off bidirectional playback.",
            "```chuck\nint bi(int val)\n```\nFor particular voice (arg 1), get bidirectional playback status.",
            "```chuck\nint bi()\n```\nGet birectional playback status.",
            "```chuck\nvoid clear()\n```\nClear recording buffer.",
            "```chuck\ndur duration(dur val)\n```\nSet buffer size; required to allocate memory, also resets all parameter values to default.",
            "```chuck\ndur duration()\n```\nGet buffer size.",
            "```chuck\nfloat feedback(float val)\n```\nSet feedback amount when overdubbing (loop recording; how much to retain).",
            "```chuck\nfloat feedback()\n```\nGet feedback amount when overdubbing (loop recording; how much to retain).",
            "```chuck\nint getVoice()\n```\nReturn an available voice (one that is not currently playing). Return -1 if no voice is available.",
            "```chuck\nint getbi(int voice)\n```\nTurn on/off bidirectional playback (voice 0).",
            "```chuck\nint loop0(int val)\n```\nTurn on/off looping (voice 0).",
            "```chuck\nint loop0()\n```\nGet looping status (voice 0).",
            "```chuck\nint loop(int voice, int val)\n```\nFor particular voice (arg 1), turn on/off looping.",
            "```chuck\nint loop(int voice)\n```\nFor particular voice (arg 1), get looping status.",
            "```chuck\ndur loopEnd(int voice, dur val)\n```\nFor particular voice (arg 1), set loop ending point for playback. only applicable when .loop(voice, 1).",
            "```chuck\ndur loopEnd(int voice)\n```\nFor particular voice (arg 1), get loop ending point for playback. only applicable when .loop(voice, 1).",
            "```chuck\ndur loopEnd(dur val)\n```\nSet loop ending point for playback (voice 0). only applicable when 1 => loop.",
            "```chuck\ndur loopEnd()\n```\nGet loop ending point for playback (voice 0). only applicable when 1 => loop.",
            "```chuck\ndur loopEndRec(dur val)\n```\nSet end point in buffer for loop recording.",
            "```chuck\ndur loopEndRec()\n```\nGet end point in buffer for loop recording.",
            "```chuck\nint loopRec(int val)\n```\nTurn on/off loop recording.",
            "```chuck\nint loopRec()\n```\nGet loop recording status.",
            "```chuck\ndur loopStart(int voice, dur val)\n```\nFor particular voice (arg 1), set loop starting point for playback. only applicable when .loop(voice, 1).",
            "```chuck\ndur loopStart(int voice)\n```\nFor particular voice (arg 1), get loop starting point for playback. only applicable when .loop(voice, 1).",
            "```chuck\ndur loopStart(dur val)\n```\nSet loop starting point for playback (voice 0). only applicable when 1 => loop.",
            "```chuck\ndur loopStart()\n```\nGet loop starting point for playback (voice 0). only applicable when 1 => loop.",
            "```chuck\nint maxVoices(int val)\n```\nSet the maximum number of voices allowable; 10 by default (256 is the current hardwired internal limit).",
            "```chuck\nint maxVoices()\n```\nGet the maximum number of voices allowable; 10 by default (256 is the current hardwired internal limit).",
            "```chuck\nfloat pan(int voice, float val)\n```\nFor particular voice (arg 1), set panning value [0.0, number of channels - 1.0].",
            "```chuck\nfloat pan(int voice)\n```\nFor particular voice (arg 1), get panning value.",
            "```chuck\nfloat pan(float val)\n```\nFor voice 0, set panning value [0.0, number of channels - 1.0].",
            "```chuck\nfloat pan()\n```\nFor voice 0, get panning value.",
            "```chuck\nint play(int voice, int toggle)\n```\nFor particular voice (arg 1), turn on/off sample playback.",
            "```chuck\nint play(int toggle)\n```\nTurn on/off sample playback (voice 0)",
            "```chuck\ndur playPos(int voice, dur val)\n```\nFor particular voice (arg 1), set playback position.",
            "```chuck\ndur playPos(int voice)\n```\nFor particular voice (arg 1), get playback position.",
            "```chuck\ndur playPos(dur val)\n```\nSet playback position (voice 0).",
            "```chuck\ndur playPos()\n```\nGet playback position (voice 0).",
            "```chuck\nint playing(int val)\n```\nGet playing status.",
            "```chuck\nvoid rampDown(int voice, dur val)\n```\nFor particular voice (arg 1), turn off sample playback, with ramp.",
            "```chuck\nvoid rampDown(dur val)\n```\nTurn off sample playback, with ramp (voice 0).",
            "```chuck\nvoid rampUp(int voice, dur val)\n```\nFor particular voice (arg 1), turn on sample playback, with ramp.",
            "```chuck\nvoid rampUp(dur val)\n```\nTurn on sample playback, with ramp (voice 0).",
            "```chuck\nfloat rate(int voice, float val)\n```\nFor particular voice (arg 1), set playback rate.",
            "```chuck\nfloat rate(int voice)\n```\nFor particular voice (arg 1), get playback rate.",
            "```chuck\nfloat rate(float val)\n```\nSet playback rate (voice 0). Note that the int/float type for this method will determine whether the rate is being set (float, for voice 0) or read (int, for voice number).",
            "```chuck\nfloat rate()\n```\nGet playback rate (voice 0).",
            "```chuck\ndur recPos(dur val)\n```\nSet record position.",
            "```chuck\ndur recPos()\n```\nGet record position.",
            "```chuck\ndur recRamp(dur val)\n```\nSet ramping when recording (from 0 to loopEndRec).",
            "```chuck\nint record(int toggle)\n```\nTurn recording on and off.",
            "```chuck\nint sync(int val)\n```\nSet input mode; (0) input is recorded to internal buffer, (1) input sets playback position [0,1] (phase value between loopStart and loopEnd for all active voices), (2) input sets playback position, interpreted as a time value in samples (only works with voice 0)",
            "```chuck\nint sync()\n```\nGet input mode; (0) input is recorded to internal buffer, (1) input sets playback position [0,1] (phase value between loopStart and loopEnd for all active voices), (2) input sets playback position, interpreted as a time value in samples (only works with voice 0)",
            "```chuck\nint track(int val)\n```\nIdentical to sync.",
            "```chuck\nint track()\n```\nIdentical to sync.",
            "```chuck\ndur value(int voice, dur val)\n```\nFor particular voice (arg 1), get value from the voice.",
            "```chuck\ndur value(dur val)\n```\nGet value from voice 0.",
            "```chuck\nfloat valueAt(float val, dur index)\n```\nSet value directly in record buffer.",
            "```chuck\nfloat valueAt(dur index)\n```\nGet value directly from record buffer.",
            "```chuck\nfloat voiceGain(int voice, float val)\n```\nFor particular voice (arg 1), set gain.",
            "```chuck\nfloat voiceGain(int voice)\n```\nSet playback gain (voice 0).",
            "```chuck\nfloat voicePan(int voice, float val)\n```\nFor particular voice (arg 1), set panning value [0.0, number of channels - 1.0].",
            "```chuck\nfloat voicePan(int voice)\n```\nFor particular voice (arg 1), get panning value."
        ],
        "link": "[More...](https://chuck.stanford.edu/doc/reference/ugens-advanced.html#LiSa8)"
    },
    "MFCC": {
        "title": "**Mel-Frequency Cepstral Coefficients**",
        "description": "A unit analyzer that computes Mel-frequency Cepstral Coefficients (MFCCs), and outputs a vector of coefficients.",
        "constructors": [
            "**Constructors:**",
            "```chuck\nMFCC()\n```\nDefault constructor for MFCC."
        ],
        "examples": [
            "Examples: \t [mfcc-basic.ck](https://chuck.stanford.edu/doc/examples/ai/features/mfcc-basic.ck), [mfcc-mean.ck](https://chuck.stanford.edu/doc/examples/ai/features/mfcc-mean.ck), [feature-extract.ck](https://chuck.stanford.edu/doc/examples/ai/genre-classify/feature-extract.ck), [genre-classify.ck](https://chuck.stanford.edu/doc/examples/ai/genre-classify/genre-classify.ck)"
        ],
        "functions": [
            "**Methods:**",
            "```chuck\nfloat compute(float[] input, float[] output)\n```\nManually computes the MFCC of the input (an FFT spectrum), and stores the results in the output array (MFCC coefficients).",
            "```chuck\nint numCoeffs(int n)\n```\nSet the number of MFCC coefficients to compute.",
            "```chuck\nint numCoeffs()\n```\nGet the number of MFCC coefficients to compute.",
            "```chuck\nint numFilters(int n)\n```\nSet the number of linearly spaced filters in MEL space.",
            "```chuck\nint numFilters()\n```\nGet the number of linearly spaced filters in MEL space.",
            "```chuck\nint sampleRate(int sr)\n```\nSet the sample rate for MFCC analysis; NOTE: by default this is set to current ChucK sample rate.",
            "```chuck\nint sampleRate()\n```\nGet the sample rate for MFCC analysis."
        ],
        "link": "[More...](https://chuck.stanford.edu/doc/reference/uanae.html#MFCC)"
    },
    "MLP": {
        "title": "**Multi-Layer Perceptron**",
        "description": "A multilayer perceptron (MLP)--a basic artificial neural network--that maps an input layer to an output layer across a number of fully-connected hidden layers. This implementation can be trained either 1) by using one of the comprehensive .train() functions OR 2) by iteratively calling .forward() and .backprop() for each input-output observation, and using .shuffle() for each epoch. Commonly used for regression or classification.",
        "constructors": [
            "**Constructors:**",
            "```chuck\nMLP()\n```\nDefault constructor for MLP."
        ],
        "examples": [
            "Examples: \t [mlp.ck](https://chuck.stanford.edu/doc/examples/ai/mlp/mlp.ck), [mlp-manual.ck](https://chuck.stanford.edu/doc/examples/ai/mlp/mlp-manual.ck), [model-load.ck](https://chuck.stanford.edu/doc/examples/ai/mlp/model-load.ck), [model-save.ck](https://chuck.stanford.edu/doc/examples/ai/mlp/model-save.ck)"
        ],
        "functions": [
            "**Methods:**",
            "```chuck\nvoid backprop(float[] output, float learningRate)\n```\n(Manually) backpropagate from the output layer, for a single input-output observation; compute the gradient of the loss function with respect to the weights in the network, one layer at a time.",
            "```chuck\nvoid forward(float[] input)\n```\n(Manually) forward-propagate the input vector through the network.",
            "```chuck\nvoid getActivations(int layer, float[] activations)\n```\nGet the activations of the given layer, after a manual .forward().",
            "```chuck\nvoid getBiases(int layer, float[] biases)\n```\nGet the biases of the given layer.",
            "```chuck\nvoid getGradients(int layer, float[] gradients)\n```\nGet the gradients of the given layer, after a manual .backprop().",
            "```chuck\nvoid getWeights(int layer, float[][] weights)\n```\nGet the weights of the given layer.",
            "```chuck\nvoid init(int[] nodesPerLayer)\n```\nInitialize the MLP with the given number of nodes per layer.",
            "```chuck\nvoid init(int[] nodesPerLayer, int[] activationPerLayer)\n```\nInitialize the MLP with the given number of nodes per layer and the given activation function per layer, as specified in 'activationPerLayer' (options: AI.Linear, AI.Sigmoid, AI.ReLU, AI.Tanh, or AI.Softmax).",
            "```chuck\nvoid init(int[] nodesPerLayer, int activationFunction)\n```\nInitialize the MLP with the given number of nodes per layer and the given activation function for all layers (options: AI.Linear, AI.Sigmoid, AI.ReLU, AI.Tanh, or AI.Softmax).",
            "```chuck\nint load(string filename)\n```\nLoad a MLP model from file.",
            "```chuck\nint predict(float[] input, float[] output)\n```\nPredict the output layer from an input layer.",
            "```chuck\nint save(string filename)\n```\nSave the MLP model to file.",
            "```chuck\nvoid train(float[][] inputs, float[][] outputs)\n```\nTrain the MLP with the given input and output observations with default learning rate=.01 and epochs=100. (Also see MLP.train(inputs,outputs,learningRate,epochs).)",
            "```chuck\nvoid train(float[][] inputs, float[][] outputs, float learningRate, int epochs)\n```\nTrain the MLP with the given input and output observations, the learning rate, and number of epochs.",
            "```chuck\nvoid shuffle(float[][] X, float[][] Y)\n```\n(Manually) shuffle the given input and output vectors."
        ],
        "link": "[More...](https://chuck.stanford.edu/doc/reference/ai.html#MLP)"
    },
    "Machine": {
        "title": "**ChucK Virtual Machine Interface**",
        "description": "Machine is the runtime interface to the ChucK Virtual Machine (Ck.VM or simply VM). This interface can be used to manage shreds, evaluate code, set log levels, etc. Machine's shred commands (add, replace, remove, etc.) are similar to the on-the-fly programming commands, except these are invoked from within a ChucK program, and benefit from ChucK's strongly-timed mechanics.",
        "constructors": [],
        "examples": [
            "Examples: \t [eval.ck](https://chuck.stanford.edu/doc/examples/machine/eval.ck), [eval-global.ck](https://chuck.stanford.edu/doc/examples/machine/eval-global.ck), [intsize.ck](https://chuck.stanford.edu/doc/examples/machine/intsize.ck), [is-realtime.ck](https://chuck.stanford.edu/doc/examples/machine/is-realtime.ck), [machine-help.ck](https://chuck.stanford.edu/doc/examples/machine/machine-help.ck), [machine-shred.ck](https://chuck.stanford.edu/doc/examples/machine/machine-shred.ck), [version.ck](https://chuck.stanford.edu/doc/examples/machine/version.ck), [DrumMachine](https://chuck.stanford.edu/doc/examples/book/digital-artists/chapter9/DrumMachine), [initialize.ck](https://chuck.stanford.edu/doc/examples/book/digital-artists/chapter9/SmartMandolin/initialize.ck)"
        ],
        "functions": [
            "**Methods:**",
            "```chuck\nint add(string path)\n```\nCompile and spork a new shred from file at 'path' into the VM; returns the new shred ID. It is possible to include arguments with the file being added, e.g., `Machine.add( \"foo.ck:bar:3:5.0\" )`.",
            "```chuck\nvoid clearVM()\n```\nReset the type system, removing all user-defined types and all global variables; removes all shreds in the VM (including the shred calling this function); use with care.",
            "```chuck\nvoid crash()\n```\nExplicitly crash the virtual machine. The very last resort; or an emphatic gesture. Use with care.",
            "```chuck\nint eval(string code)\n```\nEvaluate a string as ChucK code, compile it and immediately spork it as a new independent shred, and automatically yield the current shred to give the new shred a chance to run, without advancing time.",
            "```chuck\nint eval(string code, string args)\n```\nEvaluate a string as ChucK code, with arguments (bundled in 'args' as \"ARG1:ARG2:...\", compile it and immediately spork it as a new independent shred, and automatically yield the current shred to give the new shred a chance to run, without advancing time.",
            "```chuck\nint eval(string code, string args, int count)\n```\nEvaluate a string as ChucK code, with optional arguments (bundled in 'args' as \"ARG1:ARG2:...\", compile it and immediately spork 'count' independent shreds; and automatically yield the current shred to give all new shreds a chance to run, without advancing time.",
            "```chuck\nint intsize()\n```\nReturn the bit size of an integer.",
            "```chuck\nint loglevel(int level)\n```\nSet log level    |- 0: NONE    |- 1: CORE    |- 2: SYSTEM    |- 3: HERALD    |- 4: WARNING    |- 5: INFO    |- 6: DEBUG    |- 7: FINE    |- 8: FINER    |- 9: FINEST    |- 10: ALL.",
            "```chuck\nint loglevel()\n```\nGet log level.",
            "```chuck\nint numShreds()\n```\nGet the number of shreds currently in the VM.",
            "```chuck\nvoid printStatus()\n```\nPrint (to terminal or console) the current status of the VM.",
            "```chuck\nvoid printTimeCheck()\n```\nPrint (to terminal or console) the current time information in the VM.",
            "```chuck\nint realtime()\n```\nReturn true if the shred is in realtime mode, false if it's in silent mode (i.e. --silent is enabled)",
            "```chuck\nint refcount(Object obj)\n```\nGet an object's current internal reference count; this is intended for testing or curiosity; NOTE: this function intentionally does not take into account any reference counting related to the calling of this function (normally all functions increments the reference count for objects passed as arguments and decrements upon returning)",
            "```chuck\nint remove(int id)\n```\nRemove shred from VM by shred ID (returned by Machine.add).",
            "```chuck\nvoid removeAllShreds()\n```\nRemove all shreds in the VM (including the shred calling this function).",
            "```chuck\nint removeLastShred()\n```\nRemove the most recently added shred in the VM (could be the shred calling this function); returns the ID of the removed shred.",
            "```chuck\nint replace(int id, string path)\n```\nReplace shred with new shred from file. Returns new shred ID, or 0 on error. It is possible to include arguments, e.g., `Machine.replace( outID, \"foo.ck:bar:3:5.0\" )`.",
            "```chuck\nvoid resetOperators()\n```\nReset operator overloading state to default startup state; removes all public @operator overloads; use with care.",
            "```chuck\nint resetShredID()\n```\nReset shred IDs to 1 + the highest current shred ID in the VM; can be used as shred management to keep shred IDs low, after a lot of sporks; returns what the next shred ID would be.",
            "```chuck\nint[] shreds()\n```\nRetrieve an array of active shred ids.",
            "```chuck\nint silent()\n```\nReturn false if the shred is in realtime mode, true if it's in silent mode (i.e. --silent is enabled)",
            "```chuck\nint sp_mem()\n```\nGet the calling shred's memory (aka \"mem\") stack pointer; intended for either debugging or curiosity.",
            "```chuck\nint sp_reg()\n```\nGet the calling shred's operand (aka \"reg\"/register) stack pointer; intended for either debugging or curiosity.",
            "```chuck\nint status()\n```\nPrint the current status of the VM; legacy version of printStatus().",
            "```chuck\nstring version()\n```\nReturn language and VM version string."
        ],
        "link": "[More...](https://chuck.stanford.edu/doc/reference/base.html#Machine)"
    },
    "MagicSine": {
        "title": "**Magic Sine Oscillator**",
        "description": "Fast, recursive sine wave generator using the so-called &quot;magic circle&quot; algorithm (see <a href=\"https://ccrma.stanford.edu/~jos/pasp/Digital_Sinusoid_Generators.html\">https://ccrma.stanford.edu/~jos/pasp/Digital_Sinusoid_Generators.html</a>). Can be 30-40% faster than regular SinOsc. Frequency modulation will negate this performance benefit; most useful when pure sine tones are desired or for additive synthesis.",
        "constructors": [
            "**Constructors:**",
            "```chuck\nMagicSine()\n```\n"
        ],
        "examples": [],
        "functions": [
            "**Methods:**",
            "```chuck\nfloat freq(float arg)\n```\nOscillator frequency [Hz].",
            "```chuck\nfloat freq()\n```\nOscillator frequency [Hz]."
        ],
        "link": "[More...](https://chuck.stanford.edu/doc/reference/chugins.html#MagicSine)"
    },
    "Mandolin": {
        "title": "**STK Mandolin**",
        "description": "This class inherits from PluckTwo and uses 'commuted synthesis' techniques to model a mandolin instrument. This is a digital waveguide model, making its use possibly subject to patents held by Stanford University, Yamaha, and others. Commuted Synthesis, in particular, is covered by patents, granted, pending, and/or applied-for. All are assigned to the Board of Trustees, Stanford University. For information, contact the Office of Technology Licensing, Stanford University. Control Change Numbers: - Body Size = 2 - Pluck Position = 4 - String Sustain = 11 - String Detuning = 1 - Microphone Position = 128 by Perry R. Cook and Gary P. Scavone, 1995 - 2002.",
        "constructors": [
            "**Constructors:**",
            "```chuck\nMandolin()\n```\nDefault constructor for Mandolin."
        ],
        "examples": [
            "Examples: \t [mandolin.ck](https://chuck.stanford.edu/doc/examples/stk/mandolin.ck), [mand-o-matic.ck](https://chuck.stanford.edu/doc/examples/stk/mand-o-matic.ck), [mand-o-matic-simple.ck](https://chuck.stanford.edu/doc/examples/stk/mand-o-matic-simple.ck)"
        ],
        "functions": [
            "**Methods:**",
            "```chuck\nfloat afterTouch(float value)\n```\nSet aftertouch (currently unsupported).",
            "```chuck\nstring bodyIR(string path)\n```\nSet body impulse response.",
            "```chuck\nstring bodyIR()\n```\nGet body impulse response.",
            "```chuck\nfloat bodySize(float value)\n```\nSet body size (percentage).",
            "```chuck\nfloat bodySize()\n```\nGet body size (percentage).",
            "```chuck\nfloat pluck(float value)\n```\nPluck instrument, [0.0-1.0].",
            "```chuck\nfloat pluckPos(float value)\n```\nSet pluck position, [0.0-1.0].",
            "```chuck\nfloat pluckPos()\n```\nGet pluck position, [0.0-1.0].",
            "```chuck\nfloat stringDamping(float value)\n```\nSet string damping, [0.0-1.0].",
            "```chuck\nfloat stringDamping()\n```\nGet string damping, [0.0-1.0].",
            "```chuck\nfloat stringDetune(float value)\n```\nSet detuning of string pair, [0.0-1.0].",
            "```chuck\nfloat stringDetune()\n```\nGet detuning of string pair, [0.0-1.0]."
        ],
        "link": "[More...](https://chuck.stanford.edu/doc/reference/ugens-stk.html#Mandolin)"
    },
    "Math": {
        "title": "**Math Class Library**",
        "description": "Math class library.",
        "constructors": [],
        "examples": [
            "Examples: \t [blit2.ck](https://chuck.stanford.edu/doc/examples/basic/blit2.ck), [mand-o-matic.ck](https://chuck.stanford.edu/doc/examples/stk/mand-o-matic.ck), [randomize.ck](https://chuck.stanford.edu/doc/examples/math/randomize.ck), [maybe.ck](https://chuck.stanford.edu/doc/examples/math/maybe.ck), [int-dist.ck](https://chuck.stanford.edu/doc/examples/math/int-dist.ck), [map.ck](https://chuck.stanford.edu/doc/examples/math/map.ck)"
        ],
        "functions": [
            "**Methods:**",
            "```chuck\nint abs(int value)\n```\nReturn absolute value of an integer value.",
            "```chuck\nfloat acos(float x)\n```\nCompute arccosine of x; result in [0, pi].",
            "```chuck\nfloat asin(float x)\n```\nCompute arcsine of x; result in [-pi/2, +pi/2].",
            "```chuck\nfloat atan2(float y, float x)\n```\nCompute arc tangent of two variables (y/x).",
            "```chuck\nfloat atan(float x)\n```\nCompute arctangent of x; result in [-pi/2, +pi/2].",
            "```chuck\nfloat ceil(float x)\n```\nReturn the smallest integer value (returned as float) not less than x.",
            "```chuck\nfloat clampf(float value, float min, float max)\n```\nClamp a float to range [min,max].",
            "```chuck\nint clampi(int value, int min, int max)\n```\nClamp an integer to range [min,max].",
            "```chuck\nfloat cos(float x)\n```\nCompute cosine of x (measured in radians).",
            "```chuck\nfloat cosh(float x)\n```\nCompute the hyperbolic cosine of x.",
            "```chuck\nfloat cossim(float[] a, float[] b)\n```\nCompute the cosine similarity between arrays a and b.",
            "```chuck\nfloat cossim(vec3 a, vec3 b)\n```\nCompute the cosine similarity between 3D vectors a and b.",
            "```chuck\nfloat cossim(vec4 a, vec4 b)\n```\nCompute the cosine similarity between 4D vectors a and b.",
            "```chuck\nfloat dbtopow(float value)\n```\nConvert decibels (dB) to signal power ratio.",
            "```chuck\nfloat dbtorms(float value)\n```\nConvert decibles (dB) to linear amplitude.",
            "```chuck\nint ensurePow2(int x)\n```\nReturn the smallest power-of-2 greater than or equal to the value of x.",
            "```chuck\nint equal(float x, float y)\n```\nReturn whether two floats are considered equal.",
            "```chuck\nfloat euclidean(float[] a, float[] b)\n```\nCompute the euclidean distance between arrays a and b.",
            "```chuck\nfloat euclidean(vec2 a, vec2 b)\n```\nCompute the euclidean distance between 2D vectors a and b.",
            "```chuck\nfloat euclidean(vec3 a, vec3 b)\n```\nCompute the euclidean distance between 3D vectors a and b.",
            "```chuck\nfloat euclidean(vec4 a, vec4 b)\n```\nCompute the euclidean distance between 4D vectors a and b.",
            "```chuck\nfloat exp2(float x)\n```\nCompute 2^x, the base-2 exponential of x.",
            "```chuck\nfloat exp(float x)\n```\nCompute e^x, the base-e exponential of x.",
            "```chuck\nfloat fabs(float value)\n```\nReturn absolute value of a floating point value.",
            "```chuck\nfloat floor(float x)\n```\nReturn the largest integer value (returned as float) not greater than x.",
            "```chuck\nfloat fmod(float x, float y)\n```\nCompute the floating-point remainder of x / y.",
            "```chuck\nfloat ftom(float value)\n```\nConvert frequency (Hz) to MIDI note number space.",
            "```chuck\nfloat gauss(float x, float mean, float sd)\n```\nCompute gaussian function at x, given mean and SD.",
            "```chuck\nfloat hypot(float x, float y)\n```\nCompute the euclidean distance sqrt(x*x+y*y).",
            "```chuck\nfloat im(complex v)\n```\nReturn the imaginary component of complex value v.",
            "```chuck\nint isinf(float x)\n```\nReturn true if x is infinity, else return false.",
            "```chuck\nint isnan(float x)\n```\nReturn true if x is not a number, else return false.",
            "```chuck\nfloat log10(float x)\n```\nCompute the logarithm of x to base 10.",
            "```chuck\nfloat log2(float x)\n```\nCompute the logarithm of x to base 2.",
            "```chuck\nfloat log(float x)\n```\nCompute the natural logarithm of x.",
            "```chuck\nfloat mag(polar v)\n```\nReturn the magnitude component of polar value v.",
            "```chuck\nfloat map2(float value, float x1, float y1, float x2, float y2)\n```\nMap 'value' from range [x1,y1] into range [x2,y2]; 'value' will be clamped to [x1,y1] if outside range. (see also: Math.map())",
            "```chuck\nfloat map(float value, float x1, float y1, float x2, float y2)\n```\nMap 'value' from range [x1,y1] into range [x2,y2]; 'value' can be outside range[x1,y1]. (see also: Math.map2())",
            "```chuck\nint max(int x, int y)\n```\nReturn the greater of x and y (integer).",
            "```chuck\nfloat max(float x, float y)\n```\nReturn the greater of x and y (float).",
            "```chuck\nint min(int x, int y)\n```\nReturn the lesser of x and y (int).",
            "```chuck\nfloat min(float x, float y)\n```\nReturn the lesser of x and y (float).",
            "```chuck\nfloat mtof(float value)\n```\nConvert a MIDI note number to frequency (Hz). Note that the input value is of type float and supports fractional note numbers.",
            "```chuck\nint nextpow2(int x)\n```\nCompute the smallest power-of-2 greater than x.",
            "```chuck\nfloat phase(polar v)\n```\nReturn the phase component of polar value v.",
            "```chuck\nfloat pow(float x, float y)\n```\nCompute x raised to the y-th power.",
            "```chuck\nfloat powtodb(float value)\n```\nConvert signal power ratio to decibels (dB).",
            "```chuck\nint ptor(polar[] from, complex[] to)\n```\nConvert polar values to complex values; returns number of values converted.",
            "```chuck\nint random2(int min, int max)\n```\nReturn successive pseudo-random numbers in the range [min, max].",
            "```chuck\nfloat random2f(float min, float max)\n```\nReturn successive pseudo-random floating-point numbers in the range [min, max].",
            "```chuck\nint random()\n```\nReturn successive pseudo-random integer numbers in the range [0, Math.RANDOM_MAX]].",
            "```chuck\nfloat randomf()\n```\nReturn successive pseudo-random floating-point numbers in the range [0,1].",
            "```chuck\nvoid randomize()\n```\nRandomize the seed of the random number generator (RNG), using an non-deterministic mechanism. Whereas srandom() explicitly seeds the RNG and will produce a deterministic sequence of pseudo-random numbers, randomize() \"shakes things up\" and causes RNG to start generating from a practically unpredicable seed. The quality of randomize() depends on the underlying implementation.",
            "```chuck\nfloat re(complex v)\n```\nReturn the real component of complex value v.",
            "```chuck\nfloat remainder(float x, float y)\n```\nCompute the value r such that r=x-n*y, where n is the integer nearest the exact value of x / y. If there are two integers closest to x / y, n shall be the even one. If r is zero, it is given the same sign as x.",
            "```chuck\nfloat remap(float value, float x1, float y1, float x2, float y2)\n```\nSame as Math.map2().",
            "```chuck\nfloat rmstodb(float value)\n```\nConvert linear amplitude to decibels (dB).",
            "```chuck\nfloat round(float x)\n```\nReturn the integer value (returned as float) nearest to x (rounding halfway cases away from zero).",
            "```chuck\nint rtop(complex[] from, polar[] to)\n```\nConvert complex values to polar values; returns number of values converted.",
            "```chuck\nfloat sgn(float value)\n```\nReturn sign of 'value' as -1.0 (negative), 0.0, or 1.0 (positive).",
            "```chuck\nfloat sin(float x)\n```\nCompute sine of x (measured in radians).",
            "```chuck\nfloat sinh(float x)\n```\nCompute the hyperbolic sine of x.",
            "```chuck\nfloat sqrt(float x)\n```\nCompute the non-negative square root of x.",
            "```chuck\nvoid srandom(int seed)\n```\nSeed the random number generator (RNG). Different seeds will generate very different sequences of random numbers even if the seeds are close together. Alternatively, a deterministic sequence of pseudo-random numbers can repeatably generated by setting the same seed.",
            "```chuck\nfloat tan(float x)\n```\nCompute tangent of x (measured in radians).",
            "```chuck\nfloat tanh(float x)\n```\nCompute the hyperbolic tangent of x.",
            "```chuck\nfloat trunc(float x)\n```\nReturn the integer value nearest to but no greater in magnitude than x."
        ],
        "link": "[More...](https://chuck.stanford.edu/doc/reference/base.html#Math)"
    },
    "Mesh2D": {
        "title": "**2D Digital Waveguide Mesh**",
        "description": "This class implements a rectilinear, two-dimensional digital waveguide mesh structure. For details, see Van Duyne and Smith, &quot;Physical Modeling with the 2-D Digital Waveguide Mesh,&quot; <i>Proceedings of the 1993 International Computer Music Conference</i>. <br/><br/>This is a digital waveguide model, making its use possibly subject to patents held by Stanford University, Yamaha, and others.",
        "constructors": [
            "**Constructors:**",
            "```chuck\nMesh2D()\n```\n"
        ],
        "examples": [
            "Examples: \t [Mesh2D.ck](https://chuck.stanford.edu/doc/examples/special/Mesh2D.ck)"
        ],
        "functions": [
            "**Methods:**",
            "```chuck\nfloat decay()\n```\nDecay constant (0 = instant decay, 1.0 = long decay time).",
            "```chuck\nfloat decay(float arg)\n```\nDecay constant (0 = instant decay, 1.0 = long decay time).",
            "```chuck\nfloat noteOff(float arg)\n```\nRelease the model.",
            "```chuck\nfloat noteOn(float arg)\n```\nTrigger the mesh with given amplitude.",
            "```chuck\nint x()\n```\nX dimension of &quot;plate&quot; (max 12).",
            "```chuck\nint x(int arg)\n```\nX dimension of &quot;plate&quot; (max 12).",
            "```chuck\nfloat xpos()\n```\nStrike x position (appears to be on range (0.0, 2.0)).",
            "```chuck\nfloat xpos(float arg)\n```\nStrike x position (appears to be on range (0.0, 2.0)).",
            "```chuck\nint y()\n```\nY dimension of &quot;plate&quot; (max 12).",
            "```chuck\nint y(int arg)\n```\nY dimension of &quot;plate&quot; (max 12).",
            "```chuck\nfloat ypos()\n```\nStrike y position (appears to be on range (0.0, 2.0)).",
            "```chuck\nfloat ypos(float arg)\n```\nStrike y position (appears to be on range (0.0, 2.0))."
        ],
        "link": "[More...](https://chuck.stanford.edu/doc/reference/chugins.html#Mesh2D)"
    },
    "MidiFileIn": {
        "title": "**MIDI File Input**",
        "description": "Class for reading data from a MIDI file.",
        "constructors": [
            "**Constructors:**",
            "```chuck\nMidiFileIn()\n```\nDefault constructor for MidiFileIn."
        ],
        "examples": [
            "Examples: \t [midifile-play.ck](https://chuck.stanford.edu/doc/examples/midi/midifile-play.ck), [bwv772.mid](https://chuck.stanford.edu/doc/examples/midi/bwv772.mid)"
        ],
        "functions": [
            "**Methods:**",
            "```chuck\nvoid close()\n```\nClose the MIDI file.",
            "```chuck\nint numTracks()\n```\nGet the number of tracks in the open MIDI file.",
            "```chuck\nint open(string path)\n```\nOpen a MIDI file.",
            "```chuck\nint read(MidiMsg msg)\n```\nRead next MIDI Event (on default track 0); return contents in 'msg'.",
            "```chuck\nint read(MidiMsg msg, int track)\n```\nRead next MIDI Event on track 'track'; return contents in 'msg'.",
            "```chuck\nvoid rewind()\n```\nRewind MIDI reader to beginning of default track 0.",
            "```chuck\nvoid rewind(int track)\n```\nRewind MIDI reader to beginning of track 'track'."
        ],
        "link": "[More...](https://chuck.stanford.edu/doc/reference/io.html#MidiFileIn)"
    },
    "MidiIn": {
        "title": "**MIDI Input**",
        "description": "Class that can be ChucKed to now as an event. When receiving a message, an event is signaled and Midi information can be read.",
        "constructors": [
            "**Constructors:**",
            "```chuck\nMidiIn()\n```\nDefault constructor for MidiIn."
        ],
        "examples": [
            "Examples: \t [gomidi.ck](https://chuck.stanford.edu/doc/examples/midi/gomidi.ck), [gomidi2.ck](https://chuck.stanford.edu/doc/examples/midi/gomidi2.ck), [polyfony.ck](https://chuck.stanford.edu/doc/examples/midi/polyfony.ck), [polyfony2.ck](https://chuck.stanford.edu/doc/examples/midi/polyfony2.ck)"
        ],
        "functions": [
            "**Methods:**",
            "```chuck\nint can_wait()\n```\n(internal) used by virtual machine for synthronization.",
            "```chuck\nint good()\n```\nReturn true (1) if a device has been opened for this instance and there was no error connecting to it. Return false (0) if a device has not been opened or there was an error opening a device.",
            "```chuck\nstring name()\n```\nReturn the Midi device's name as string.",
            "```chuck\nint num()\n```\nReturn the device number of the device (i.e. the number passed to MidiIn/MidiOut.open).",
            "```chuck\nint open(int port)\n```\nOpen Midi device using a port number.",
            "```chuck\nint open(string name)\n```\nOpen Midi device using the device's name.",
            "```chuck\nvoid printerr(int print_or_not)\n```\nSet error printing (1 for on, 0 for off). On by default.",
            "```chuck\nint recv(MidiMsg msg)\n```\nReturn into the MidiMsg argument the next message in the queue from the device. Return 0 if the queue is empty or 1 if a message was in the queue and returned in the argument."
        ],
        "link": "[More...](https://chuck.stanford.edu/doc/reference/io.html#MidiIn)"
    },
    "MidiMsg": {
        "title": "**MIDI Message**",
        "description": "Creates a message for sending and receiving Midi information.",
        "constructors": [
            "**Constructors:**",
            "```chuck\nMidiMsg()\n```\nDefault constructor for MidiMsg."
        ],
        "examples": [
            "Examples: \t [gomidi.ck](https://chuck.stanford.edu/doc/examples/midi/gomidi.ck), [gomidi2.ck](https://chuck.stanford.edu/doc/examples/midi/gomidi2.ck), [polyfony.ck](https://chuck.stanford.edu/doc/examples/midi/polyfony.ck), [polyfony2.ck](https://chuck.stanford.edu/doc/examples/midi/polyfony2.ck)"
        ],
        "functions": [],
        "link": "[More...](https://chuck.stanford.edu/doc/reference/io.html#MidiMsg)"
    },
    "MidiOut": {
        "title": "**MIDI Output**",
        "description": "Class for sending out MIDI messages. Note that channel numbers are 0-based.",
        "constructors": [
            "**Constructors:**",
            "```chuck\nMidiOut()\n```\nDefault constructor for MidiOut."
        ],
        "examples": [
            "Examples: \t [midiout.ck](https://chuck.stanford.edu/doc/examples/midi/midiout.ck), [midiout2.ck](https://chuck.stanford.edu/doc/examples/midi/midiout2.ck)"
        ],
        "functions": [
            "**Methods:**",
            "```chuck\nint channelPressure(int channel, int pressure)\n```\nSend out a channelPressure message.",
            "```chuck\nint controlChange(int channel, int controller, int value)\n```\nSend out a controlChange message.",
            "```chuck\nint good()\n```\nReturn true (1) if a device has been opened for this instance and there was no error connecting to it. Return false (0) if a device has not been opened or there was an error opening a device.",
            "```chuck\nstring name()\n```\nReturn the Midi device's name as string.",
            "```chuck\nint noteOff(int channel, int note, int velocity)\n```\nSend out a noteOff message.",
            "```chuck\nint noteOn(int channel, int note, int velocity)\n```\nSend out a noteOn message.",
            "```chuck\nint num()\n```\nReturn the device number of the device (i.e. the number passed to MidiIn/MidiOut.open).",
            "```chuck\nint open(int port)\n```\nOpen Midi device using a port number.",
            "```chuck\nint open(string name)\n```\nOpen Midi device using the device's name.",
            "```chuck\nint pitchBend(int channel, int value)\n```\nSend out a pitchBend message.",
            "```chuck\nint pitchBend(int channel, int lsb, int msb)\n```\nSend out a pitchBend message with fine and coarse values.",
            "```chuck\nint polyPressure(int channel, int note, int pressure)\n```\nSend out a polyPressure message.",
            "```chuck\nvoid printerr(int print_or_not)\n```\nSet error printing (1 for on, 0 for off). On by default.",
            "```chuck\nint programChange(int channel, int program)\n```\nSend out a programChange message.",
            "```chuck\nint send(int status, int data1, int data2)\n```\nSend out a MIDI message consisting of one status byte and two data bytes.",
            "```chuck\nint send(MidiMsg msg)\n```\nSend out a MIDI message using a MidiMsg."
        ],
        "link": "[More...](https://chuck.stanford.edu/doc/reference/io.html#MidiOut)"
    },
    "Mix2": {
        "title": "**Stereo to Mono UGen**",
        "description": "A stereo-to-mono unit generator for mixing stereo signal to mono.",
        "constructors": [
            "**Constructors:**",
            "```chuck\nMix2()\n```\nDefault constructor for Mix2."
        ],
        "examples": [],
        "functions": [],
        "link": "[More...](https://chuck.stanford.edu/doc/reference/ugens-basic.html#Mix2)"
    },
    "ModalBar": {
        "title": "**STK Modal Bar**",
        "description": "This class implements a number of different struck bar instruments. It inherits from the Modal class. Control Change Numbers: - Stick Hardness = 2 - Stick Position = 4 - Vibrato Gain = 11 - Vibrato Frequency = 7 - Direct Stick Mix = 1 - Volume = 128 - Modal Presets = 16 - Marimba = 0 - Vibraphone = 1 - Agogo = 2 - Wood1 = 3 - Reso = 4 - Wood2 = 5 - Beats = 6 - Two Fixed = 7 - Clump = 8 by Perry R. Cook and Gary P. Scavone, 1995 - 2002.",
        "constructors": [
            "**Constructors:**",
            "```chuck\nModalBar()\n```\nDefault constructor for ModalBar."
        ],
        "examples": [
            "Examples: \t [modalbar.ck](https://chuck.stanford.edu/doc/examples/stk/modalbar.ck), [modalbar2.ck](https://chuck.stanford.edu/doc/examples/stk/modalbar2.ck), [mode-o-matic.ck](https://chuck.stanford.edu/doc/examples/stk/mode-o-matic.ck), [mode-o-test.ck](https://chuck.stanford.edu/doc/examples/stk/mode-o-test.ck)"
        ],
        "functions": [
            "**Methods:**",
            "```chuck\nfloat clear(float value)\n```\nClear instrument.",
            "```chuck\nfloat damp(float value)\n```\nDamp bar, [0.0-1.0].",
            "```chuck\nfloat directGain(float value)\n```\nSet direct gain, [0.0-1.0].",
            "```chuck\nfloat directGain()\n```\nGet direct gain, [0.0-1.0].",
            "```chuck\nfloat masterGain(float value)\n```\nSet master gain, [0.0-1.0].",
            "```chuck\nfloat masterGain()\n```\nGet master gain, [0.0-1.0].",
            "```chuck\nint mode(int value)\n```\nSet mode.",
            "```chuck\nint mode()\n```\nGet mode.",
            "```chuck\nfloat modeGain(float value)\n```\nSet gain for selected mode, [0.0-1.0].",
            "```chuck\nfloat modeGain()\n```\nGet gain for selected mode, [0.0-1.0].",
            "```chuck\nfloat modeRadius(float value)\n```\nSet radius for selected mode, [0.0-1.0].",
            "```chuck\nfloat modeRadius()\n```\nGet radius for selected mode, [0.0-1.0].",
            "```chuck\nfloat modeRatio(float value)\n```\nSet ratio for selected mode.",
            "```chuck\nfloat modeRatio()\n```\nGet ratio for selected mode.",
            "```chuck\nint preset(int value)\n```\nSet preset (see above).",
            "```chuck\nint preset()\n```\nGet preset.",
            "```chuck\nfloat stickHardness(float value)\n```\nSet stick hardness, [0.0-1.0].",
            "```chuck\nfloat stickHardness()\n```\nGet stick hardness, [0.0-1.0].",
            "```chuck\nfloat strike(float value)\n```\nStrike bar, [0.0-1.0].",
            "```chuck\nfloat strikePosition(float value)\n```\nSet strike position, [0.0-1.0].",
            "```chuck\nfloat strikePosition()\n```\nGet strike position, [0.0-1.0].",
            "```chuck\nfloat vibratoFreq(float value)\n```\nSet vibrato frequency (Hz).",
            "```chuck\nfloat vibratoFreq()\n```\nGet vibrato frequency (Hz).",
            "```chuck\nfloat vibratoGain(float value)\n```\nSet vibrato gain, [0.0-1.0].",
            "```chuck\nfloat vibratoGain()\n```\nGet vibrato gain, [0.0-1.0].",
            "```chuck\nfloat volume(float value)\n```\nSet volume, [0.0-1.0].",
            "```chuck\nfloat volume()\n```\nGet volume, [0.0-1.0]."
        ],
        "link": "[More...](https://chuck.stanford.edu/doc/reference/ugens-stk.html#ModalBar)"
    },
    "Modulate": {
        "title": "**Modulation Effect**",
        "description": "This class combines random and periodic modulations to give a nice, natural human modulation function. by Perry R. Cook and Gary P. Scavone, 1995 - 2002.",
        "constructors": [
            "**Constructors:**",
            "```chuck\nModulate()\n```\nDefault constructor for Modulate."
        ],
        "examples": [
            "Examples: \t [modulate.ck](https://chuck.stanford.edu/doc/examples/stk/modulate.ck)"
        ],
        "functions": [
            "**Methods:**",
            "```chuck\nfloat randomGain(float value)\n```\nSet gain for random contribution.",
            "```chuck\nfloat randomGain()\n```\nGet gain for random contribution.",
            "```chuck\nfloat vibratoGain(float value)\n```\nSet gain for vibrato.",
            "```chuck\nfloat vibratoGain()\n```\nGet gain for vibrato.",
            "```chuck\nfloat vibratoRate(float value)\n```\nSet rate for vibrato.",
            "```chuck\nfloat vibratoRate()\n```\nGet rate for vibrato."
        ],
        "link": "[More...](https://chuck.stanford.edu/doc/reference/ugens-stk.html#Modulate)"
    },
    "Moog": {
        "title": "**STK Moog**",
        "description": "This instrument uses one attack wave, one looped wave, and an ADSR envelope (inherited from the Sampler class) and adds two sweepable formant (FormSwep) filters. Control Change Numbers: - Filter Q = 2 - Filter Sweep Rate = 4 - Vibrato Frequency = 11 - Vibrato Gain = 1 - Gain = 128 by Perry R. Cook and Gary P. Scavone, 1995 - 2002.",
        "constructors": [
            "**Constructors:**",
            "```chuck\nMoog()\n```\nDefault constructor for Moog."
        ],
        "examples": [
            "Examples: \t [moog.ck](https://chuck.stanford.edu/doc/examples/stk/moog.ck), [moog2.ck](https://chuck.stanford.edu/doc/examples/stk/moog2.ck), [moogie.ck](https://chuck.stanford.edu/doc/examples/stk/moogie.ck)"
        ],
        "functions": [
            "**Methods:**",
            "```chuck\nfloat afterTouch(float value)\n```\nSet aftertouch, [0.0-1.0].",
            "```chuck\nfloat filterQ(float value)\n```\nSet filter Q value, [0.0-1.0].",
            "```chuck\nfloat filterQ()\n```\nGet filter Q value, [0.0-1.0].",
            "```chuck\nfloat filterStartFreq(float freq)\n```\nSet filter starting frequency.",
            "```chuck\nfloat filterStartFreq()\n```\nGet filter starting frequency.",
            "```chuck\nfloat filterSweepRate(float value)\n```\nSet filter sweep rate, [0.0-1.0].",
            "```chuck\nfloat filterSweepRate()\n```\nGet filter sweep rate, [0.0-1.0].",
            "```chuck\nfloat lfoDepth(float value)\n```\nSet LFO modulation depth.",
            "```chuck\nfloat lfoDepth()\n```\nGet LFO modulation depth.",
            "```chuck\nfloat lfoSpeed(float value)\n```\nSet LFO modulation speed.",
            "```chuck\nfloat lfoSpeed()\n```\nGet LFO modulation speed.",
            "```chuck\nfloat modDepth(float value)\n```\nSet modulation depth.",
            "```chuck\nfloat modDepth()\n```\nGet modulation depth.",
            "```chuck\nfloat modSpeed(float value)\n```\nSet modulation speed.",
            "```chuck\nfloat modSpeed()\n```\nGet modulation speed.",
            "```chuck\nfloat vibratoFreq(float value)\n```\nSet vibrato frequency (Hz).",
            "```chuck\nfloat vibratoFreq()\n```\nGet vibrato frequency (Hz).",
            "```chuck\nfloat vibratoGain(float value)\n```\nSet vibrato gain, [0.0-1.0].",
            "```chuck\nfloat vibratoGain()\n```\nGet vibrato gain, [0.0-1.0].",
            "```chuck\nfloat volume(float value)\n```\nSet volume.",
            "```chuck\nfloat volume()\n```\nGet volume."
        ],
        "link": "[More...](https://chuck.stanford.edu/doc/reference/ugens-stk.html#Moog)"
    },
    "Multicomb": {
        "title": "**Multi-Comb Filter**",
        "description": "Multiple simultaneous comb filters randomly chosen within a specified frequency range and spread across the stereo field.",
        "constructors": [
            "**Constructors:**",
            "```chuck\nMulticomb()\n```\n"
        ],
        "examples": [
            "Examples: \t [Multicomb.ck](https://chuck.stanford.edu/doc/examples/filter/Multicomb.ck)"
        ],
        "functions": [
            "**Methods:**",
            "```chuck\nfloat maxfreq(float maxfreq)\n```\nSet max frequency. Default 880.",
            "```chuck\nfloat maxfreq()\n```\nGet max frequency. Default 880.",
            "```chuck\nfloat minfreq(float minfreq)\n```\nSet low frequency. Default 220.",
            "```chuck\nfloat minfreq()\n```\nGet low frequency. Default 220.",
            "```chuck\nint num(int num)\n```\nSet number of comb filters. Default 5.",
            "```chuck\nint num()\n```\nGet number of comb filters. Default 5.",
            "```chuck\ndur revtime(dur revtime)\n```\nSet total ring time. Default 1::second.",
            "```chuck\ndur revtime()\n```\nGet total ring time. Default 1::second.",
            "```chuck\nvoid set(float minfreq, float maxfreq)\n```\nSet both low and high frequencies."
        ],
        "link": "[More...](https://chuck.stanford.edu/doc/reference/chugins.html#Multicomb)"
    },
    "NRev": {
        "title": "**CCRMA's NRev Reverberator**",
        "description": "CCRMA's NRev reverberator class. This class is derived from the CLM NRev function, which is based on the use of networks of simple allpass and comb delay filters. This particular arrangement consists of 6 comb filters in parallel, followed by 3 allpass filters, a lowpass filter, and another allpass in series, followed by two allpass filters in parallel with corresponding rightand left outputs. by Perry R. Cook and Gary P. Scavone, 1995 - 2002.",
        "constructors": [
            "**Constructors:**",
            "```chuck\nNRev()\n```\nDefault constructor for NRev."
        ],
        "examples": [
            "Examples: \t [reverb.ck](https://chuck.stanford.edu/doc/examples/effects/reverb.ck), [krstlchr-algo7.ck](https://chuck.stanford.edu/doc/examples/stk/krstlchr-algo7.ck), [thx.ck](https://chuck.stanford.edu/doc/examples/deep/thx.ck)"
        ],
        "functions": [
            "**Methods:**",
            "```chuck\nfloat mix(float value)\n```\nSet mix level.",
            "```chuck\nfloat mix()\n```\nGet mix level."
        ],
        "link": "[More...](https://chuck.stanford.edu/doc/reference/ugens-stk.html#NRev)"
    },
    "Noise": {
        "title": "**White Noise Generator**",
        "description": "A white noise generator.",
        "constructors": [],
        "examples": [
            "Examples: \t [wind.ck](https://chuck.stanford.edu/doc/examples/basic/wind.ck), [powerup.ck](https://chuck.stanford.edu/doc/examples/shred/powerup.ck)"
        ],
        "functions": [],
        "link": "[More...](https://chuck.stanford.edu/doc/reference/ugens-basic.html#Noise)"
    },
    "Object": {
        "title": "**ChucK Base Object Class**",
        "description": "Base class for all class types in ChucK.",
        "constructors": [
            "**Constructors:**",
            "```chuck\nObject()\n```\nDefault constructor for Object."
        ],
        "examples": [],
        "functions": [
            "**Methods:**",
            "```chuck\nstring toString()\n```\nGet a textual description of this object.",
            "```chuck\nvoid help()\n```\nOutput helpful information about a class or an instance thereof.",
            "```chuck\nType typeOf()\n```\nGet the type of this object (or class)."
        ],
        "link": "[More...](https://chuck.stanford.edu/doc/reference/base.html#Object)"
    },
    "OnePole": {
        "title": "**One-Pole Filter**",
        "description": "This Filter subclass implements a one-pole digital filter. A method is provided for setting the pole position along the real axis of the z-plane while maintaining a constant peak filter gain. by Perry R. Cook and Gary P. Scavone, 1995 - 2002.",
        "constructors": [
            "**Constructors:**",
            "```chuck\nOnePole()\n```\nDefault constructor for OnePole."
        ],
        "examples": [
            "Examples: \t [follower.ck](https://chuck.stanford.edu/doc/examples/deep/follower.ck)"
        ],
        "functions": [
            "**Methods:**",
            "```chuck\nfloat a1(float value)\n```\nSet filter coefficient.",
            "```chuck\nfloat a1()\n```\nGet filter coefficient.",
            "```chuck\nfloat b0(float value)\n```\nSet filter coefficient.",
            "```chuck\nfloat b0()\n```\nGet filter coefficient.",
            "```chuck\nfloat pole(float value)\n```\nSet pole position along real axis of z-plane.",
            "```chuck\nfloat pole()\n```\nGet pole position along real axis of z-plane."
        ],
        "link": "[More...](https://chuck.stanford.edu/doc/reference/ugens-filters.html#OnePole)"
    },
    "OneZero": {
        "title": "**One-Zero Filter**",
        "description": "This Filter subclass implements a one-zero digital filter. A method is provided for setting the zero position along the real axis of the z-plane while maintaining a constant filter gain. by Perry R. Cook and Gary P. Scavone, 1995 - 2002.",
        "constructors": [
            "**Constructors:**",
            "```chuck\nOneZero()\n```\nDefault constructor for OneZero."
        ],
        "examples": [
            "Examples: \t [plu.ck](https://chuck.stanford.edu/doc/examples/deep/plu.ck), [plu2.ck](https://chuck.stanford.edu/doc/examples/deep/plu2.ck), [plu3.ck](https://chuck.stanford.edu/doc/examples/deep/plu3.ck)"
        ],
        "functions": [
            "**Methods:**",
            "```chuck\nfloat b0(float value)\n```\nSet filter coefficient.",
            "```chuck\nfloat b0()\n```\nGet filter coefficient.",
            "```chuck\nfloat b1(float value)\n```\nSet filter coefficient.",
            "```chuck\nfloat b1()\n```\nGet filter coefficient.",
            "```chuck\nfloat zero(float value)\n```\nSet zero position.",
            "```chuck\nfloat zero()\n```\nGet zero position."
        ],
        "link": "[More...](https://chuck.stanford.edu/doc/reference/ugens-filters.html#OneZero)"
    },
    "Osc": {
        "title": "**Oscillator Base Class**",
        "description": "Base class for simple oscillator unit generators.",
        "constructors": [
            "**Constructors:**",
            "```chuck\nOsc()\n```\nDefault constructor for Osc.",
            "```chuck\nOsc(float freq)\n```\nConstruct Osc at specified frequency.",
            "```chuck\nOsc(float freq, float phase)\n```\nConstruct Osc at specified frequency and phase."
        ],
        "examples": [],
        "functions": [
            "**Methods:**",
            "```chuck\nfloat freq(float hz)\n```\nSet frequency of oscillator in Hertz; maintains phase.",
            "```chuck\nfloat freq()\n```\nGet frequency of oscillator in Hertz.",
            "```chuck\ndur period(dur value)\n```\nSet period of oscillator (inverse of frequency).",
            "```chuck\ndur period()\n```\nGet period of oscillator (inverse of frequency).",
            "```chuck\nfloat phase(float phase)\n```\nSet oscillator phase, in range [0,1).",
            "```chuck\nfloat phase()\n```\nGet oscillator phase, in range [0,1).",
            "```chuck\nfloat sfreq(float hz)\n```\nSet frequency of oscillator in Hertz; resets phase to 0.",
            "```chuck\nint sync(int type)\n```\nChoose how to interpret input: (0) sync frequency to input; (1) sync phase to input; (2) frequency modulation (add input to internal frequency).",
            "```chuck\nint sync()\n```\nGet current interpretation of input: (0) sync frequency to input; (1) sync phase to input; (2) frequency modulation (add input to internal frequency)."
        ],
        "link": "[More...](https://chuck.stanford.edu/doc/reference/ugens-basic.html#Osc)"
    },
    "OscIn": {
        "title": "**OSC Input**",
        "description": "Class for receiving Open Sound Control (OSC) messages. See examples for usage.",
        "constructors": [
            "**Constructors:**",
            "```chuck\nOscIn()\n```\n"
        ],
        "examples": [
            "Examples: \t [r.ck](https://chuck.stanford.edu/doc/examples/osc/r.ck), [r2.ck](https://chuck.stanford.edu/doc/examples/osc/r2.ck), [s.ck](https://chuck.stanford.edu/doc/examples/osc/s.ck), [osc-dump.ck](https://chuck.stanford.edu/doc/examples/osc/osc-dump.ck), [r-multi-msg.ck](https://chuck.stanford.edu/doc/examples/osc/multi-msg/r-multi-msg.ck)"
        ],
        "functions": [
            "**Methods:**",
            "```chuck\nfloat freq(float hz)\n```\nSet frequency of oscillator in Hertz; maintains phase.",
            "```chuck\nfloat freq()\n```\nGet frequency of oscillator in Hertz.",
            "```chuck\ndur period(dur value)\n```\nSet period of oscillator (inverse of frequency).",
            "```chuck\ndur period()\n```\nGet period of oscillator (inverse of frequency).",
            "```chuck\nfloat phase(float phase)\n```\nSet oscillator phase, in range [0,1).",
            "```chuck\nfloat phase()\n```\nGet oscillator phase, in range [0,1).",
            "```chuck\nfloat sfreq(float hz)\n```\nSet frequency of oscillator in Hertz; resets phase to 0.",
            "```chuck\nint sync(int type)\n```\nChoose how to interpret input: (0) sync frequency to input; (1) sync phase to input; (2) frequency modulation (add input to internal frequency).",
            "```chuck\nint sync()\n```\nGet current interpretation of input: (0) sync frequency to input; (1) sync phase to input; (2) frequency modulation (add input to internal frequency).",
            "```chuck\nint buffered(int val)\n```\nSet the unit generator's buffered operation mode, typically used externally from hosts that embed ChucK as a component. If true, the UGen stores a buffer of its most recent samples, which can be fetched using global variables in the host language.",
            "```chuck\nint buffered()\n```\nGet the ugen's buffered operation mode.",
            "```chuck\nUGen chan(int num)\n```\nGet channel (as a UGen) at specified index.",
            "```chuck\nint channels(int num)\n```\nSet number of channels. (currently NOT supported)",
            "```chuck\nint channels()\n```\nGet number of channels.",
            "```chuck\nfloat gain(float val)\n```\nSet the gain of the unit generator.",
            "```chuck\nfloat gain()\n```\nGet the gain of the unit generator.",
            "```chuck\nint isConnectedTo(UGen rhs)\n```\nReturn true if this UGen's output is connected to the input of rhs; if either this UGen or rhs has more than one channel, this function returns true if any connections exist between the channels; return false if there are no connections.",
            "```chuck\nfloat last()\n```\nGet the last sample value of the unit generator.",
            "```chuck\nint op(int val)\n```\nSet the unit generator's operation mode. Accepted values are: 1 (sum inputs), 2 (take difference between first input and subsequent inputs), 3 (multiply inputs), 4 (divide first input by subsequent inputs), 0 (do not synthesize audio, output 0) or -1 (passthrough inputs to output).",
            "```chuck\nint op()\n```\nGet the unit generator's operation mode.",
            "```chuck\nvoid addAddress(string address)\n```\nAdd an OSC address to receive messages from.",
            "```chuck\nvoid listenAll()\n```\nSet OscIn to receive messages of any OSC address.",
            "```chuck\nint port()\n```\nGet which port to listen on.",
            "```chuck\nint port(int p)\n```\nSet which port to listen on; this will begin priming the background OSC listener on the named port. If port is set to 0, a usable port would be automatically assigned; the auto-assigned port number can be retrieved by calling .port() but may initially take some time to acquire (e.g., hundreds of milliseconds); if there is more than one OscIn client on port 0, they all will eventually share the same auto-assigned port.",
            "```chuck\nint recv(OscMsg msg)\n```\nReceive the next queued incoming OSC message, returning its contents in `msg`.",
            "```chuck\nvoid removeAddress(string address)\n```\nStop listening on a particular OSC address.",
            "```chuck\nvoid removeAllAddresses()\n```\nStop listening on all OSC addresses."
        ],
        "link": "[More...](https://chuck.stanford.edu/doc/reference/io.html#OscIn)"
    },
    "OscMsg": {
        "title": "**OSC Message**",
        "description": "Helper class for receiving the contents of an OSC message.",
        "constructors": [
            "**Constructors:**",
            "```chuck\nOscMsg()\n```\n"
        ],
        "examples": [
            "Examples: \t [r.ck](https://chuck.stanford.edu/doc/examples/osc/r.ck), [r2.ck](https://chuck.stanford.edu/doc/examples/osc/r2.ck), [s.ck](https://chuck.stanford.edu/doc/examples/osc/s.ck), [osc-dump.ck](https://chuck.stanford.edu/doc/examples/osc/osc-dump.ck), [r-multi-msg.ck](https://chuck.stanford.edu/doc/examples/osc/multi-msg/r-multi-msg.ck)"
        ],
        "functions": [
            "**Methods:**",
            "```chuck\nfloat freq(float hz)\n```\nSet frequency of oscillator in Hertz; maintains phase.",
            "```chuck\nfloat freq()\n```\nGet frequency of oscillator in Hertz.",
            "```chuck\ndur period(dur value)\n```\nSet period of oscillator (inverse of frequency).",
            "```chuck\ndur period()\n```\nGet period of oscillator (inverse of frequency).",
            "```chuck\nfloat phase(float phase)\n```\nSet oscillator phase, in range [0,1).",
            "```chuck\nfloat phase()\n```\nGet oscillator phase, in range [0,1).",
            "```chuck\nfloat sfreq(float hz)\n```\nSet frequency of oscillator in Hertz; resets phase to 0.",
            "```chuck\nint sync(int type)\n```\nChoose how to interpret input: (0) sync frequency to input; (1) sync phase to input; (2) frequency modulation (add input to internal frequency).",
            "```chuck\nint sync()\n```\nGet current interpretation of input: (0) sync frequency to input; (1) sync phase to input; (2) frequency modulation (add input to internal frequency).",
            "```chuck\nint buffered(int val)\n```\nSet the unit generator's buffered operation mode, typically used externally from hosts that embed ChucK as a component. If true, the UGen stores a buffer of its most recent samples, which can be fetched using global variables in the host language.",
            "```chuck\nint buffered()\n```\nGet the ugen's buffered operation mode.",
            "```chuck\nUGen chan(int num)\n```\nGet channel (as a UGen) at specified index.",
            "```chuck\nint channels(int num)\n```\nSet number of channels. (currently NOT supported)",
            "```chuck\nint channels()\n```\nGet number of channels.",
            "```chuck\nfloat gain(float val)\n```\nSet the gain of the unit generator.",
            "```chuck\nfloat gain()\n```\nGet the gain of the unit generator.",
            "```chuck\nint isConnectedTo(UGen rhs)\n```\nReturn true if this UGen's output is connected to the input of rhs; if either this UGen or rhs has more than one channel, this function returns true if any connections exist between the channels; return false if there are no connections.",
            "```chuck\nfloat last()\n```\nGet the last sample value of the unit generator.",
            "```chuck\nint op(int val)\n```\nSet the unit generator's operation mode. Accepted values are: 1 (sum inputs), 2 (take difference between first input and subsequent inputs), 3 (multiply inputs), 4 (divide first input by subsequent inputs), 0 (do not synthesize audio, output 0) or -1 (passthrough inputs to output).",
            "```chuck\nint op()\n```\nGet the unit generator's operation mode.",
            "```chuck\nfloat getFloat(int i)\n```\nGet argument (at index 'i') as a float.",
            "```chuck\nint getInt(int i)\n```\nGet argument (at index 'i') as an integer.",
            "```chuck\nstring getString(int i)\n```\nGet argument (at index 'i') as a string.",
            "```chuck\nint numArgs()\n```\nGet the number of arguments contained in this OscMsg."
        ],
        "link": "[More...](https://chuck.stanford.edu/doc/reference/io.html#OscMsg)"
    },
    "OscOut": {
        "title": "**OSC Output**",
        "description": "Class for sending Open Sound Control (OSC) messages. See examples for usage.",
        "constructors": [
            "**Constructors:**",
            "```chuck\nOscOut()\n```\n"
        ],
        "examples": [
            "Examples: \t [s.ck](https://chuck.stanford.edu/doc/examples/osc/s.ck), [r.ck](https://chuck.stanford.edu/doc/examples/osc/r.ck), [r2.ck](https://chuck.stanford.edu/doc/examples/osc/r2.ck), [osc-dump.ck](https://chuck.stanford.edu/doc/examples/osc/osc-dump.ck)"
        ],
        "functions": [
            "**Methods:**",
            "```chuck\nfloat freq(float hz)\n```\nSet frequency of oscillator in Hertz; maintains phase.",
            "```chuck\nfloat freq()\n```\nGet frequency of oscillator in Hertz.",
            "```chuck\ndur period(dur value)\n```\nSet period of oscillator (inverse of frequency).",
            "```chuck\ndur period()\n```\nGet period of oscillator (inverse of frequency).",
            "```chuck\nfloat phase(float phase)\n```\nSet oscillator phase, in range [0,1).",
            "```chuck\nfloat phase()\n```\nGet oscillator phase, in range [0,1).",
            "```chuck\nfloat sfreq(float hz)\n```\nSet frequency of oscillator in Hertz; resets phase to 0.",
            "```chuck\nint sync(int type)\n```\nChoose how to interpret input: (0) sync frequency to input; (1) sync phase to input; (2) frequency modulation (add input to internal frequency).",
            "```chuck\nint sync()\n```\nGet current interpretation of input: (0) sync frequency to input; (1) sync phase to input; (2) frequency modulation (add input to internal frequency).",
            "```chuck\nint buffered(int val)\n```\nSet the unit generator's buffered operation mode, typically used externally from hosts that embed ChucK as a component. If true, the UGen stores a buffer of its most recent samples, which can be fetched using global variables in the host language.",
            "```chuck\nint buffered()\n```\nGet the ugen's buffered operation mode.",
            "```chuck\nUGen chan(int num)\n```\nGet channel (as a UGen) at specified index.",
            "```chuck\nint channels(int num)\n```\nSet number of channels. (currently NOT supported)",
            "```chuck\nint channels()\n```\nGet number of channels.",
            "```chuck\nfloat gain(float val)\n```\nSet the gain of the unit generator.",
            "```chuck\nfloat gain()\n```\nGet the gain of the unit generator.",
            "```chuck\nint isConnectedTo(UGen rhs)\n```\nReturn true if this UGen's output is connected to the input of rhs; if either this UGen or rhs has more than one channel, this function returns true if any connections exist between the channels; return false if there are no connections.",
            "```chuck\nfloat last()\n```\nGet the last sample value of the unit generator.",
            "```chuck\nint op(int val)\n```\nSet the unit generator's operation mode. Accepted values are: 1 (sum inputs), 2 (take difference between first input and subsequent inputs), 3 (multiply inputs), 4 (divide first input by subsequent inputs), 0 (do not synthesize audio, output 0) or -1 (passthrough inputs to output).",
            "```chuck\nint op()\n```\nGet the unit generator's operation mode.",
            "```chuck\nOscOut add(int i)\n```\nAdd an integer value to an OSC message.",
            "```chuck\nOscOut add(float f)\n```\nAdd a floating-point value to an OSC message.",
            "```chuck\nOscOut add(string s)\n```\nAdd an string value to an OSC message.",
            "```chuck\nOscOut dest(string hostname, int port)\n```\nSet the destination hostname and port for sending OSC message.",
            "```chuck\nOscOut send()\n```\nSend the current OSC message.",
            "```chuck\nOscOut start(string address)\n```\nStart an OSC message with a particular address.",
            "```chuck\nOscOut start(string address, string host, int port)\n```\nStart an OSC message with a particular address, aimed at a destination host and port."
        ],
        "link": "[More...](https://chuck.stanford.edu/doc/reference/io.html#OscOut)"
    },
    "PCA": {
        "title": "**Principal Component Analyzer**",
        "description": "A principle component analysis (PCA) utility, commonly used for dimensionality reduction.",
        "constructors": [
            "**Constructors:**",
            "```chuck\nPCA()\n```\nDefault constructor for PCA."
        ],
        "examples": [
            "Examples: \t [pca.ck](https://chuck.stanford.edu/doc/examples/ai/pca/pca.ck)"
        ],
        "functions": [
            "**Methods:**",
            "```chuck\nvoid reduce(float[][] input, int D, float[][] output)\n```\nDimension-reduce 'input' (NxM) to 'output' (NxD) as the projection of the input data onto its first 'D' principle components."
        ],
        "link": "[More...](https://chuck.stanford.edu/doc/reference/ai.html#PCA)"
    },
    "PRCRev": {
        "title": "**Perry Cook's Simple Reverberator**",
        "description": "Perry's simple reverberator class. This class is based on some of the famous Stanford/CCRMA reverbs (NRev, KipRev), which were based on the Chowning/Moorer/Schroeder reverberators using networks of simple allpass and comb delay filters. This class implements two series allpass units and two parallel comb filters. by Perry R. Cook and Gary P. Scavone, 1995 - 2002.",
        "constructors": [
            "**Constructors:**",
            "```chuck\nPRCRev()\n```\nDefault constructor for PRCRev."
        ],
        "examples": [
            "Examples: \t [reverb.ck](https://chuck.stanford.edu/doc/examples/effects/reverb.ck)"
        ],
        "functions": [
            "**Methods:**",
            "```chuck\nfloat mix(float value)\n```\nSet mix level.",
            "```chuck\nfloat mix()\n```\nGet mix level."
        ],
        "link": "[More...](https://chuck.stanford.edu/doc/reference/ugens-stk.html#PRCRev)"
    },
    "Pan16": {
        "title": "**16-Channel Panner**",
        "description": "Sixteen-channel equal-power panner.",
        "constructors": [
            "**Constructors:**",
            "```chuck\nPan16()\n```\n"
        ],
        "examples": [],
        "functions": [
            "**Methods:**",
            "```chuck\nfloat pan(float arg)\n```\nSet pan position [0-16].",
            "```chuck\nfloat pan()\n```\nGet pan position [0-16]."
        ],
        "link": "[More...](https://chuck.stanford.edu/doc/reference/chugins.html#Pan16)"
    },
    "Pan2": {
        "title": "**Mono to Stereo Panner**",
        "description": "A mono-to-stereo unit generator for stereo panning.",
        "constructors": [
            "**Constructors:**",
            "```chuck\nPan2()\n```\nDefault constructor for Pan2."
        ],
        "examples": [
            "Examples: \t [chirp2.ck](https://chuck.stanford.edu/doc/examples/basic/chirp2.ck), [array.ck](https://chuck.stanford.edu/doc/examples/stereo/array.ck), [powerup2.ck](https://chuck.stanford.edu/doc/examples/stereo/powerup2.ck), [moe2.ck](https://chuck.stanford.edu/doc/examples/stereo/moe2.ck), [larry2.ck](https://chuck.stanford.edu/doc/examples/stereo/larry2.ck), [curly2.ck](https://chuck.stanford.edu/doc/examples/stereo/curly2.ck), [ugen-array.ck](https://chuck.stanford.edu/doc/examples/stereo/ugen-array.ck), [stereo-noise.ck](https://chuck.stanford.edu/doc/examples/stereo/stereo-noise.ck), [honkeytonk-algo1.ck](https://chuck.stanford.edu/doc/examples/stk/honkeytonk-algo1.ck), [hanoi++.ck](https://chuck.stanford.edu/doc/examples/hanoi++.ck), [hanoi2.ck](https://chuck.stanford.edu/doc/examples/hanoi2.ck), [hanoi3.ck](https://chuck.stanford.edu/doc/examples/hanoi3.ck)"
        ],
        "functions": [],
        "link": "[More...](https://chuck.stanford.edu/doc/reference/ugens-basic.html#Pan2)"
    },
    "Pan4": {
        "title": "**4-Channel Panner**",
        "description": "Four-channel equal-power panner.",
        "constructors": [
            "**Constructors:**",
            "```chuck\nPan4()\n```\n"
        ],
        "examples": [
            "Examples: \t [Pan4.ck](https://chuck.stanford.edu/doc/examples/spatial/Pan4.ck)"
        ],
        "functions": [
            "**Methods:**",
            "```chuck\nfloat pan(float arg)\n```\nSet pan position [0-4].",
            "```chuck\nfloat pan()\n```\nGet pan position [0-4]."
        ],
        "link": "[More...](https://chuck.stanford.edu/doc/reference/chugins.html#Pan4)"
    },
    "Pan8": {
        "title": "**8-Channel Panner**",
        "description": "Eight-channel equal-power panner.",
        "constructors": [
            "**Constructors:**",
            "```chuck\nPan8()\n```\n"
        ],
        "examples": [
            "Examples: \t [Pan8.ck](https://chuck.stanford.edu/doc/examples/spatial/Pan8.ck)"
        ],
        "functions": [
            "**Methods:**",
            "```chuck\nfloat pan(float arg)\n```\nSet pan position [0-8].",
            "```chuck\nfloat pan()\n```\nGet pan position [0-8]."
        ],
        "link": "[More...](https://chuck.stanford.edu/doc/reference/chugins.html#Pan8)"
    },
    "PercFlut": {
        "title": "**STK Percussive Flute**",
        "description": "STK percussive flute FM synthesis instrument. This class implements algorithm 4 of the TX81Z. Algorithm 4 is :     4->3--\\   ___2-- + -->1-->Out   Control Change Numbers: - Total Modulator Index = 2 (.controlOne) - Modulator Crossfade = 4 (.controlTwo) - LFO Speed = 11 - LFO Depth = 1 - ADSR 2 & 4 Target = 128 The basic Chowning/Stanford FM patent expired in 1995, but there exist follow-on patents, mostly assigned to Yamaha. If you are of the type who should worry about this (making money) worry away. by Perry R. Cook and Gary P. Scavone, 1995 - 2002.",
        "constructors": [
            "**Constructors:**",
            "```chuck\nPercFlut()\n```\nDefault constructor for PercFlut."
        ],
        "examples": [
            "Examples: \t [ctrl_sequencer.ck](https://chuck.stanford.edu/doc/examples/ctrl/ctrl_sequencer.ck)"
        ],
        "functions": [],
        "link": "[More...](https://chuck.stanford.edu/doc/reference/ugens-stk.html#PercFlut)"
    },
    "Phasor": {
        "title": "**Phasor Oscillator**",
        "description": "A phasor oscillator; linearly rises from 0 to 1; can be used as a phase control.",
        "constructors": [
            "**Constructors:**",
            "```chuck\nPhasor()\n```\nDefault constructor for Phasor.",
            "```chuck\nPhasor(float freq)\n```\nConstruct Phasor at specified frequency.",
            "```chuck\nPhasor(float freq, float phase)\n```\nConstruct Phasor at specified frequency and phase."
        ],
        "examples": [
            "Examples: \t [phasor.ck](https://chuck.stanford.edu/doc/examples/basic/phasor.ck)"
        ],
        "functions": [],
        "link": "[More...](https://chuck.stanford.edu/doc/reference/ugens-basic.html#Phasor)"
    },
    "PitShift": {
        "title": "**Pitch Shift Effect**",
        "description": "This class implements a simple pitch shifter using delay lines. by Perry R. Cook and Gary P. Scavone, 1995 - 2002.",
        "constructors": [
            "**Constructors:**",
            "```chuck\nPitShift()\n```\nDefault constructor for PitShift."
        ],
        "examples": [
            "Examples: \t [pitch-shift.ck](https://chuck.stanford.edu/doc/examples/effects/pitch-shift.ck)"
        ],
        "functions": [
            "**Methods:**",
            "```chuck\nfloat effectMix(float value)\n```\nSet effect mix level.",
            "```chuck\nfloat effectMix()\n```\nGet effect mix level.",
            "```chuck\nfloat mix(float value)\n```\nSet mix level.",
            "```chuck\nfloat mix()\n```\nGet mix level.",
            "```chuck\nfloat shift(float value)\n```\nSet degree of pitch shifting.",
            "```chuck\nfloat shift()\n```\nGet degree of pitch shifting."
        ],
        "link": "[More...](https://chuck.stanford.edu/doc/reference/ugens-stk.html#PitShift)"
    },
    "PitchTrack": {
        "title": "**Pitch Tracker**",
        "description": "PitchTrack is a monophonic autocorrelation pitch tracker with a fast response and extremely high accuracy, even at low frequencies. It is adapted from [helmholtz~] for Pd by Katja, documented at http://www.katjaas.nl/helmholtz/helmholtz.html.",
        "constructors": [
            "**Constructors:**",
            "```chuck\nPitchTrack()\n```\n"
        ],
        "examples": [
            "Examples: \t [autotune.ck](https://chuck.stanford.edu/doc/examples/effects/autotune.ck), [PitchTrack.ck](https://chuck.stanford.edu/doc/examples/analysis/PitchTrack.ck)"
        ],
        "functions": [
            "**Methods:**",
            "```chuck\nfloat bias(float arg)\n```\nSet the bias. Katja's pitch tracker introduces a small bias to help with the tracking. See the link above.",
            "```chuck\nfloat bias()\n```\nGet the bias. Katja's pitch tracker introduces a small bias to help with the tracking. See the link above.",
            "```chuck\nfloat fidelity(float arg)\n```\nSet the threshold for certainty about the result. A highly periodic signal (i.e. one that has a strong pitch center) should produce a result with a high fidelity, which a non-periodic signal (eg noise) will have a very low fidelity. Setting this parameter close to 1 should reduce the number of inaccurate reports. [0-1], default 0.95.",
            "```chuck\nfloat fidelity()\n```\nGet the threshold for certainty about the result. A highly periodic signal (i.e. one that has a strong pitch center) should produce a result with a high fidelity, which a non-periodic signal (eg noise) will have a very low fidelity. Setting this parameter close to 1 should reduce the number of inaccurate reports. [0-1], default 0.95.",
            "```chuck\nint frame(int arg)\n```\nSet size of FFT frame for analysis. Smaller values result in lower latency and high responsiveness but less accuracy. Higher values result in considerably greater CPU load. Values that aren't powers of 2 get rounded up to the next power of 2. Recommend 512, 1024, or 2048. [128-?], default 2048.",
            "```chuck\nint frame()\n```\nGet size of FFT frame for analysis. Smaller values result in lower latency and high responsiveness but less accuracy. Higher values result in considerably greater CPU load. Values that aren't powers of 2 get rounded up to the next power of 2. Recommend 512, 1024, or 2048. [128-?], default 2048.",
            "```chuck\nfloat get()\n```\nGet calculated frequency.",
            "```chuck\nint overlap(int arg)\n```\nSet how much to overlap successive analysis frames. Higher values should produce smoother values, at the cost of an increase of CPU load. [1-?], default 2.",
            "```chuck\nint overlap()\n```\nGet how much to overlap successive analysis frames. Higher values should produce smoother values, at the cost of an increase of CPU load. [1-?], default 2.",
            "```chuck\nfloat sensitivity(float arg)\n```\nSet the minimum RMS value to trigger a pitch calculation. Setting this parameter low forces PitchTrack to attempt to find the pitch of even very quiet sounds. Higher values will cause it to trigger only on louder notes. [0-1], default 0.003.",
            "```chuck\nfloat sensitivity()\n```\nGet the minimum RMS value to trigger a pitch calculation. Setting this parameter low forces PitchTrack to attempt to find the pitch of even very quiet sounds. Higher values will cause it to trigger only on louder notes. [0-1], default 0.003."
        ],
        "link": "[More...](https://chuck.stanford.edu/doc/reference/chugins.html#PitchTrack)"
    },
    "PoleZero": {
        "title": "**Pole-Zero Filter**",
        "description": "A one-pole, one-zero digital filter. A method is provided for creating an allpass filter with a given coefficient. Another method is provided to create a DC blocking filter. by Perry R. Cook and Gary P. Scavone, 1995 - 2002.",
        "constructors": [
            "**Constructors:**",
            "```chuck\nPoleZero()\n```\nDefault constructor for PoleZero."
        ],
        "examples": [
            "Examples: \t [dcblocker.ck](https://chuck.stanford.edu/doc/examples/filter/dcblocker.ck), [plu2.ck](https://chuck.stanford.edu/doc/examples/deep/plu2.ck), [plu3.ck](https://chuck.stanford.edu/doc/examples/deep/plu3.ck), [flute.ck](https://chuck.stanford.edu/doc/examples/stk/flute.ck), [pitch-track.ck](https://chuck.stanford.edu/doc/examples/analysis/tracking/pitch-track.ck), [pitch-third.ck](https://chuck.stanford.edu/doc/examples/analysis/tracking/pitch-third.ck), [pitch-fifth.ck](https://chuck.stanford.edu/doc/examples/analysis/tracking/pitch-fifth.ck), [pitch-seventh.ck](https://chuck.stanford.edu/doc/examples/analysis/tracking/pitch-seventh.ck), [Tracking.ck](https://chuck.stanford.edu/doc/examples/analysis/tracking/Tracking.ck)"
        ],
        "functions": [
            "**Methods:**",
            "```chuck\nfloat a1(float value)\n```\nSet filter coefficient.",
            "```chuck\nfloat a1()\n```\nGet filter coefficient.",
            "```chuck\nfloat allpass(float value)\n```\nSet allpass filter with given coefficient.",
            "```chuck\nfloat allpass()\n```\nGet allpass filter with given coefficient.",
            "```chuck\nfloat b0(float value)\n```\nSet filter coefficient.",
            "```chuck\nfloat b0()\n```\nGet filter coefficient.",
            "```chuck\nfloat b1(float value)\n```\nSet filter coefficient.",
            "```chuck\nfloat b1()\n```\nGet filter coefficient.",
            "```chuck\nfloat blockZero(float value)\n```\nSet DC blocking filter with given pole position.",
            "```chuck\nfloat blockZero()\n```\nGet DC blocking filter with given pole position."
        ],
        "link": "[More...](https://chuck.stanford.edu/doc/reference/ugens-filters.html#PoleZero)"
    },
    "PowerADSR": {
        "title": "**Power ADSR Envelope**",
        "description": "ADSR envelope that uses a power function to create curved envelope phases. In general, curves under 1.0 are sharp, while curves over 1.0 are soft.",
        "constructors": [
            "**Constructors:**",
            "```chuck\nPowerADSR()\n```\n"
        ],
        "examples": [
            "Examples: \t [PowerADSR-feedback-beatings.ck](https://chuck.stanford.edu/doc/examples/effects/PowerADSR-feedback-beatings.ck), [PowerADSR.ck](https://chuck.stanford.edu/doc/examples/effects/PowerADSR.ck)"
        ],
        "functions": [
            "**Methods:**",
            "```chuck\ndur attack(dur attackDuration)\n```\nSets duration of the attack phase.",
            "```chuck\nfloat attackCurve(float attackCurve)\n```\nSets envelope curve of the attack phase.",
            "```chuck\nfloat attackCurve()\n```\nGets the attack curve.",
            "```chuck\ndur attackTime(dur attackDuration)\n```\nSets duration of the attack phase.",
            "```chuck\ndur attackTime()\n```\nGets the attack duration.",
            "```chuck\ndur decay(dur decayDuration)\n```\nSets duration of the decay phase.",
            "```chuck\nfloat decayCurve(float decayCurve)\n```\nSets envelope curve of the decay phase.",
            "```chuck\nfloat decayCurve()\n```\nGets the decay curve.",
            "```chuck\ndur decayTime(dur decayDuration)\n```\nSets duration of the decay phase.",
            "```chuck\ndur decayTime()\n```\nGets the decay duration.",
            "```chuck\nint keyOff()\n```\nBegins the release phase of the envelope.",
            "```chuck\nint keyOff(int keyOff)\n```\nBegins the release phase of the envelope.",
            "```chuck\nint keyOn()\n```\nBegins the attack phase of the envelope.",
            "```chuck\nint keyOn(int keyOn)\n```\nBegins the attack phase of the envelope.",
            "```chuck\ndur release(dur releaseDuration)\n```\nSets duration of the release phase.",
            "```chuck\nfloat releaseCurve(float releaseCurve)\n```\nSets envelope curve of the release phase.",
            "```chuck\nfloat releaseCurve()\n```\nGets the release curve.",
            "```chuck\ndur releaseTime(dur releaseDuration)\n```\nSets duration of the release phase.",
            "```chuck\ndur releaseTime()\n```\nGets the release duration.",
            "```chuck\nvoid set(dur attackDuration, dur decayDuration, float sustainLevel, dur releaseDuration)\n```\nSets duration of the attack, decay, and release phases; as well as the sustain level (ADSR order).",
            "```chuck\nvoid setCurves(float attackCurve, float decayCurve, float releaseCurve)\n```\nSets envelope curves of the attack, decay, and release phases.",
            "```chuck\nint state()\n```\nGets current state.",
            "```chuck\nfloat sustainLevel(float sustainLevel)\n```\nSets sustain level.",
            "```chuck\nfloat sustainLevel()\n```\nGets sustain level.",
            "```chuck\nfloat value()\n```\nGets current envelope value."
        ],
        "link": "[More...](https://chuck.stanford.edu/doc/reference/chugins.html#PowerADSR)"
    },
    "PulseOsc": {
        "title": "**Pulse Width Oscillator**",
        "description": "A pulse width oscillator.",
        "constructors": [
            "**Constructors:**",
            "```chuck\nPulseOsc()\n```\nDefault constructor for PulseOsc.",
            "```chuck\nPulseOsc(float freq)\n```\nConstruct PulseOsc at specified frequency.",
            "```chuck\nPulseOsc(float freq, float phase)\n```\nConstruct PulseOsc at specified frequency and phase."
        ],
        "examples": [
            "Examples: \t [pulse.ck](https://chuck.stanford.edu/doc/examples/basic/pulse.ck)"
        ],
        "functions": [
            "**Methods:**",
            "```chuck\nfloat freq(float hz)\n```\nSet frequency of oscillator in Hertz; maintains phase.",
            "```chuck\nfloat freq()\n```\nGet frequency of oscillator in Hertz.",
            "```chuck\ndur period(dur value)\n```\nSet period of oscillator (inverse of frequency).",
            "```chuck\ndur period()\n```\nGet period of oscillator (inverse of frequency).",
            "```chuck\nfloat phase(float phase)\n```\nSet oscillator phase, in range [0,1).",
            "```chuck\nfloat phase()\n```\nGet oscillator phase, in range [0,1).",
            "```chuck\nfloat sfreq(float hz)\n```\nSet frequency of oscillator in Hertz; resets phase to 0.",
            "```chuck\nint sync(int type)\n```\nChoose how to interpret input: (0) sync frequency to input; (1) sync phase to input; (2) frequency modulation (add input to internal frequency).",
            "```chuck\nint sync()\n```\nGet current interpretation of input: (0) sync frequency to input; (1) sync phase to input; (2) frequency modulation (add input to internal frequency).",
            "```chuck\nint buffered(int val)\n```\nSet the unit generator's buffered operation mode, typically used externally from hosts that embed ChucK as a component. If true, the UGen stores a buffer of its most recent samples, which can be fetched using global variables in the host language.",
            "```chuck\nint buffered()\n```\nGet the ugen's buffered operation mode.",
            "```chuck\nUGen chan(int num)\n```\nGet channel (as a UGen) at specified index.",
            "```chuck\nint channels(int num)\n```\nSet number of channels. (currently NOT supported)",
            "```chuck\nint channels()\n```\nGet number of channels.",
            "```chuck\nfloat gain(float val)\n```\nSet the gain of the unit generator.",
            "```chuck\nfloat gain()\n```\nGet the gain of the unit generator.",
            "```chuck\nint isConnectedTo(UGen rhs)\n```\nReturn true if this UGen's output is connected to the input of rhs; if either this UGen or rhs has more than one channel, this function returns true if any connections exist between the channels; return false if there are no connections.",
            "```chuck\nfloat last()\n```\nGet the last sample value of the unit generator.",
            "```chuck\nint op(int val)\n```\nSet the unit generator's operation mode. Accepted values are: 1 (sum inputs), 2 (take difference between first input and subsequent inputs), 3 (multiply inputs), 4 (divide first input by subsequent inputs), 0 (do not synthesize audio, output 0) or -1 (passthrough inputs to output).",
            "```chuck\nint op()\n```\nGet the unit generator's operation mode.",
            "```chuck\nfloat width(float width)\n```\nSet width of duty cycle [0,1).",
            "```chuck\nfloat width()\n```\nGet width of duty cycle [0,1)/."
        ],
        "link": "[More...](https://chuck.stanford.edu/doc/reference/ugens-basic.html#PulseOsc)"
    },
    "RMS": {
        "title": "**Root Mean Square**",
        "description": "A unit analyzer that computes the root-mean-square (RMS) power mean from a magnitude spectrum (either from an incoming UAna, or given manually), and outputs a single number.",
        "constructors": [
            "**Constructors:**",
            "```chuck\nRMS()\n```\nDefault constructor for RMS."
        ],
        "examples": [
            "Examples: \t [rms.ck](https://chuck.stanford.edu/doc/examples/ai/features/rms.ck)"
        ],
        "functions": [
            "**Methods:**",
            "```chuck\nfloat compute(float[] input)\n```\nManually computes the RMS from a float array."
        ],
        "link": "[More...](https://chuck.stanford.edu/doc/reference/uanae.html#RMS)"
    },
    "RegEx": {
        "title": "**Regular Expression**",
        "description": "Class for regular expression matching and replacing in strings. Regex style is POSIX-extended.",
        "constructors": [],
        "examples": [],
        "functions": [
            "**Methods:**",
            "```chuck\nint match(string pattern, string str)\n```\nReturn true if match for pattern is found in str, false otherwise.",
            "```chuck\nint match(string pattern, string str, string[] matches)\n```\nReturn the match and sub-patterns in matches. matches[0] in the entire matched pattern, matches[1] is the first sub-pattern (if any), and so on.",
            "```chuck\nstring replace(string pattern, string replacement, string str)\n```\nReplace the first instance of pattern in str with replacement, returning the result.",
            "```chuck\nstring replaceAll(string pattern, string replacement, string str)\n```\nReplace all instances of pattern in str with replacement, returning the result."
        ],
        "link": "[More...](https://chuck.stanford.edu/doc/reference/chugins.html#RegEx)"
    },
    "ResonZ": {
        "title": "**Resonant Filter**",
        "description": "A resonance filter with equal-gain zeros; keeps gain under control independent of frequency.",
        "constructors": [
            "**Constructors:**",
            "```chuck\nResonZ()\n```\nDefault constructor for ResonZ."
        ],
        "examples": [
            "Examples: \t [resonz.ck](https://chuck.stanford.edu/doc/examples/filter/resonz.ck)"
        ],
        "functions": [
            "**Methods:**",
            "```chuck\nfloat Q(float val)\n```\nSet filter resonance.",
            "```chuck\nfloat Q()\n```\nGet filter resonance.",
            "```chuck\nfloat freq(float val)\n```\nSet filter center frequency.",
            "```chuck\nfloat freq()\n```\nGet filter center frequency.",
            "```chuck\nvoid set(float freq, float Q)\n```\nSet filter frequency and resonance at the same time."
        ],
        "link": "[More...](https://chuck.stanford.edu/doc/reference/ugens-filters.html#ResonZ)"
    },
    "Rhodey": {
        "title": "**STK Rhodes Piano**",
        "description": "STK Fender Rhodes-like electric piano FM synthesis instrument. This class implements two simple FM Pairs summed together, also referred to as algorithm 5 of the TX81Z. Algorithm 5 is :     4->3--   + --> Out   2->1--   Control Change Numbers: - Modulator Index One = 2 (.controlOne) - Crossfade of Outputs = 4 (.controlTwo) - LFO Speed = 11 - LFO Depth = 1 - ADSR 2 & 4 Target = 128 The basic Chowning/Stanford FM patent expired in 1995, but there exist follow-on patents, mostly assigned to Yamaha. If you are of the type who should worry about this (making money) worry away. by Perry R. Cook and Gary P. Scavone, 1995 - 2002.",
        "constructors": [
            "**Constructors:**",
            "```chuck\nRhodey()\n```\nDefault constructor for Rhodey."
        ],
        "examples": [
            "Examples: \t [rhodey.ck](https://chuck.stanford.edu/doc/examples/stk/rhodey.ck)"
        ],
        "functions": [],
        "link": "[More...](https://chuck.stanford.edu/doc/reference/ugens-stk.html#Rhodey)"
    },
    "RollOff": {
        "title": "**Spectral Rolloff**",
        "description": "A unit analyzer that computes the spectral rolloff from a magnitude spectrum (either from incoming UAna, or given manually), and outputs a single number.",
        "constructors": [
            "**Constructors:**",
            "```chuck\nRollOff()\n```\nDefault constructor for RollOff."
        ],
        "examples": [
            "Examples: \t [rolloff.ck](https://chuck.stanford.edu/doc/examples/ai/features/rolloff.ck), [rolloff2.ck](https://chuck.stanford.edu/doc/examples/ai/features/rolloff2.ck)"
        ],
        "functions": [
            "**Methods:**",
            "```chuck\nfloat percent(float percent)\n```\nSet the percentage for computing rolloff.",
            "```chuck\nfloat percent()\n```\nGet the percentage specified for the rolloff.",
            "```chuck\nfloat compute(float[] input, float percent)\n```\nManually computes the rolloff from a float array."
        ],
        "link": "[More...](https://chuck.stanford.edu/doc/reference/uanae.html#RollOff)"
    },
    "SFM": {
        "title": "**Spectral Flatness Measure**",
        "description": "A unit analyzer that computes the Spectral Flatness Measure (SFM) from a magnitude spectrum (either from an incoming UAna, or given manually), and outputs a single number.",
        "constructors": [
            "**Constructors:**",
            "```chuck\nSFM()\n```\nDefault constructor for SFM."
        ],
        "examples": [
            "Examples: \t [sfm.ck](https://chuck.stanford.edu/doc/examples/ai/features/sfm.ck)"
        ],
        "functions": [
            "**Methods:**",
            "```chuck\nfloat compute(float[] input, float[] output)\n```\nManually computes the SFM of the input (an FFT spectrum), and stores the results in the output array (SFM coefficients).",
            "```chuck\nint nrBands(int nr_bands)\n```\nSet the number of frequency bands to use for SFM analysis.",
            "```chuck\nint nrBands()\n```\nGet the number of frequency bands to use for SFM analysis."
        ],
        "link": "[More...](https://chuck.stanford.edu/doc/reference/uanae.html#SFM)"
    },
    "SVM": {
        "title": "**Support Vector Machine**",
        "description": "A support vector machine (SVM) utility trains a model and predicts output based on new input.",
        "constructors": [
            "**Constructors:**",
            "```chuck\nSVM()\n```\nDefault constructor for SVM."
        ],
        "examples": [
            "Examples: \t [svm-basic.ck](https://chuck.stanford.edu/doc/examples/ai/svm/svm-basic.ck)"
        ],
        "functions": [
            "**Methods:**",
            "```chuck\nint predict(float[] x, float[] y)\n```\nPredict the output 'y' given the input 'x'.",
            "```chuck\nint train(float[][] x, float[][] y)\n```\nTrain the SVM model with the given samples 'x' and 'y'."
        ],
        "link": "[More...](https://chuck.stanford.edu/doc/reference/ai.html#SVM)"
    },
    "SawOsc": {
        "title": "**Sawtooth Wave Oscillator**",
        "description": "Sawtooth wave oscillator.",
        "constructors": [
            "**Constructors:**",
            "```chuck\nSawOsc()\n```\nDefault constructor for SawOsc.",
            "```chuck\nSawOsc(float freq)\n```\nConstruct SawOsc at specified frequency.",
            "```chuck\nSawOsc(float freq, float phase)\n```\nConstruct SawOsc at specified frequency and phase."
        ],
        "examples": [
            "Examples: \t [thx.ck](https://chuck.stanford.edu/doc/examples/deep/thx.ck), [oscillatronx.ck](https://chuck.stanford.edu/doc/examples/basic/oscillatronx.ck)"
        ],
        "functions": [
            "**Methods:**",
            "```chuck\nfloat freq(float hz)\n```\nSet frequency of oscillator in Hertz; maintains phase.",
            "```chuck\nfloat freq()\n```\nGet frequency of oscillator in Hertz.",
            "```chuck\ndur period(dur value)\n```\nSet period of oscillator (inverse of frequency).",
            "```chuck\ndur period()\n```\nGet period of oscillator (inverse of frequency).",
            "```chuck\nfloat phase(float phase)\n```\nSet oscillator phase, in range [0,1).",
            "```chuck\nfloat phase()\n```\nGet oscillator phase, in range [0,1).",
            "```chuck\nfloat sfreq(float hz)\n```\nSet frequency of oscillator in Hertz; resets phase to 0.",
            "```chuck\nint sync(int type)\n```\nChoose how to interpret input: (0) sync frequency to input; (1) sync phase to input; (2) frequency modulation (add input to internal frequency).",
            "```chuck\nint sync()\n```\nGet current interpretation of input: (0) sync frequency to input; (1) sync phase to input; (2) frequency modulation (add input to internal frequency).",
            "```chuck\nint buffered(int val)\n```\nSet the unit generator's buffered operation mode, typically used externally from hosts that embed ChucK as a component. If true, the UGen stores a buffer of its most recent samples, which can be fetched using global variables in the host language.",
            "```chuck\nint buffered()\n```\nGet the ugen's buffered operation mode.",
            "```chuck\nUGen chan(int num)\n```\nGet channel (as a UGen) at specified index.",
            "```chuck\nint channels(int num)\n```\nSet number of channels. (currently NOT supported)",
            "```chuck\nint channels()\n```\nGet number of channels.",
            "```chuck\nfloat gain(float val)\n```\nSet the gain of the unit generator.",
            "```chuck\nfloat gain()\n```\nGet the gain of the unit generator.",
            "```chuck\nint isConnectedTo(UGen rhs)\n```\nReturn true if this UGen's output is connected to the input of rhs; if either this UGen or rhs has more than one channel, this function returns true if any connections exist between the channels; return false if there are no connections.",
            "```chuck\nfloat last()\n```\nGet the last sample value of the unit generator.",
            "```chuck\nint op(int val)\n```\nSet the unit generator's operation mode. Accepted values are: 1 (sum inputs), 2 (take difference between first input and subsequent inputs), 3 (multiply inputs), 4 (divide first input by subsequent inputs), 0 (do not synthesize audio, output 0) or -1 (passthrough inputs to output).",
            "```chuck\nint op()\n```\nGet the unit generator's operation mode.",
            "```chuck\nfloat width(float width)\n```\nWhether sawtooth wave is to fall (0) or rise (1).",
            "```chuck\nfloat width()\n```\nWhether sawtooth wave is to fall (0) or rise (1)."
        ],
        "link": "[More...](https://chuck.stanford.edu/doc/reference/ugens-basic.html#SawOsc)"
    },
    "Saxofony": {
        "title": "**STK Saxophone**",
        "description": "This class implements a 'hybrid' digital waveguide instrument that can generate a variety of wind-like sounds. It has also been referred to as the 'blowed string' model. The waveguide section is essentially that of a string, with one rigid and one lossy termination. The non-linear function is a reed table. The string can be 'blown' at any point between the terminations, though just as with strings, it is impossible to excite the system at either end. If the excitation is placed at the string mid-point, the sound is that of a clarinet. At points closer to the 'bridge', the sound is closer to that of a saxophone. See Scavone (2002) for more details. This is a digital waveguide model, making its use possibly subject to patents held by Stanford University, Yamaha, and others. Control Change Numbers: - Reed Stiffness = 2 - Reed Aperture = 26 - Noise Gain = 4 - Blow Position = 11 - Vibrato Frequency = 29 - Vibrato Gain = 1 - Breath Pressure = 128 by Perry R. Cook and Gary P. Scavone, 1995 - 2002.",
        "constructors": [
            "**Constructors:**",
            "```chuck\nSaxofony()\n```\nDefault constructor for Saxofony."
        ],
        "examples": [
            "Examples: \t [saxofony.ck](https://chuck.stanford.edu/doc/examples/stk/saxofony.ck)"
        ],
        "functions": [
            "**Methods:**",
            "```chuck\nfloat aperture(float value)\n```\nSet reed aperture, [0.0-1.0].",
            "```chuck\nfloat aperture()\n```\nGet reed aperture, [0.0-1.0].",
            "```chuck\nfloat blowPosition(float value)\n```\nSet lip stiffness, [0.0-1.0].",
            "```chuck\nfloat blowPosition()\n```\nGet lip stiffness, [0.0-1.0].",
            "```chuck\nfloat clear(float value)\n```\nClear instrument.",
            "```chuck\nfloat noiseGain(float value)\n```\nSet noise component gain, [0.0-1.0].",
            "```chuck\nfloat noiseGain()\n```\nGet noise component gain, [0.0-1.0].",
            "```chuck\nfloat pressure(float value)\n```\nSet pressure, [0.0-1.0].",
            "```chuck\nfloat pressure()\n```\nGet pressure, [0.0-1.0].",
            "```chuck\nfloat rate(float value)\n```\nSet rate of attack (seconds).",
            "```chuck\nfloat rate()\n```\nGet rate of attack (seconds).",
            "```chuck\nfloat startBlowing(float value)\n```\nStart blowing, [0.0-1.0].",
            "```chuck\nfloat stiffness(float value)\n```\nSet reed stiffness, [0.0-1.0].",
            "```chuck\nfloat stiffness()\n```\nGet reed stiffness, [0.0-1.0].",
            "```chuck\nfloat stopBlowing(float value)\n```\nStop blowing, [0.0-1.0].",
            "```chuck\nfloat vibratoFreq(float value)\n```\nSet vibrato frequency (Hz).",
            "```chuck\nfloat vibratoFreq()\n```\nGet vibrato frequency (Hz).",
            "```chuck\nfloat vibratoGain(float value)\n```\nSet vibrato gain, [0.0-1.0].",
            "```chuck\nfloat vibratoGain()\n```\nGet vibrato gain, [0.0-1.0]."
        ],
        "link": "[More...](https://chuck.stanford.edu/doc/reference/ugens-stk.html#Saxofony)"
    },
    "SerialIO": {
        "title": "**Serial Input/Output**",
        "description": "Serial input/output. popularly used to communicate with systems like Arduino.",
        "constructors": [
            "**Constructors:**",
            "```chuck\nSerialIO()\n```\nDefault constructor for SerialIO."
        ],
        "examples": [
            "Examples: \t [byte.ck](https://chuck.stanford.edu/doc/examples/serial/byte.ck), [bytes.ck](https://chuck.stanford.edu/doc/examples/serial/bytes.ck), [ints-bin.ck](https://chuck.stanford.edu/doc/examples/serial/ints-bin.ck), [ints-ascii.ck](https://chuck.stanford.edu/doc/examples/serial/ints-ascii.ck), [lines.ck](https://chuck.stanford.edu/doc/examples/serial/lines.ck), [list.ck](https://chuck.stanford.edu/doc/examples/serial/list.ck), [write-bytes.ck](https://chuck.stanford.edu/doc/examples/serial/write-bytes.ck), [write.ck](https://chuck.stanford.edu/doc/examples/serial/write.ck)"
        ],
        "functions": [
            "**Methods:**",
            "```chuck\nint baudRate(int r)\n```\nSet baud rate.",
            "```chuck\nint baudRate()\n```\nGet current baud rate.",
            "```chuck\nvoid close()\n```\n",
            "```chuck\nint dataAvailable()\n```\n",
            "```chuck\nvoid flush()\n```\nFlush the IO buffer.",
            "```chuck\nint getByte()\n```\nGet next requested byte.",
            "```chuck\nint[] getBytes()\n```\nGet next requested number of bytes.",
            "```chuck\nint[] getInts()\n```\nGet next requested number of integers.",
            "```chuck\nstring getLine()\n```\nGet next requested line.",
            "```chuck\nSerialIO onByte()\n```\nWait for one byte (binary mode only).",
            "```chuck\nSerialIO onBytes(int num)\n```\nWait for requested number of bytes (binary mode only).",
            "```chuck\nSerialIO onFloats(int num)\n```\nWait for requested number of floats (ASCII or binary mode).",
            "```chuck\nSerialIO onInts(int num)\n```\nWait for requested number of ints (ASCII or binary mode).",
            "```chuck\nSerialIO onLine()\n```\nWait for one line (ASCII mode only).",
            "```chuck\nint open(int i, int baud, int mode)\n```\nOpen serial device i with specified baud rate and mode (binary or ASCII).",
            "```chuck\nstring readLine()\n```\n",
            "```chuck\nvoid writeByte(int b)\n```\nWrite a single byte.",
            "```chuck\nvoid writeBytes(int[] b)\n```\nWrite array of bytes.",
            "```chuck\nstring[] list()\n```\nGet list of available serial devices."
        ],
        "link": "[More...](https://chuck.stanford.edu/doc/reference/io.html#SerialIO)"
    },
    "Shakers": {
        "title": "**STK Shakers**",
        "description": "PhISEM (Physically Informed Stochastic Event Modeling) is an algorithmic approach for simulating collisions of multiple independent sound producing objects. This class is a meta-model that can simulate a Maraca, Sekere, Cabasa, Bamboo Wind Chimes, Water Drops, Tambourine, Sleighbells, and a Guiro. PhOLIES (Physically-Oriented Library of Imitated Environmental Sounds) is a similar approach for the synthesis of environmental sounds. This class implements simulations of breaking sticks, crunchy snow (or not), a wrench, sandpaper, and more. Control Change Numbers: - Shake Energy = 2 - System Decay = 4 - Number Of Objects = 11 - Resonance Frequency = 1 - Shake Energy = 128 - Instrument Selection = 1071 - Maraca = 0 - Cabasa = 1 - Sekere = 2 - Guiro = 3 - Water Drops = 4 - Bamboo Chimes = 5 - Tambourine = 6 - Sleigh Bells = 7 - Sticks = 8 - Crunch = 9 - Wrench = 10 - Sand Paper = 11 - Coke Can = 12 - Next Mug = 13 - Penny + Mug = 14 - Nickle + Mug = 15 - Dime + Mug = 16 - Quarter + Mug = 17 - Franc + Mug = 18 - Peso + Mug = 19 - Big Rocks = 20 - Little Rocks = 21 - Tuned Bamboo Chimes = 22 by Perry R. Cook, 1996 - 1999.",
        "constructors": [
            "**Constructors:**",
            "```chuck\nShakers()\n```\nDefault constructor for Shakers."
        ],
        "examples": [
            "Examples: \t [shake-cycle.ck](https://chuck.stanford.edu/doc/examples/stk/shake-cycle.ck), [shake-o-matic.ck](https://chuck.stanford.edu/doc/examples/stk/shake-o-matic.ck)"
        ],
        "functions": [
            "**Methods:**",
            "```chuck\nfloat decay(float value)\n```\nSet system decay, [0.0-1.0].",
            "```chuck\nfloat decay()\n```\nGet system decay, [0.0-1.0].",
            "```chuck\nfloat energy(float value)\n```\nSet shake energy, [0.0-1.0].",
            "```chuck\nfloat energy()\n```\nGet shake energy, [0.0-1.0].",
            "```chuck\nfloat freq(float value)\n```\nSet frequency (Hz).",
            "```chuck\nfloat freq()\n```\nGet frequency (Hz).",
            "```chuck\nfloat noteOff(float value)\n```\nTrigger note off.",
            "```chuck\nfloat noteOn(float value)\n```\nTrigger note on.",
            "```chuck\nfloat objects(float value)\n```\nSet number of objects, [0.0-128.0].",
            "```chuck\nfloat objects()\n```\nGet number of objects, [0.0-128.0].",
            "```chuck\nint preset(int value)\n```\nSet instrument, [0-22] (see above).",
            "```chuck\nint preset()\n```\nGet instrument, [0-22] (see above).",
            "```chuck\nint which(int value)\n```\nSet instrument, [0-22] (see above).",
            "```chuck\nint which()\n```\nGet instrument, [0-22] (see above)."
        ],
        "link": "[More...](https://chuck.stanford.edu/doc/reference/ugens-stk.html#Shakers)"
    },
    "Shred": {
        "title": "**ChucK Shred Class**",
        "description": "A strongly-timed ChucK thread of execution.",
        "constructors": [
            "**Constructors:**",
            "```chuck\nShred()\n```\nDefault constructor for Shred."
        ],
        "examples": [
            "Examples: \t [spork.ck](https://chuck.stanford.edu/doc/examples/shred/spork.ck), [spork2.ck](https://chuck.stanford.edu/doc/examples/shred/spork2.ck), [spork2-exit.ck](https://chuck.stanford.edu/doc/examples/shred/spork2-exit.ck), [spork2-remove.ck](https://chuck.stanford.edu/doc/examples/shred/spork2-remove.ck), [powerup.ck](https://chuck.stanford.edu/doc/examples/shred/powerup.ck), [broadcast.ck](https://chuck.stanford.edu/doc/examples/event/broadcast.ck), [signal.ck](https://chuck.stanford.edu/doc/examples/event/signal.ck), [signal4.ck](https://chuck.stanford.edu/doc/examples/event/signal4.ck), [parent.ck](https://chuck.stanford.edu/doc/examples/shred/parent.ck), [ancestor.ck](https://chuck.stanford.edu/doc/examples/shred/ancestor.ck)"
        ],
        "functions": [
            "**Methods:**",
            "```chuck\nstring arg(int index)\n```\nGet the Shred argument at the specified index.",
            "```chuck\nint args()\n```\nGet the number of arguments provided to the Shred.",
            "```chuck\nint childMemSize(int sizeInBytes)\n```\nSet size hint of per-shred call stack (\"mem\") for children shreds subsequently sporked from the calling shred (NOTE this size hint does not affect the calling shred--only its descendants); if sizeInBytes <= 0, the size hint is set to the VM default. (FYI This is an arcane functionality that most programmers never need to worry about. Advanced usage: set size hint to small values (e.g., 1K) to support A LOT (e.g., >10000) of simultaneous shreds; set size hint to large values (e.g., >65K) to spork functions with extremely deep recursion, or to support A LOT (>10000) of declared local variables. Use with care.)",
            "```chuck\nint childMemSize()\n```\nGet the memory stack size hint (in bytes) for shreds sporked from this one.",
            "```chuck\nint childRegSize(int sizeInBytes)\n```\nSet size hint of per-shred operand stack (\"reg\") for children shreds subsequently sporked from the calling shred (NOTE this size hint does not affect the calling shred--only its descendants); if sizeInBytes <= 0, the size hint is set to the VM default. (FYI This is an arcane functionality that most programmers never need to worry about. Advanced usage: set size hint to small values (e.g., 256 bytes) to support A LOT (>10000) of simultaneous shreds; set size hint to large values (e.g., >20K) to spork functions with extremely lengthy (>10000) statements, including array initializer lists. Use with care.)",
            "```chuck\nint childRegSize()\n```\nGet the operand stack size hint (in bytes) for shreds sporked from this one.",
            "```chuck\nstring dir()\n```\nGet the enclosing directory of the source file from which this Shred's code is derived (same as .sourceDir()).",
            "```chuck\nstring dir(int levelsUp)\n```\nGet the enclosing directory, the specified number of parent directories up.",
            "```chuck\nint done()\n```\nHas the Shred reached the end of its execution?",
            "```chuck\nvoid exit()\n```\nHalt the shred's operation and remove it from the virtual machine.",
            "```chuck\nint id()\n```\nGet the unique numeric id of the Shred.",
            "```chuck\nstring path()\n```\nGet the path of the source file from which this Shred's code is derived (same as .sourcePath()).",
            "```chuck\nint running()\n```\nIs the Shred currently actively running in the VM?",
            "```chuck\nstring sourceDir()\n```\nGet the enclosing directory of the source file from which this Shred's code is derived (same as .dir()).",
            "```chuck\nstring sourcePath()\n```\nGet the path of the source file from which this Shred's code is derived (same as .path()).",
            "```chuck\nvoid yield()\n```\nCause the current Shred to temporarily suspend without advancing time, allowing other simultaneously schreduled shreds to run as needed. NOTE: yield() is equivalent to '0::second +=> now;'",
            "```chuck\nShred ancestor()\n```\nGet the calling shred's \"ancestor\" shred (i.e., the top-level shred). Returns itself if the calling shred is the top-level shred. (Related: see Shred.parent())",
            "```chuck\nShred fromId(int id)\n```\nGet Shred corresponding to a Shred ID.",
            "```chuck\nShred parent()\n```\nGet the calling shred's parent shred (i.e., the shred that sporked the calling shred). Returns null if there is no parent Shred. (Related: see Shred.ancestor())"
        ],
        "link": "[More...](https://chuck.stanford.edu/doc/reference/base.html#Shred)"
    },
    "Sigmund": {
        "title": "**Sigmund**",
        "description": "Sinusoidal analysis & pitch tracking. Adapted from Miller Puckettes sigmund~ Max object.",
        "constructors": [
            "**Constructors:**",
            "```chuck\nSigmund()\n```\n"
        ],
        "examples": [
            "Examples: \t [Sigmund.ck](https://chuck.stanford.edu/doc/examples/analysis/Sigmund.ck)"
        ],
        "functions": [
            "**Methods:**",
            "```chuck\nfloat amp(int amp)\n```\nReport amplitude of nth sinusoundal peak sorting depends on parameter \"tracks.\"",
            "```chuck\nvoid clear()\n```\nClear buffers and reset.",
            "```chuck\nfloat env()\n```\nGet reported RMS value (in dB) of input signal.",
            "```chuck\nfloat freq()\n```\nGet reported frequency of input signal.",
            "```chuck\nfloat maxfreq(float arg)\n```\nSet maximum frequency of sinusoidal peaks to look for. This can be useful in situations where background noise creates high-frequency, spurious peaks...",
            "```chuck\nfloat minpower(float arg)\n```\nSet the minimum dB level to report a pitch. Signals quieter than this will be assumed to be crosstalk and ignored. default: 50.",
            "```chuck\nint npeak(int npeak)\n```\nSet the maximum number of sinusoidal peaks to look for. The computation time is quadratic in the number of peaks actually found (this number only sets an upper limit). Use it to balance CPU time with quality of results.",
            "```chuck\nint npts(int npts)\n```\nSet the number of points used in analysis. Must be a power of 2, at least 128. The minimum frequency that can be tracked is about 2 * samplerate / npts. Default: 1024.",
            "```chuck\nfloat param1(float arg)\n```\nMysterious setting...",
            "```chuck\nfloat param2(float arg)\n```\nMysterious setting...",
            "```chuck\nfloat param3(float arg)\n```\nMysterious setting...",
            "```chuck\nfloat peak(int peak)\n```\nReport freq of nth sinusoundal peak sorting. Depends on parameter \"tracks.\"",
            "```chuck\ndur stabletime(dur stabletime)\n```\nSet period of stability needed for note. Not implemented.",
            "```chuck\nint tracks(int tracks)\n```\nToggle whether peak and amp are sorted in order of amplitude or organized into tracks. Default false."
        ],
        "link": "[More...](https://chuck.stanford.edu/doc/reference/chugins.html#Sigmund)"
    },
    "SinOsc": {
        "title": "**Sine Wave Oscillator**",
        "description": "A sine wave oscillator.",
        "constructors": [
            "**Constructors:**",
            "```chuck\nSinOsc()\n```\nDefault constructor for SinOsc.",
            "```chuck\nSinOsc(float freq)\n```\nConstruct SinOsc at specified frequency.",
            "```chuck\nSinOsc(float freq, float phase)\n```\nConstruct SinOsc at specified frequency and phase."
        ],
        "examples": [
            "Examples: \t [otf_05.ck](https://chuck.stanford.edu/doc/examples/otf_05.ck), [otf_06.ck](https://chuck.stanford.edu/doc/examples/otf_06.ck), [foo.ck](https://chuck.stanford.edu/doc/examples/basic/foo.ck), [bar.ck](https://chuck.stanford.edu/doc/examples/basic/bar.ck), [chirp.ck](https://chuck.stanford.edu/doc/examples/basic/chirp.ck), [alarm.ck](https://chuck.stanford.edu/doc/examples/basic/alarm.ck), [whirl.ck](https://chuck.stanford.edu/doc/examples/basic/whirl.ck), [fft.ck](https://chuck.stanford.edu/doc/examples/analysis/fft.ck)"
        ],
        "functions": [
            "**Methods:**",
            "```chuck\nfloat freq(float hz)\n```\nSet frequency of oscillator in Hertz; maintains phase.",
            "```chuck\nfloat freq()\n```\nGet frequency of oscillator in Hertz.",
            "```chuck\ndur period(dur value)\n```\nSet period of oscillator (inverse of frequency).",
            "```chuck\ndur period()\n```\nGet period of oscillator (inverse of frequency).",
            "```chuck\nfloat phase(float phase)\n```\nSet oscillator phase, in range [0,1).",
            "```chuck\nfloat phase()\n```\nGet oscillator phase, in range [0,1).",
            "```chuck\nfloat sfreq(float hz)\n```\nSet frequency of oscillator in Hertz; resets phase to 0.",
            "```chuck\nint sync(int type)\n```\nChoose how to interpret input: (0) sync frequency to input; (1) sync phase to input; (2) frequency modulation (add input to internal frequency).",
            "```chuck\nint sync()\n```\nGet current interpretation of input: (0) sync frequency to input; (1) sync phase to input; (2) frequency modulation (add input to internal frequency).",
            "```chuck\nint buffered(int val)\n```\nSet the unit generator's buffered operation mode, typically used externally from hosts that embed ChucK as a component. If true, the UGen stores a buffer of its most recent samples, which can be fetched using global variables in the host language.",
            "```chuck\nint buffered()\n```\nGet the ugen's buffered operation mode.",
            "```chuck\nUGen chan(int num)\n```\nGet channel (as a UGen) at specified index.",
            "```chuck\nint channels(int num)\n```\nSet number of channels. (currently NOT supported)",
            "```chuck\nint channels()\n```\nGet number of channels.",
            "```chuck\nfloat gain(float val)\n```\nSet the gain of the unit generator.",
            "```chuck\nfloat gain()\n```\nGet the gain of the unit generator.",
            "```chuck\nint isConnectedTo(UGen rhs)\n```\nReturn true if this UGen's output is connected to the input of rhs; if either this UGen or rhs has more than one channel, this function returns true if any connections exist between the channels; return false if there are no connections.",
            "```chuck\nfloat last()\n```\nGet the last sample value of the unit generator.",
            "```chuck\nint op(int val)\n```\nSet the unit generator's operation mode. Accepted values are: 1 (sum inputs), 2 (take difference between first input and subsequent inputs), 3 (multiply inputs), 4 (divide first input by subsequent inputs), 0 (do not synthesize audio, output 0) or -1 (passthrough inputs to output).",
            "```chuck\nint op()\n```\nGet the unit generator's operation mode."
        ],
        "link": "[More...](https://chuck.stanford.edu/doc/reference/ugens-basic.html#SinOsc)"
    },
    "Sitar": {
        "title": "**STK Sitar**",
        "description": "This class implements a sitar plucked string physical model based on the Karplus-Strong algorithm.   This is a digital waveguide model, making its use possibly subject to patents held by Stanford University, Yamaha, and others. There exist at least two patents, assigned to Stanford, bearing the names of Karplus and/or Strong. by Perry R. Cook and Gary P. Scavone, 1995 - 2002.",
        "constructors": [
            "**Constructors:**",
            "```chuck\nSitar()\n```\nDefault constructor for Sitar."
        ],
        "examples": [
            "Examples: \t [sitar.ck](https://chuck.stanford.edu/doc/examples/stk/sitar.ck)"
        ],
        "functions": [
            "**Methods:**",
            "```chuck\nfloat clear(float value)\n```\nClear instrument.",
            "```chuck\nfloat pluck(float value)\n```\nPluck string."
        ],
        "link": "[More...](https://chuck.stanford.edu/doc/reference/ugens-stk.html#Sitar)"
    },
    "SndBuf": {
        "title": "**Sound Buffer**",
        "description": "An interpolating sound buffer/player with single-channel output; can read audio data from a variety of uncompressed formats.",
        "constructors": [
            "**Constructors:**",
            "```chuck\nSndBuf()\n```\nDefault constructor for SndBuf.",
            "```chuck\nSndBuf(string path)\n```\nConstruct a SndBuf with the 'path' to a sound file to read.",
            "```chuck\nSndBuf(string path, float rate)\n```\nConstruct a SndBuf with the 'path' to a sound file to read, and a default playback 'rate' (1.0 is normal rate)",
            "```chuck\nSndBuf(string path, float rate, int pos)\n```\nConstruct a SndBuf with the 'path' to a sound file to read, a default playback 'rate' (1.0 is normal rate), and starting at sample position 'pos'"
        ],
        "examples": [
            "Examples: \t [sndbuf.ck](https://chuck.stanford.edu/doc/examples/basic/sndbuf.ck), [doh.ck](https://chuck.stanford.edu/doc/examples/basic/doh.ck), [valueat.ck](https://chuck.stanford.edu/doc/examples/basic/valueat.ck), [otf_01.ck](https://chuck.stanford.edu/doc/examples/otf_01.ck), [otf_02.ck](https://chuck.stanford.edu/doc/examples/otf_02.ck), [otf_03.ck](https://chuck.stanford.edu/doc/examples/otf_03.ck), [otf_04.ck](https://chuck.stanford.edu/doc/examples/otf_04.ck)"
        ],
        "functions": [
            "**Methods:**",
            "```chuck\nint channel(int channel)\n```\nFor sound file containing more than one channel of audio, select the channel to play.",
            "```chuck\nint channel()\n```\nGet the selected chanel of audio this buffer is playing.",
            "```chuck\nint channels()\n```\nGet number of channels available in the sound file.",
            "```chuck\nint chunks(int frames)\n```\nSet chunk size, in frames, for loading the file from disk. Set to 0 to disable chunking.",
            "```chuck\nint chunks()\n```\nGet chunk size, in frames, for loading the file from disk. 0 indicates that chunking is disabled.",
            "```chuck\nint frames()\n```\nGet total number of sample frames in the file; same as .samples().",
            "```chuck\nfloat freq(float freq)\n```\nSet loop rate (in file loops per second).",
            "```chuck\nfloat freq()\n```\nGet loop rate (in file loops per second).",
            "```chuck\nint interp(int interp)\n```\nSet interpolation mode: (0) drop sample; (1) linear interpolation; (2) sinc interpolation.",
            "```chuck\nint interp()\n```\nGet interpolation mode: (0) drop sample; (1) linear interpolation; (2) sinc interpolation.",
            "```chuck\ndur length()\n```\nGet total length of the file as a duration.",
            "```chuck\nint loop(int loop)\n```\nToggle looping file playback.",
            "```chuck\nint loop()\n```\nGet whether file playback is set to loop.",
            "```chuck\nfloat phase(float phase)\n```\nSet phase position, normalized to [0,1).",
            "```chuck\nfloat phase()\n```\nGet phase position, normalized to [0,1).",
            "```chuck\nfloat phaseOffset(float value)\n```\nAdvance the playhead by the specified phase offset in [0,1), where 0 is no advance and 1 advance the entire length of the file.",
            "```chuck\nfloat play(float play)\n```\n(same as .rate)",
            "```chuck\nfloat play()\n```\n(same as .rate)",
            "```chuck\nint pos(int pos)\n```\nSet play position (between 0 and number of samples).",
            "```chuck\nint pos()\n```\nGet play position (between 0 and number of samples).",
            "```chuck\nfloat rate(float rate)\n```\nSet playback rate (relative to file's natural speed). For example, 1.0 is 'normal', 0.5 is half speed, and 2 is twice as fast.",
            "```chuck\nfloat rate()\n```\nGet playback rate (relative to file's natural speed). For example, 1.0 is 'normal', 0.5 is half speed, and 2 is twice as fast.",
            "```chuck\nstring read(string read)\n```\nRead file for reading.",
            "```chuck\nint ready()\n```\nQuery whether the SndBuf is ready for use (e.g., sound file successfully loaded).",
            "```chuck\nint samples()\n```\nGet total number of sample frames in the file; same as .frames().",
            "```chuck\nfloat valueAt(int pos)\n```\nGet sample value at given position (in samples).",
            "```chuck\nstring write(string read)\n```\nSet file for writing (currently unsupported)."
        ],
        "link": "[More...](https://chuck.stanford.edu/doc/reference/ugens-basic.html#SndBuf)"
    },
    "SndBuf2": {
        "title": "**Sound Buffer (Stereo)**",
        "description": "An interpolating sound buffer with two-channel output. Reads from a variety of uncompressed formats.",
        "constructors": [
            "**Constructors:**",
            "```chuck\nSndBuf2()\n```\nDefault constructor for SndBuf2."
        ],
        "examples": [],
        "functions": [
            "**Methods:**",
            "```chuck\nint channel(int channel)\n```\nFor sound file containing more than one channel of audio, select the channel to play.",
            "```chuck\nint channel()\n```\nGet the selected chanel of audio this buffer is playing.",
            "```chuck\nint channels()\n```\nGet number of channels available in the sound file.",
            "```chuck\nint chunks(int frames)\n```\nSet chunk size, in frames, for loading the file from disk. Set to 0 to disable chunking.",
            "```chuck\nint chunks()\n```\nGet chunk size, in frames, for loading the file from disk. 0 indicates that chunking is disabled.",
            "```chuck\nint frames()\n```\nGet total number of sample frames in the file; same as .samples().",
            "```chuck\nfloat freq(float freq)\n```\nSet loop rate (in file loops per second).",
            "```chuck\nfloat freq()\n```\nGet loop rate (in file loops per second).",
            "```chuck\nint interp(int interp)\n```\nSet interpolation mode: (0) drop sample; (1) linear interpolation; (2) sinc interpolation.",
            "```chuck\nint interp()\n```\nGet interpolation mode: (0) drop sample; (1) linear interpolation; (2) sinc interpolation.",
            "```chuck\ndur length()\n```\nGet total length of the file as a duration.",
            "```chuck\nint loop(int loop)\n```\nToggle looping file playback.",
            "```chuck\nint loop()\n```\nGet whether file playback is set to loop.",
            "```chuck\nfloat phase(float phase)\n```\nSet phase position, normalized to [0,1).",
            "```chuck\nfloat phase()\n```\nGet phase position, normalized to [0,1).",
            "```chuck\nfloat phaseOffset(float value)\n```\nAdvance the playhead by the specified phase offset in [0,1), where 0 is no advance and 1 advance the entire length of the file.",
            "```chuck\nfloat play(float play)\n```\n(same as .rate)",
            "```chuck\nfloat play()\n```\n(same as .rate)",
            "```chuck\nint pos(int pos)\n```\nSet play position (between 0 and number of samples).",
            "```chuck\nint pos()\n```\nGet play position (between 0 and number of samples).",
            "```chuck\nfloat rate(float rate)\n```\nSet playback rate (relative to file's natural speed). For example, 1.0 is 'normal', 0.5 is half speed, and 2 is twice as fast.",
            "```chuck\nfloat rate()\n```\nGet playback rate (relative to file's natural speed). For example, 1.0 is 'normal', 0.5 is half speed, and 2 is twice as fast.",
            "```chuck\nstring read(string read)\n```\nRead file for reading.",
            "```chuck\nint ready()\n```\nQuery whether the SndBuf is ready for use (e.g., sound file successfully loaded).",
            "```chuck\nint samples()\n```\nGet total number of sample frames in the file; same as .frames().",
            "```chuck\nfloat valueAt(int pos)\n```\nGet sample value at given position (in samples).",
            "```chuck\nstring write(string read)\n```\nSet file for writing (currently unsupported)."
        ],
        "link": "[More...](https://chuck.stanford.edu/doc/reference/ugens-basic.html#SndBuf2)"
    },
    "Spectacle": {
        "title": "**Spectral Delay and EQ**",
        "description": "FFT-based spectral delay and EQ by John Gibson. Inspired by the totally awesome Spektral Delay plug-in by Native Instruments.",
        "constructors": [
            "**Constructors:**",
            "```chuck\nSpectacle()\n```\n"
        ],
        "examples": [
            "Examples: \t [Spectacle.ck](https://chuck.stanford.edu/doc/examples/effects/Spectacle.ck)"
        ],
        "functions": [
            "**Methods:**",
            "```chuck\nint bands(int arg)\n```\nSet number of frequency bands, [1 - 512], default 64.",
            "```chuck\nint bands()\n```\nGet number of frequency bands, [1 - 512], default 64.",
            "```chuck\nvoid clear()\n```\nReset Spectacle.",
            "```chuck\ndur delay(dur delay)\n```\nSet the same delay duration for all bands.",
            "```chuck\ndur delayMax(dur delay)\n```\nSet maximum delay time.",
            "```chuck\ndur delayMax()\n```\nGet maximum delay time.",
            "```chuck\ndur delayMin(dur delay)\n```\nSet minimum delay time.",
            "```chuck\ndur delayMin()\n```\nGet minimum delay time.",
            "```chuck\nfloat eq(float eq)\n```\nSet the same EQ value for all bands (value is +/- dB).",
            "```chuck\nfloat feedback(float feedback)\n```\nSet the same feedback value for all bands [-1.0 - 1.0].",
            "```chuck\nint fftlen(int arg)\n```\nSet FFT frame size (power of 2).",
            "```chuck\nint fftlen()\n```\nGet FFT frame size (power of 2).",
            "```chuck\nfloat freqMax(float arg)\n```\nSet maximum frequency processed by Spectacle.",
            "```chuck\nfloat freqMax()\n```\nGet maximum frequency processed by Spectacle.",
            "```chuck\nfloat freqMin(float arg)\n```\nSet minimum frequency processed by Spectacle.",
            "```chuck\nfloat freqMin()\n```\nGet minimum frequency processed by Spectacle.",
            "```chuck\nint hold(int arg)\n```\nSet hold. True to suppress input, false disables.",
            "```chuck\nint hold()\n```\nGet hold. True to suppress input, false disables.",
            "```chuck\nfloat mix(float mix)\n```\nSet mix of processed and unprocessed signal [0 - 1].",
            "```chuck\nfloat mix()\n```\nGet mix of processed and unprocessed signal [0 - 1].",
            "```chuck\nint overlap(int arg)\n```\nSet frame overlap; best between 2 and 6.",
            "```chuck\nint overlap()\n```\nGet frame overlap; best between 2 and 6.",
            "```chuck\nint posteq(int arg)\n```\nSet posteq to true to apply EQ after delay, rather than before.",
            "```chuck\nint posteq()\n```\nGet posteq. True applies EQ after delay, rather than before.",
            "```chuck\nvoid range(float arg1, float arg2)\n```\nSet both min and max freqs in one command.",
            "```chuck\nint table(string table, string type)\n```\nSet \"delay\", eq, or \"feedback\" tables to the types \"random\", \"ascending\", or \"descending.\" Example: table(\"delay\", \"random\");."
        ],
        "link": "[More...](https://chuck.stanford.edu/doc/reference/chugins.html#Spectacle)"
    },
    "SqrOsc": {
        "title": "**Square Wave Oscillator**",
        "description": "A square wave oscillator (same as PulseOsc with 0.5 duty cycle).",
        "constructors": [
            "**Constructors:**",
            "```chuck\nSqrOsc()\n```\nDefault constructor for SqrOsc.",
            "```chuck\nSqrOsc(float freq)\n```\nConstruct SqrOsc at specified frequency.",
            "```chuck\nSqrOsc(float freq, float phase)\n```\nConstruct SqrOsc at specified frequency and phase."
        ],
        "examples": [
            "Examples: \t [oscillatronx.ck](https://chuck.stanford.edu/doc/examples/basic/oscillatronx.ck), [brf.ck](https://chuck.stanford.edu/doc/examples/filter/brf.ck), [rlpf.ck](https://chuck.stanford.edu/doc/examples/filter/rlpf.ck), [rhpf.ck](https://chuck.stanford.edu/doc/examples/filter/rhpf.ck)"
        ],
        "functions": [
            "**Methods:**",
            "```chuck\nfloat freq(float hz)\n```\nSet frequency of oscillator in Hertz; maintains phase.",
            "```chuck\nfloat freq()\n```\nGet frequency of oscillator in Hertz.",
            "```chuck\ndur period(dur value)\n```\nSet period of oscillator (inverse of frequency).",
            "```chuck\ndur period()\n```\nGet period of oscillator (inverse of frequency).",
            "```chuck\nfloat phase(float phase)\n```\nSet oscillator phase, in range [0,1).",
            "```chuck\nfloat phase()\n```\nGet oscillator phase, in range [0,1).",
            "```chuck\nfloat sfreq(float hz)\n```\nSet frequency of oscillator in Hertz; resets phase to 0.",
            "```chuck\nint sync(int type)\n```\nChoose how to interpret input: (0) sync frequency to input; (1) sync phase to input; (2) frequency modulation (add input to internal frequency).",
            "```chuck\nint sync()\n```\nGet current interpretation of input: (0) sync frequency to input; (1) sync phase to input; (2) frequency modulation (add input to internal frequency).",
            "```chuck\nint buffered(int val)\n```\nSet the unit generator's buffered operation mode, typically used externally from hosts that embed ChucK as a component. If true, the UGen stores a buffer of its most recent samples, which can be fetched using global variables in the host language.",
            "```chuck\nint buffered()\n```\nGet the ugen's buffered operation mode.",
            "```chuck\nUGen chan(int num)\n```\nGet channel (as a UGen) at specified index.",
            "```chuck\nint channels(int num)\n```\nSet number of channels. (currently NOT supported)",
            "```chuck\nint channels()\n```\nGet number of channels.",
            "```chuck\nfloat gain(float val)\n```\nSet the gain of the unit generator.",
            "```chuck\nfloat gain()\n```\nGet the gain of the unit generator.",
            "```chuck\nint isConnectedTo(UGen rhs)\n```\nReturn true if this UGen's output is connected to the input of rhs; if either this UGen or rhs has more than one channel, this function returns true if any connections exist between the channels; return false if there are no connections.",
            "```chuck\nfloat last()\n```\nGet the last sample value of the unit generator.",
            "```chuck\nint op(int val)\n```\nSet the unit generator's operation mode. Accepted values are: 1 (sum inputs), 2 (take difference between first input and subsequent inputs), 3 (multiply inputs), 4 (divide first input by subsequent inputs), 0 (do not synthesize audio, output 0) or -1 (passthrough inputs to output).",
            "```chuck\nint op()\n```\nGet the unit generator's operation mode.",
            "```chuck\nfloat width()\n```\nSet width of duty cycle (always 0.5)."
        ],
        "link": "[More...](https://chuck.stanford.edu/doc/reference/ugens-basic.html#SqrOsc)"
    },
    "Std": {
        "title": "**ChucK Standard Library**",
        "description": "A standard library in ChucK, which includes utility functions for random number generation, unit conversions, and absolute value.",
        "constructors": [],
        "examples": [],
        "functions": [
            "**Methods:**",
            "```chuck\nint abs(int value)\n```\nReturn absolute value of integer.",
            "```chuck\nfloat atof(string value)\n```\nConverts ascii (string) to floating point value (float).",
            "```chuck\nint atoi(string value)\n```\nConvert ascii (string) to integer (int).",
            "```chuck\nint clamp(int value, int min, int max)\n```\nClamp integer to range [min, max].",
            "```chuck\nfloat clampf(float value, float min, float max)\n```\nClamp float to range [min, max].",
            "```chuck\nfloat dbtolin(float value)\n```\nConvert decibels (dB) to linear amplitude.",
            "```chuck\nfloat dbtopow(float value)\n```\nConvert decibels (dB) to signal power ratio.",
            "```chuck\nfloat dbtorms(float value)\n```\nConvert decibels (dB) to rms.",
            "```chuck\nfloat fabs(float value)\n```\nReturn absolute value of float.",
            "```chuck\nstring ftoa(float f, int precision)\n```\nConverts floating point value (float) to ascii (string) with specified precision (number of decimal digits).",
            "```chuck\nint ftoi(float f)\n```\nConvert float to integer.",
            "```chuck\nfloat ftom(float value)\n```\nConvert frequency (Hz) to MIDI note number space.",
            "```chuck\nstring getenv(string key)\n```\nGet the value of an environment variable (e.g., PATH).",
            "```chuck\nstring getenv(string key, string default)\n```\nGet the value of an environment variable, returning the provided default if unset.",
            "```chuck\nstring itoa(int i)\n```\nConverts integer (int) to ascii (string).",
            "```chuck\nfloat lintodb(float value)\n```\nConvert linear amplitude to decibels (dB).",
            "```chuck\nfloat mtof(float value)\n```\nConvert a MIDI note number to frequency (Hz). Note the input value is of type float (supports fractional note number). For reference, MIDI note number 60 is Middle C; each whole number is one semitone.",
            "```chuck\nfloat powtodb(float value)\n```\nConvert signal power ratio to decibels (dB).",
            "```chuck\nint rand2(int min, int max)\n```\nGenerate a random integer in range [min, max]. (NOTE: this is deprecated; use Math.random2()).",
            "```chuck\nfloat rand2f(float min, float max)\n```\nGenerate random floating point number in the range [min, max]. (NOTE: this is deprecated; use Math.random2f())",
            "```chuck\nint rand()\n```\nGenerate a random integer between 0 and Std.RAND_MAX. (NOTE: this is deprecated; use Math.random()).",
            "```chuck\nfloat randf()\n```\nGenerate random floating point number in the range [-1, 1]. (Note: this is deprecated; use Math.randomf())",
            "```chuck\nint[] range(int stop)\n```\nReturn array containing the range [0,stop).",
            "```chuck\nint[] range(int start, int stop)\n```\nReturn array containing the range [start,stop).",
            "```chuck\nint[] range(int start, int stop, int step)\n```\nReturn array containing values from start up to (but not including) stop, hopping by step.",
            "```chuck\nfloat rmstodb(float value)\n```\nConvert rms to decibels (dB).",
            "```chuck\nfloat scalef(float value, float srcmin, float srcmax, float dstmin, float dstmax)\n```\nScale a float from source range to destination range.",
            "```chuck\nint setenv(string key, string value)\n```\nSet the value of environment variable named 'key'",
            "```chuck\nfloat sgn(float value)\n```\nGet sign of value as -1 (negative), 0, or 1 (positive).",
            "```chuck\nvoid srand(int seed)\n```\nSeed the random number generator. Different seeds will likely generate different sequences of random numbers even if the seeds are close together; alternatively, a sequence of random numbers can be repeated by setting the same seed. (NOTE: this is deprecated; use Math.srandom())",
            "```chuck\nint system(string cmd)\n```\nPass a command to be executed in the shell (requires --caution-to-the-wind flag to be set)."
        ],
        "link": "[More...](https://chuck.stanford.edu/doc/reference/base.html#Std)"
    },
    "Step": {
        "title": "**Step Generator**",
        "description": "A step generator. Step behaves like Impulse, except that once a next value is set, that value is held for all following samples, until a different value is set.",
        "constructors": [
            "**Constructors:**",
            "```chuck\nStep()\n```\nDefault constructor for Step.",
            "```chuck\nStep(float value)\n```\nConstruct a Step with default value."
        ],
        "examples": [
            "Examples: \t [step.ck](https://chuck.stanford.edu/doc/examples/basic/step.ck), [fm3.ck](https://chuck.stanford.edu/doc/examples/basic/fm3.ck), [zerox.ck](https://chuck.stanford.edu/doc/examples/basic/zerox.ck)"
        ],
        "functions": [
            "**Methods:**",
            "```chuck\nfloat next(float next)\n```\nSet the next step value.",
            "```chuck\nfloat next()\n```\nGet the next step value."
        ],
        "link": "[More...](https://chuck.stanford.edu/doc/reference/ugens-basic.html#Step)"
    },
    "StifKarp": {
        "title": "**STK Stiff Karplus-Strong**",
        "description": "This class implements a simple plucked string algorithm (Karplus Strong) with enhancements (Jaffe-Smith, Smith, and others), including string stiffness and pluck position controls. The stiffness is modeled with allpass filters. This is a digital waveguide model, making its use possibly subject to patents held by Stanford University, Yamaha, and others. Control Change Numbers: - Pickup Position = 4 - String Sustain = 11 - String Stretch = 1 by Perry R. Cook and Gary P. Scavone, 1995 - 2002.",
        "constructors": [
            "**Constructors:**",
            "```chuck\nStifKarp()\n```\nDefault constructor for StifKarp."
        ],
        "examples": [
            "Examples: \t [stifkarp.ck](https://chuck.stanford.edu/doc/examples/stk/stifkarp.ck), [stif-o-karp.ck](https://chuck.stanford.edu/doc/examples/stk/stif-o-karp.ck)"
        ],
        "functions": [
            "**Methods:**",
            "```chuck\nfloat baseLoopGain(float value)\n```\nSet base loop gain, [0.0-1.0].",
            "```chuck\nfloat baseLoopGain()\n```\nGet base loop gain, [0.0-1.0].",
            "```chuck\nfloat clear(float value)\n```\nClear instrument.",
            "```chuck\nfloat pickupPosition(float value)\n```\nSet pickup position, [0.0-1.0].",
            "```chuck\nfloat pickupPosition()\n```\nGet pickup position, [0.0-1.0].",
            "```chuck\nfloat pluck(float value)\n```\nPluck string.",
            "```chuck\nfloat stretch(float value)\n```\nSet string stretch, [0.0-1.0].",
            "```chuck\nfloat stretch()\n```\nGet string stretch, [0.0-1.0].",
            "```chuck\nfloat sustain(float value)\n```\nSet string sustain, [0.0-1.0].",
            "```chuck\nfloat sustain()\n```\nGet string sustain, [0.0-1.0]."
        ],
        "link": "[More...](https://chuck.stanford.edu/doc/reference/ugens-stk.html#StifKarp)"
    },
    "StkInstrument": {
        "title": "**STK Instrument**",
        "description": "Super-class for STK instruments.",
        "constructors": [
            "**Constructors:**",
            "```chuck\nStkInstrument()\n```\nDefault constructor for StkInstrument."
        ],
        "examples": [],
        "functions": [
            "**Methods:**",
            "```chuck\nvoid controlChange(int ctrl, float value)\n```\nAssert control change; numbers are instrument specific; value range [0.0 - 127.0].",
            "```chuck\nfloat freq(float value)\n```\nSet frequency.",
            "```chuck\nfloat freq()\n```\nGet frequency.",
            "```chuck\nfloat noteOff(float value)\n```\nTrigger note off.",
            "```chuck\nfloat noteOn(float value)\n```\nTrigger note on."
        ],
        "link": "[More...](https://chuck.stanford.edu/doc/reference/ugens-stk.html#StkInstrument)"
    },
    "StringTokenizer": {
        "title": "**String Tokenizer**",
        "description": "Break a string into tokens. This uses whitespace as the delimiter.",
        "constructors": [
            "**Constructors:**",
            "```chuck\nStringTokenizer()\n```\nDefault constructor for StringTokenizer."
        ],
        "examples": [
            "Examples: \t [token.ck](https://chuck.stanford.edu/doc/examples/string/token.ck), [readline.ck](https://chuck.stanford.edu/doc/examples/string/readline.ck), [read-tokens.ck](https://chuck.stanford.edu/doc/examples/io/read-tokens.ck), [jabberwocky.txt](https://chuck.stanford.edu/doc/examples/io/jabberwocky.txt), [word2vec-prompt.ck](https://chuck.stanford.edu/doc/examples/ai/word2vec/word2vec-prompt.ck)"
        ],
        "functions": [
            "**Methods:**",
            "```chuck\nstring get(int index)\n```\nReturn the i-th token in the set string.",
            "```chuck\nstring get(int index, string out)\n```\nReturn the i-th token in the set string. Additionally, write the token string to the `out` string variable.",
            "```chuck\nint more()\n```\nReturn true (1) if there are still more tokens, false (0) if no more tokens.",
            "```chuck\nstring next()\n```\nReturn the next token string.",
            "```chuck\nstring next(string out)\n```\nReturn the next token string. Additionally, write the token string to the 'out' string variable.",
            "```chuck\nvoid reset()\n```\nReset token iteration back to the beginning of the set string.",
            "```chuck\nvoid set(string line)\n```\nSet the string to be tokenized.",
            "```chuck\nint size()\n```\nReturns the number of token strings that the set string can be broken into."
        ],
        "link": "[More...](https://chuck.stanford.edu/doc/reference/utils.html#StringTokenizer)"
    },
    "SubNoise": {
        "title": "**Sub-Sampling Noise Generator**",
        "description": "Generates a new random number every 'rate' ticks using the C `rand()` function. The quality of the r`and()` function varies from one OS to another. by Perry R. Cook and Gary P. Scavone, 1995 - 2002.",
        "constructors": [
            "**Constructors:**",
            "```chuck\nSubNoise()\n```\nDefault constructor for SubNoise."
        ],
        "examples": [
            "Examples: \t [subnoise-control.ck](https://chuck.stanford.edu/doc/examples/stk/subnoise-control.ck), [subnoise-audio.ck](https://chuck.stanford.edu/doc/examples/stk/subnoise-audio.ck)"
        ],
        "functions": [
            "**Methods:**",
            "```chuck\nint rate(int value)\n```\nSet subsampling rate.",
            "```chuck\nint rate()\n```\nGet subsampling rate."
        ],
        "link": "[More...](https://chuck.stanford.edu/doc/reference/ugens-stk.html#SubNoise)"
    },
    "TriOsc": {
        "title": "**Triangle Wave Oscillator**",
        "description": "A triangle wave oscillator.",
        "constructors": [
            "**Constructors:**",
            "```chuck\nTriOsc()\n```\nDefault constructor for TriOsc.",
            "```chuck\nTriOsc(float freq)\n```\nConstruct TriOsc at specified frequency.",
            "```chuck\nTriOsc(float freq, float phase)\n```\nConstruct TriOsc at specified frequency and phase."
        ],
        "examples": [
            "Examples: \t [oscillatronx.ck](https://chuck.stanford.edu/doc/examples/basic/oscillatronx.ck), [shepard.ck](https://chuck.stanford.edu/doc/examples/deep/shepard.ck)"
        ],
        "functions": [
            "**Methods:**",
            "```chuck\nfloat freq(float hz)\n```\nSet frequency of oscillator in Hertz; maintains phase.",
            "```chuck\nfloat freq()\n```\nGet frequency of oscillator in Hertz.",
            "```chuck\ndur period(dur value)\n```\nSet period of oscillator (inverse of frequency).",
            "```chuck\ndur period()\n```\nGet period of oscillator (inverse of frequency).",
            "```chuck\nfloat phase(float phase)\n```\nSet oscillator phase, in range [0,1).",
            "```chuck\nfloat phase()\n```\nGet oscillator phase, in range [0,1).",
            "```chuck\nfloat sfreq(float hz)\n```\nSet frequency of oscillator in Hertz; resets phase to 0.",
            "```chuck\nint sync(int type)\n```\nChoose how to interpret input: (0) sync frequency to input; (1) sync phase to input; (2) frequency modulation (add input to internal frequency).",
            "```chuck\nint sync()\n```\nGet current interpretation of input: (0) sync frequency to input; (1) sync phase to input; (2) frequency modulation (add input to internal frequency).",
            "```chuck\nint buffered(int val)\n```\nSet the unit generator's buffered operation mode, typically used externally from hosts that embed ChucK as a component. If true, the UGen stores a buffer of its most recent samples, which can be fetched using global variables in the host language.",
            "```chuck\nint buffered()\n```\nGet the ugen's buffered operation mode.",
            "```chuck\nUGen chan(int num)\n```\nGet channel (as a UGen) at specified index.",
            "```chuck\nint channels(int num)\n```\nSet number of channels. (currently NOT supported)",
            "```chuck\nint channels()\n```\nGet number of channels.",
            "```chuck\nfloat gain(float val)\n```\nSet the gain of the unit generator.",
            "```chuck\nfloat gain()\n```\nGet the gain of the unit generator.",
            "```chuck\nint isConnectedTo(UGen rhs)\n```\nReturn true if this UGen's output is connected to the input of rhs; if either this UGen or rhs has more than one channel, this function returns true if any connections exist between the channels; return false if there are no connections.",
            "```chuck\nfloat last()\n```\nGet the last sample value of the unit generator.",
            "```chuck\nint op(int val)\n```\nSet the unit generator's operation mode. Accepted values are: 1 (sum inputs), 2 (take difference between first input and subsequent inputs), 3 (multiply inputs), 4 (divide first input by subsequent inputs), 0 (do not synthesize audio, output 0) or -1 (passthrough inputs to output).",
            "```chuck\nint op()\n```\nGet the unit generator's operation mode.",
            "```chuck\nfloat width(float width)\n```\nSet width of triangle wave (ratio of rise time to fall time).",
            "```chuck\nfloat width()\n```\nGet width of triangle wave (ratio of rise time to fall time)."
        ],
        "link": "[More...](https://chuck.stanford.edu/doc/reference/ugens-basic.html#TriOsc)"
    },
    "TubeBell": {
        "title": "**STK Tubular Bell**",
        "description": "STK tubular bell (orchestral chime) FM synthesis instrument. This class implements two simple FM Pairs summed together, also referred to as algorithm 5 of the TX81Z. Algorithm 5 is :     4->3--   + --> Out   2->1--   Control Change Numbers: - Modulator Index One = 2 (.controlOne) - Crossfade of Outputs = 4 (.controlTwo) - LFO Speed = 11 - LFO Depth = 1 - ADSR 2 & 4 Target = 128 The basic Chowning/Stanford FM patent expired in 1995, but there exist follow-on patents, mostly assigned to Yamaha. If you are of the type who should worry about this (making money) worry away. by Perry R. Cook and Gary P. Scavone, 1995 - 2002.",
        "constructors": [
            "**Constructors:**",
            "```chuck\nTubeBell()\n```\nDefault constructor for TubeBell."
        ],
        "examples": [],
        "functions": [],
        "link": "[More...](https://chuck.stanford.edu/doc/reference/ugens-stk.html#TubeBell)"
    },
    "TwoPole": {
        "title": "**Two-Pole Filter**",
        "description": "This Filter subclass implements a two-pole digital filter. A method is provided for creating a resonance in the frequency response while maintaining a nearly constant filter gain. by Perry R. Cook and Gary P. Scavone, 1995 - 2002.",
        "constructors": [
            "**Constructors:**",
            "```chuck\nTwoPole()\n```\nDefault constructor for TwoPole."
        ],
        "examples": [
            "Examples: \t [powerup.ck](https://chuck.stanford.edu/doc/examples/shred/powerup.ck)"
        ],
        "functions": [
            "**Methods:**",
            "```chuck\nfloat a1(float value)\n```\nSet filter coefficient.",
            "```chuck\nfloat a1()\n```\nGet filter coefficient.",
            "```chuck\nfloat a2(float value)\n```\nSet filter coefficient.",
            "```chuck\nfloat a2()\n```\nGet filter coefficient.",
            "```chuck\nfloat b0(float value)\n```\nSet filter coefficient.",
            "```chuck\nfloat b0()\n```\nGet filter coefficient.",
            "```chuck\nfloat freq(float value)\n```\nSet filter resonance frequency.",
            "```chuck\nfloat freq()\n```\nGet filter resonance frequency.",
            "```chuck\nint norm(int value)\n```\nSet filter normalization.",
            "```chuck\nint norm()\n```\nGet filter normalization.",
            "```chuck\nfloat radius(float value)\n```\nSet filter radius resonance.",
            "```chuck\nfloat radius()\n```\nGet filter radius resonance."
        ],
        "link": "[More...](https://chuck.stanford.edu/doc/reference/ugens-filters.html#TwoPole)"
    },
    "TwoZero": {
        "title": "**Two-Zero Filter**",
        "description": "This Filter subclass implements a two-zero digital filter. A method is provided for creating a 'notch' in the frequency response while maintaining a constant filter gain. by Perry R. Cook and Gary P. Scavone, 1995 - 2002.",
        "constructors": [
            "**Constructors:**",
            "```chuck\nTwoZero()\n```\nDefault constructor for TwoZero."
        ],
        "examples": [
            "Examples: \t [chant.ck](https://chuck.stanford.edu/doc/examples/deep/chant.ck), [say-chu.ck](https://chuck.stanford.edu/doc/examples/deep/say-chu.ck)"
        ],
        "functions": [
            "**Methods:**",
            "```chuck\nfloat b0(float value)\n```\nSet filter coefficient.",
            "```chuck\nfloat b0()\n```\nGet filter coefficient.",
            "```chuck\nfloat b1(float value)\n```\nSet filter coefficient.",
            "```chuck\nfloat b1()\n```\nGet filter coefficient.",
            "```chuck\nfloat b2(float value)\n```\nSet filter coefficient.",
            "```chuck\nfloat b2()\n```\nGet filter coefficient.",
            "```chuck\nfloat freq(float value)\n```\nSet filter notch frequency.",
            "```chuck\nfloat freq()\n```\nGet filter notch frequency.",
            "```chuck\nfloat radius(float value)\n```\nSet filter notch radius.",
            "```chuck\nfloat radius()\n```\nGet filter notch radius."
        ],
        "link": "[More...](https://chuck.stanford.edu/doc/reference/ugens-filters.html#TwoZero)"
    },
    "Type": {
        "title": "**ChucK Type Class**",
        "description": "A representation of a ChucK type.",
        "constructors": [
            "**Constructors:**",
            "```chuck\nType()\n```\nDefault constructor for Type."
        ],
        "examples": [
            "Examples: \t [type_type.ck](https://chuck.stanford.edu/doc/examples/type/type_type.ck), [type_query.ck](https://chuck.stanford.edu/doc/examples/type/type_query.ck)"
        ],
        "functions": [
            "**Methods:**",
            "```chuck\nint arrayDepth()\n```\nReturn the number of array dimensions associated with this Type (e.g., 'int[][]' has 2; 'int' has 0).",
            "```chuck\nstring baseName()\n```\nReturn the base name of this Type. The base of name of an array Type is the type without the array dimensions (e.g., base name of 'int[][]' is 'int')",
            "```chuck\nType[] children()\n```\nRetrieve this Type's children Types.",
            "```chuck\nint equals(Type another)\n```\nReturn whether this Type is same as 'another'.",
            "```chuck\nint isArray()\n```\nReturn whether this Type is some kind of an array.",
            "```chuck\nint isPrimitive()\n```\nReturn whether this is a primitive Type (e.g., 'int' and 'dur' are primitives types; 'Object' and its children Types are not).",
            "```chuck\nint isa(Type another)\n```\nReturn whether this Type is a kind of 'another'.",
            "```chuck\nint isa(string another)\n```\nReturn whether this Type is a kind of 'another'.",
            "```chuck\nstring name()\n```\nReturn the name of this Type.",
            "```chuck\nstring origin()\n```\nReturn a string describing where this Type was defined (e.g., \"builtin\", \"chugin\", \"cklib\", \"user\").",
            "```chuck\nType parent()\n```\nReturn this Type's parent Type; returns null if this Type is 'Object'.",
            "```chuck\nType find(string typeName)\n```\nFind and return the Type associated with 'typeName'; returns null if no Types currently in the VM with that name.",
            "```chuck\nType[] getTypes(int attributes, int origins)\n```\nRetrieve all top-level Types in the ChucK runtime type system that fit the attributes and origins flags. Flags that can bitwise-OR'ed for attributes: Type.ATTRIB_OBJECT, Type.ATTRIB_PRIMITIVE, TYPE_SPECIAL -- and for origins: Type.ORIGIN_BUILTIN, Type.ORIGIN_CHUGIN, Type.ORIGIN_CKLIB, Type.ORIGIN_USER.",
            "```chuck\nType[] getTypes()\n```\nRetrieves all top-level Types currently in the type system.",
            "```chuck\nType of(Object obj)\n```\nReturn the Type of 'obj'",
            "```chuck\nType of(int val)\n```\nReturn the Type associated with 'int'.",
            "```chuck\nType of(float val)\n```\nReturn the Type associated with 'float'.",
            "```chuck\nType of(time val)\n```\nReturn the Type associated with 'time'.",
            "```chuck\nType of(dur val)\n```\nReturn the Type associated with 'dur'.",
            "```chuck\nType of(complex val)\n```\nReturn the Type associated with 'complex'.",
            "```chuck\nType of(polar val)\n```\nReturn the Type associated with 'polar'.",
            "```chuck\nType of(vec3 val)\n```\nReturn the Type associated with 'vec3'.",
            "```chuck\nType of(vec4 val)\n```\nReturn the Type associated with 'vec4'."
        ],
        "link": "[More...](https://chuck.stanford.edu/doc/reference/utils.html#Type)"
    },
    "UAna": {
        "title": "**Unit Analyzer Base Class**",
        "description": "Base class from which all unit analyzer (UAna) types inherit; UAnae (note plural form) can be interconnected using => (chuck operator for synthesis; all UAnae are also UGens) or using =^ (upchuck operator for analysis) -- the operator used will determine how data is passed. When .upchuck() is invoked on a given UAna, the UAna-chain (i.e., UAnae connected via =^) is traversed upstream from the upchucked UAna, and analysis is performed at each UAna along the chain; the analysis results are returned in UAnaBlobs.",
        "constructors": [
            "**Constructors:**",
            "```chuck\nUAna()\n```\nDefault constructor for UAna."
        ],
        "examples": [],
        "functions": [
            "**Methods:**",
            "```chuck\ncomplex cval(int index)\n```\nGet blob's complex value at index.",
            "```chuck\ncomplex[] cvals()\n```\nGet blob's complex array.",
            "```chuck\nfloat fval(int index)\n```\nGet blob's float value at index.",
            "```chuck\nfloat[] fvals()\n```\nGet blob's float array.",
            "```chuck\nint isUpConnectedTo(UAna right)\n```\nIs connected to another uana via =^?",
            "```chuck\nUAnaBlob upchuck()\n```\nInitiate analysis at the UAna and return result."
        ],
        "link": "[More...](https://chuck.stanford.edu/doc/reference/uanae.html#UAna)"
    },
    "UAnaBlob": {
        "title": "**Unit Analyzer Blob**",
        "description": "A data structure that contains results associated with UAna analysis. There is a UAnaBlob associated with every UAna. As a UAna is upchucked (using .upchuck()), the result is stored in the UAnaBlob's floating point vector and/or complex vector. The interpretation of the results depends on the specific UAna.",
        "constructors": [
            "**Constructors:**",
            "```chuck\nUAnaBlob()\n```\nDefault constructor for UAnaBlob."
        ],
        "examples": [],
        "functions": [
            "**Methods:**",
            "```chuck\ncomplex cval(int index)\n```\nGet blob's complex value at index.",
            "```chuck\ncomplex[] cvals()\n```\nGet blob's complex array.",
            "```chuck\nfloat fval(int index)\n```\nGet blob's float value at index.",
            "```chuck\nfloat[] fvals()\n```\nGet blob's float array.",
            "```chuck\ntime when()\n```\nGet the time when blob was last upchucked."
        ],
        "link": "[More...](https://chuck.stanford.edu/doc/reference/uanae.html#UAnaBlob)"
    },
    "UGen": {
        "title": "**Unit Generator Base Class**",
        "description": "Base class for all unit generator (UGen) types.",
        "constructors": [
            "**Constructors:**",
            "```chuck\nUGen()\n```\nDefault constructor for UGen."
        ],
        "examples": [],
        "functions": [
            "**Methods:**",
            "```chuck\nint buffered(int val)\n```\nSet the unit generator's buffered operation mode, typically used externally from hosts that embed ChucK as a component. If true, the UGen stores a buffer of its most recent samples, which can be fetched using global variables in the host language.",
            "```chuck\nint buffered()\n```\nGet the ugen's buffered operation mode.",
            "```chuck\nUGen chan(int num)\n```\nGet channel (as a UGen) at specified index.",
            "```chuck\nint channels(int num)\n```\nSet number of channels. (currently NOT supported)",
            "```chuck\nint channels()\n```\nGet number of channels.",
            "```chuck\nfloat gain(float val)\n```\nSet the gain of the unit generator.",
            "```chuck\nfloat gain()\n```\nGet the gain of the unit generator.",
            "```chuck\nint isConnectedTo(UGen rhs)\n```\nReturn true if this UGen's output is connected to the input of rhs; if either this UGen or rhs has more than one channel, this function returns true if any connections exist between the channels; return false if there are no connections.",
            "```chuck\nfloat last()\n```\nGet the last sample value of the unit generator.",
            "```chuck\nint op(int val)\n```\nSet the unit generator's operation mode. Accepted values are: 1 (sum inputs), 2 (take difference between first input and subsequent inputs), 3 (multiply inputs), 4 (divide first input by subsequent inputs), 0 (do not synthesize audio, output 0) or -1 (passthrough inputs to output).",
            "```chuck\nint op()\n```\nGet the unit generator's operation mode."
        ],
        "link": "[More...](https://chuck.stanford.edu/doc/reference/ugens-basic.html#UGen)"
    },
    "UGen_Multi": {
        "title": "**Multi-Channel UGen**",
        "description": "Base class for multi-channel unit generators.",
        "constructors": [
            "**Constructors:**",
            "```chuck\nUGen_Multi()\n```\nDefault constructor for UGen_Multi."
        ],
        "examples": [],
        "functions": [
            "**Methods:**",
            "```chuck\nUGen chan(int which)\n```\nGet UGen representing a specific channel of this UGen, or null if no such channel is available."
        ],
        "link": "[More...](https://chuck.stanford.edu/doc/reference/ugens-basic.html#UGen_Multi)"
    },
    "UGen_Stereo": {
        "title": "**Stereo UGen**",
        "description": "Base class for stereo unit generators.",
        "constructors": [
            "**Constructors:**",
            "```chuck\nUGen_Stereo()\n```\nDefault constructor for UGen_Stereo."
        ],
        "examples": [],
        "functions": [
            "**Methods:**",
            "```chuck\nfloat pan(float val)\n```\nPan between left and right channels, in range [-1,1], with -1 being far-left, 1 far-right, and 0 centered.",
            "```chuck\nfloat pan()\n```\nPan between left and right channels, in range [-1,1], with -1 being far-left, 1 far-right, and 0 centered.",
            "```chuck\nint panType(int val)\n```\nSet the panning type: (1) constant power panning, (0) unity gain anti-panning.",
            "```chuck\nint panType()\n```\nGet the panning type: (1) constant power panning, (0) unity gain anti-panning."
        ],
        "link": "[More...](https://chuck.stanford.edu/doc/reference/ugens-basic.html#UGen_Stereo)"
    },
    "UnFlip": {
        "title": "**Signal Unflip**",
        "description": "Turns UAna frames into audio samples, via overlap add.",
        "constructors": [
            "**Constructors:**",
            "```chuck\nUnFlip()\n```\nDefault constructor for UnFlip."
        ],
        "examples": [
            "Examples: \t [flip.ck](https://chuck.stanford.edu/doc/examples/analysis/flip.ck)"
        ],
        "functions": [
            "**Methods:**",
            "```chuck\nvoid output(float[] buffer)\n```\nManually take pilF (as opposed to using .upchuck() / upchuck operator)",
            "```chuck\nint size(int size)\n```\nSet the pilF size.",
            "```chuck\nint size()\n```\nGet the pilF size.",
            "```chuck\nvoid transform()\n```\nManually take pilF (as opposed to using .upchuck() / upchuck operator).",
            "```chuck\nfloat[] window(float[] win)\n```\nSet/get the transform window/size.",
            "```chuck\nint windowSize()\n```\nGet the current window size."
        ],
        "link": "[More...](https://chuck.stanford.edu/doc/reference/uanae.html#UnFlip)"
    },
    "VoicForm": {
        "title": "**STK Voice Formant**",
        "description": "This instrument contains an excitation singing wavetable (looping wave with random and periodic vibrato, smoothing on frequency, etc.), excitation noise, and four sweepable complex resonances. Measured formant data is included, and enough data is there to support either parallel or cascade synthesis. In the floating point case cascade synthesis is the most natural so that's what you'll find here. Control Change Numbers: Voiced/Unvoiced Mix = 2 Vowel/Phoneme Selection = 4 Vibrato Frequency = 11 Vibrato Gain = 1 Loudness (Spectral Tilt) = 128 by Perry R. Cook and Gary P. Scavone, 1995 - 2002. Phoneme Names:   'eee' 'ihh' 'ehh' 'aaa'   'ahh' 'aww' 'ohh' 'uhh'   'uuu' 'ooo' 'rrr' 'lll'   'mmm' 'nnn' 'nng' 'ngg'   'fff' 'sss' 'thh' 'shh'   'xxx' 'hee' 'hoo' 'hah'   'bbb' 'ddd' 'jjj' 'ggg'   'vvv' 'zzz' 'thz' 'zhh'",
        "constructors": [
            "**Constructors:**",
            "```chuck\nVoicForm()\n```\nDefault constructor for VoicForm."
        ],
        "examples": [
            "Examples: \t [voic-o-form.ck](https://chuck.stanford.edu/doc/examples/stk/voic-o-form.ck)"
        ],
        "functions": [
            "**Methods:**",
            "```chuck\nfloat loudness(float value)\n```\nSet 'loudness' of voice, [0.0-1.0].",
            "```chuck\nfloat loudness()\n```\nGet 'loudness' of voice, [0.0-1.0].",
            "```chuck\nstring phoneme(string value)\n```\nSet phoneme (see above).",
            "```chuck\nstring phoneme()\n```\nGet phoneme (see above).",
            "```chuck\nint phonemeNum(int value)\n```\nSet phoneme by number, [0.0-128.0].",
            "```chuck\nint phonemeNum()\n```\nGet phoneme by number, [0.0-128.0].",
            "```chuck\nfloat pitchSweepRate(float value)\n```\nSet rate of pitch sweep, [0.0-1.0].",
            "```chuck\nfloat pitchSweepRate()\n```\nGet rate of pitch sweep, [0.0-1.0].",
            "```chuck\nfloat quiet(float value)\n```\nStop singing, [0.0-1.0].",
            "```chuck\nfloat speak(float value)\n```\nStart singing, [0.0-1.0].",
            "```chuck\nfloat unVoiced(float value)\n```\nSet mix for unvoiced component, [0.0 - 1.0].",
            "```chuck\nfloat unVoiced()\n```\nGet mix for unvoiced component, [0.0 - 1.0].",
            "```chuck\nfloat vibratoFreq(float value)\n```\nSet vibrato frequency (Hz).",
            "```chuck\nfloat vibratoFreq()\n```\nGet vibrato frequency (Hz).",
            "```chuck\nfloat vibratoGain(float value)\n```\nSet vibrato gain (Hz), [0.0-1.0].",
            "```chuck\nfloat vibratoGain()\n```\nGet vibrato gain (Hz), [0.0-1.0].",
            "```chuck\nfloat voiceMix(float value)\n```\nSet voiced/unvoiced mix, [0.0-1.0].",
            "```chuck\nfloat voiceMix()\n```\nGet voiced/unvoiced mix, [0.0-1.0].",
            "```chuck\nfloat voiced(float value)\n```\nSet mix for voiced component, [0.0 - 1.0].",
            "```chuck\nfloat voiced()\n```\nGet mix for voiced component, [0.0 - 1.0]."
        ],
        "link": "[More...](https://chuck.stanford.edu/doc/reference/ugens-stk.html#VoicForm)"
    },
    "WPDiodeLadder": {
        "title": "**WPD Diode Ladder Filter**",
        "description": "Virtual analog low pass filter based on Will Pirkle's Diode Ladder application notes.",
        "constructors": [
            "**Constructors:**",
            "```chuck\nWPDiodeLadder()\n```\n"
        ],
        "examples": [
            "Examples: \t [WPDiodeLadder.ck](https://chuck.stanford.edu/doc/examples/filter/WPDiodeLadder.ck)"
        ],
        "functions": [
            "**Methods:**",
            "```chuck\nfloat cutoff(float arg)\n```\nCuttoff is in Hz [0..Nyquist).",
            "```chuck\nfloat cutoff()\n```\nGet cuttoff frequency in Hz [0..Nyquist).",
            "```chuck\nint nlp_type(int arg)\n```\nSet to 1 to normalize non-linear output.",
            "```chuck\nint nlp_type()\n```\nGet non-linear output setting. 1 is normalized.",
            "```chuck\nint nonlinear(int arg)\n```\nEnable non linear saturator.",
            "```chuck\nint nonlinear()\n```\nGet non-linear saturator setting. 1 is enabled.",
            "```chuck\nfloat resonance(float arg)\n```\nResonance goes between [0...17].",
            "```chuck\nfloat resonance()\n```\nGet resonance [0 - 17].",
            "```chuck\nfloat saturation(float arg)\n```\nSaturation is a scalar gain, and can be used to drive the non-linearity.",
            "```chuck\nfloat saturation()\n```\nGet saturation. Saturation is a scalar gain, and can be used to drive the non-linearity."
        ],
        "link": "[More...](https://chuck.stanford.edu/doc/reference/chugins.html#WPDiodeLadder)"
    },
    "WPKorg35": {
        "title": "**WPD Korg 35 Filter**",
        "description": "Virtual analog low pass filter based on Will Pirkle's Korg35 application notes.",
        "constructors": [
            "**Constructors:**",
            "```chuck\nWPKorg35()\n```\n"
        ],
        "examples": [
            "Examples: \t [WPKorg35.ck](https://chuck.stanford.edu/doc/examples/filter/WPKorg35.ck)"
        ],
        "functions": [
            "**Methods:**",
            "```chuck\nfloat cutoff(float arg)\n```\nCuttoff is in Hz [0..Nyquist).",
            "```chuck\nfloat cutoff()\n```\nGet cutoff in Hz [0..Nyquist).",
            "```chuck\nint nonlinear(int arg)\n```\nEnable non linear saturator.",
            "```chuck\nint nonlinear()\n```\nGet non-linear saturator setting. 1 is enabled.",
            "```chuck\nfloat resonance(float arg)\n```\nResonance goes between [0...2).",
            "```chuck\nfloat resonance()\n```\nGet resonance [0 - 2).",
            "```chuck\nfloat saturation(float arg)\n```\nSaturation is a scalar gain, and can be used to drive the non-linearity.",
            "```chuck\nfloat saturation()\n```\nGet saturation. Saturation is a scalar gain, and can be used to drive the non-linearity."
        ],
        "link": "[More...](https://chuck.stanford.edu/doc/reference/chugins.html#WPKorg35)"
    },
    "WarpTable": {
        "title": "**Warp Table**",
        "description": "An end-constrained mapping table, mostly useful for conditioning control signals.",
        "constructors": [
            "**Constructors:**",
            "```chuck\nWarpTable()\n```\nDefault constructor for WarpTable."
        ],
        "examples": [
            "Examples: \t [GenX-WarpTable-test.ck](https://chuck.stanford.edu/doc/examples/special/GenX-WarpTable-test.ck)"
        ],
        "functions": [
            "**Methods:**",
            "```chuck\nfloat[] coefs(float[] v)\n```\nSet lookup table coefficients."
        ],
        "link": "[More...](https://chuck.stanford.edu/doc/reference/ugens-advanced.html#WarpTable)"
    },
    "WaveLoop": {
        "title": "**Audio File Looping**",
        "description": "This class inherits from WvIn and provides audio file looping functionality. WaveLoop supports multi-channel data in interleaved format. It is important to distinguish the `tick()` methods, which return samples produced by averaging across sample frames, from the `tickFrame()` methods, which return pointers to multi-channel sample frames. For single-channel data, these methods return equivalent values. by Perry R. Cook and Gary P. Scavone, 1995 - 2002.",
        "constructors": [
            "**Constructors:**",
            "```chuck\nWaveLoop()\n```\nDefault constructor for WaveLoop."
        ],
        "examples": [],
        "functions": [
            "**Methods:**",
            "```chuck\nfloat addPhase(float value)\n```\nSet offset by phase.",
            "```chuck\nfloat addPhase()\n```\nGet offset by phase.",
            "```chuck\nfloat addPhaseOffset(float value)\n```\nSet phase offset.",
            "```chuck\nfloat addPhaseOffset()\n```\nGet phase offset.",
            "```chuck\nfloat freq(float value)\n```\nSet frequency of playback (loops/second).",
            "```chuck\nfloat freq()\n```\nGet frequency of playback (loops/second)."
        ],
        "link": "[More...](https://chuck.stanford.edu/doc/reference/ugens-stk.html#WaveLoop)"
    },
    "Wekinator": {
        "title": "**Wekinator**",
        "description": "A Wekinator utility that maps input vectors to output vectors, commonly used for interactive machine learning combining human-computer interaction and ML. Based on Rebecca Fiebrink's Wekinator framework.",
        "constructors": [
            "**Constructors:**",
            "```chuck\nWekinator()\n```\nDefault constructor for Wekinator."
        ],
        "examples": [
            "Examples: \t [wekinator-basic.ck](https://chuck.stanford.edu/doc/examples/ai/wekinator/wekinator-basic.ck), [wekinator-customize.ck](https://chuck.stanford.edu/doc/examples/ai/wekinator/wekinator-customize.ck), [wekinator-import.ck](https://chuck.stanford.edu/doc/examples/ai/wekinator/wekinator-import.ck)"
        ],
        "functions": [
            "**Methods:**",
            "```chuck\nvoid add()\n```\nAdd current inputs and outputs to the observations.",
            "```chuck\nvoid add(float[] inputs, float[] outputs)\n```\nAdd given inputs and outputs to the observations.",
            "```chuck\nvoid add(int output_index, float[] inputs, float[] outputs)\n```\nAdd given inputs and outputs to the observations for the specified output.",
            "```chuck\nvoid clear()\n```\nClear everything except the global properties.",
            "```chuck\nvoid clearAllObs()\n```\nClear all observations.",
            "```chuck\nvoid clearAllObs(int output_index)\n```\nClear all observations for the specified output.",
            "```chuck\nvoid clearObs(int lo, int hi)\n```\nClear the observations by id range.",
            "```chuck\nvoid clearObs(int output_index, int lo, int hi)\n```\nClear the observations by id range for the specified output.",
            "```chuck\nvoid deleteLastRound()\n```\nDelete the last round of observations.",
            "```chuck\nvoid exportObs(string filename)\n```\nExport the observations to a file.",
            "```chuck\nvoid exportObs(int output_index, string filename)\n```\nExport the observations for the specified output to a file.",
            "```chuck\nint getAllRecordStatus()\n```\nGet the record status for all outputs.",
            "```chuck\nint getAllRunStatus()\n```\nGet the run status for all outputs.",
            "```chuck\nvoid getObs(float[][] obs)\n```\nGet the observations in the Wekinator.",
            "```chuck\nvoid getObs(int output_index, float[][] obs)\n```\nGet the observations for the specified output in the Wekinator.",
            "```chuck\nvoid getOutputProperty(int output_index, string property_name, int[] property_value)\n```\nGet the output property of the Wekinator. See the Wekinator documentation for more information.",
            "```chuck\nfloat getOutputPropertyFloat(int output_index, int property_type, string property_name)\n```\nGet the output property of the Wekinator. See the Wekinator documentation for more information.",
            "```chuck\nint getOutputPropertyInt(int output_index, string property_name)\n```\nGet the output property of the Wekinator. See the Wekinator documentation for more information.",
            "```chuck\nint getOutputPropertyInt(int output_index, int property_type, string property_name)\n```\nGet the output property of the Wekinator. See the Wekinator documentation for more information.",
            "```chuck\nint getOutputRecordStatus(int output_index)\n```\nGet the record status for the specified output.",
            "```chuck\nint getOutputRunStatus(int output_index)\n```\nGet the run status for the specified output.",
            "```chuck\nfloat getPropertyFloat(int property_type, string property_name)\n```\nGet the property of the Wekinator. See the Wekinator documentation for more information.",
            "```chuck\nint getPropertyInt(int property_type, string property_name)\n```\nGet the property of the Wekinator. See the Wekinator documentation for more information.",
            "```chuck\nint getRound()\n```\nGet the current recording round.",
            "```chuck\nvoid importObs(string filename)\n```\nImport the observations from a file.",
            "```chuck\nvoid input(float[] inputs)\n```\nSet the inputs of the Wekinator.",
            "```chuck\nint inputDims(int n)\n```\nSet the number of input dimensions to Wekinator.",
            "```chuck\nint inputDims()\n```\nGet the number of input dimensions to Wekinator.",
            "```chuck\nvoid load(string filename)\n```\nLoad the Wekinator from a file.",
            "```chuck\nint modelType(int model_type)\n```\nSet the model type of the Wekinator. Options: AI.Regression: AI.MLP, AI.LR, AI.Classification: AI.KNN, AI.SVM, AI.DT.",
            "```chuck\nint modelType()\n```\nGet the model type id of the Wekinator.",
            "```chuck\nstring modelTypeName()\n```\nGet the model type name of the Wekinator.",
            "```chuck\nvoid nextRound()\n```\nBump the recording round.",
            "```chuck\nint numObs()\n```\nGet the number of observations in the Wekinator.",
            "```chuck\nint numObs(int output_index)\n```\nGet the number of observations for the specified output in the Wekinator.",
            "```chuck\nvoid output(float[] outputs)\n```\nSet the outputs of the Wekinator.",
            "```chuck\nint outputDims(int n)\n```\nSet the number of output dimensions to Wekinator.",
            "```chuck\nint outputDims()\n```\nGet the number of output dimensions to Wekinator.",
            "```chuck\nvoid predict(float[] inputs, float[] outputs)\n```\nPredict outputs for the given inputs.",
            "```chuck\nvoid randomizeOutputs()\n```\nRandomize the outputs of the Wekinator.",
            "```chuck\nvoid save(string filename)\n```\nSave the Wekinator to a file.",
            "```chuck\nvoid setAllRecordStatus(int status)\n```\nSet the record status for all outputs.",
            "```chuck\nvoid setAllRunStatus(int status)\n```\nSet the run status for all outputs.",
            "```chuck\nvoid setOutputProperty(int output_index, string property_name, int property_value)\n```\nSet the output property of the Wekinator. See the Wekinator documentation for more information.",
            "```chuck\nvoid setOutputProperty(int output_index, int property_type, string property_name, int property_value)\n```\nSet the output property of the Wekinator. See the Wekinator documentation for more information.",
            "```chuck\nvoid setOutputProperty(int output_index, int property_type, string property_name, float property_value)\n```\nSet the output property of the Wekinator. See the Wekinator documentation for more information.",
            "```chuck\nvoid setOutputProperty(int output_index, string property_name, int[] property_value)\n```\nSet the output property of the Wekinator. See the Wekinator documentation for more information.",
            "```chuck\nvoid setOutputRecordStatus(int output_index, int status)\n```\nSet the record status for the specified output.",
            "```chuck\nvoid setOutputRunStatus(int output_index, int status)\n```\nSet the run status for the specified output.",
            "```chuck\nvoid setProperty(int property_type, string property_name, int property_value)\n```\nSet the property of the Wekinator. See the Wekinator documentation for more information.",
            "```chuck\nvoid setProperty(int property_type, string property_name, float property_value)\n```\nSet the property of the Wekinator. See the Wekinator documentation for more information.",
            "```chuck\nint taskType(int task_type)\n```\nSet the task type of the Wekinator. Options: AI.Regression, AI.Classification.",
            "```chuck\nint taskType()\n```\nGet the task type id of the Wekinator.",
            "```chuck\nstring taskTypeName()\n```\nGet the task type name of the Wekinator.",
            "```chuck\nvoid train()\n```\nTrain models for all outputs."
        ],
        "link": "[More...](https://chuck.stanford.edu/doc/reference/ai.html#Wekinator)"
    },
    "WinFuncEnv": {
        "title": "**Window Function Envelope**",
        "description": "WinFunEnv is an Attack/Release envelope built around window functions!",
        "constructors": [
            "**Constructors:**",
            "```chuck\nWinFuncEnv()\n```\n"
        ],
        "examples": [
            "Examples: \t [WinFuncEnv.ck](https://chuck.stanford.edu/doc/examples/effects/WinFuncEnv.ck)"
        ],
        "functions": [
            "**Methods:**",
            "```chuck\ndur attackTime(dur attackDuration)\n```\nSet duration of the attack phase.",
            "```chuck\nint keyOff()\n```\nStart release phase.",
            "```chuck\nint keyOff(int keyOff)\n```\nStart release phase.",
            "```chuck\nint keyOn()\n```\nStart attack phase.",
            "```chuck\nint keyOn(int keyOn)\n```\nStart attack phase.",
            "```chuck\ndur releaseTime(dur releaseDuration)\n```\nSet duration of the release phase.",
            "```chuck\nvoid setBlackman()\n```\nSet Blackman Window Envelope with default value (0.16).",
            "```chuck\nvoid setBlackman(float a)\n```\nSet Blackman Window Envelope with a custom value.",
            "```chuck\nvoid setBlackmanDerivative(float a0, float a1, float a2, float a3)\n```\nSet a custom Blackman Derivative Envelope with custom values.",
            "```chuck\nvoid setBlackmanHarris()\n```\nSet BlackmanHarris Window Envelope.",
            "```chuck\nvoid setBlackmanNutall()\n```\nSet BlackmanNutall Window Envelope.",
            "```chuck\nvoid setExponential()\n```\nSet Exponential Function Envelope with default value (8.69/60.0).",
            "```chuck\nvoid setExponential(float a)\n```\nSet Exponential Function Envleope with a custom value.",
            "```chuck\nvoid setHann()\n```\nSet Hann (Hanning) Window Envelope.",
            "```chuck\nvoid setHannPoisson()\n```\nSet Hann-Poisson Window Envelope with default value (0.5).",
            "```chuck\nvoid setHannPoisson(float a)\n```\nSet Hann-Poisson Window Envelope with a custom value.",
            "```chuck\nvoid setNutall()\n```\nSet Nutall Window Envelope.",
            "```chuck\nvoid setParzen()\n```\nSet Parzen Window Envelope.",
            "```chuck\nvoid setPoisson()\n```\nSet Poisson Window Envelope with default value (6.0).",
            "```chuck\nvoid setPoisson(float a)\n```\nSet Poisson Window Envelope with a custom value.",
            "```chuck\nvoid setSigmoid()\n```\nSet Sigmoid Window Envelope with default value (2.0).",
            "```chuck\nvoid setSigmoid(float k)\n```\nSet Sigmoid Window Envelope with a custom value.",
            "```chuck\nvoid setTukey()\n```\nSet Tukey Window Envelope with default value (0.5).",
            "```chuck\nvoid setTukey(float a)\n```\nSet Tukey Window Envelope with a custom value.",
            "```chuck\nvoid setWelch()\n```\nSet Welch Window Window.",
            "```chuck\nfloat windowValue()\n```\nGet current window value."
        ],
        "link": "[More...](https://chuck.stanford.edu/doc/reference/chugins.html#WinFuncEnv)"
    },
    "Windowing": {
        "title": "**Windowing Function**",
        "description": "",
        "constructors": [],
        "examples": [
            "Examples: \t [win.ck](https://chuck.stanford.edu/doc/examples/analysis/win.ck), [xsynth.ck](https://chuck.stanford.edu/doc/examples/analysis/xsynth.ck), [pitch-track.ck](https://chuck.stanford.edu/doc/examples/analysis/tracking/pitch-track.ck), [rolloff2.ck](https://chuck.stanford.edu/doc/examples/ai/features/rolloff2.ck), [win.ck](https://chuck.stanford.edu/doc/examples/analysis/win.ck), [feature-extract.ck](https://chuck.stanford.edu/doc/examples/ai/genre-classify/feature-extract.ck), [genre-classify.ck](https://chuck.stanford.edu/doc/examples/ai/genre-classify/genre-classify.ck)"
        ],
        "functions": [
            "**Methods:**",
            "```chuck\nfloat[] blackmanHarris(int size)\n```\n",
            "```chuck\nfloat[] hamming(int size)\n```\n",
            "```chuck\nfloat[] hann(int size)\n```\n",
            "```chuck\nfloat[] rectangle(int size)\n```\n",
            "```chuck\nfloat[] triangle(int size)\n```\n"
        ],
        "link": "[More...](https://chuck.stanford.edu/doc/reference/uanae.html#Windowing)"
    },
    "Word2Vec": {
        "title": "**Word2Vec**",
        "description": "A word embeddings utility that maps words to vectors; can load a model and perform similarity retrieval.",
        "constructors": [
            "**Constructors:**",
            "```chuck\nWord2Vec()\n```\nDefault constructor for Word2Vec."
        ],
        "examples": [
            "Examples: \t [word2vec-basic.ck](https://chuck.stanford.edu/doc/examples/ai/word2vec/word2vec-basic.ck), [poem-i-feel.ck](https://chuck.stanford.edu/doc/examples/ai/word2vec/poem-i-feel.ck), [poem-randomwalk.ck](https://chuck.stanford.edu/doc/examples/ai/word2vec/poem-randomwalk.ck), [poem-spew.ck](https://chuck.stanford.edu/doc/examples/ai/word2vec/poem-spew.ck), [poem-ungenerate.ck](https://chuck.stanford.edu/doc/examples/ai/word2vec/poem-ungenerate.ck), [word2vec-prompt.ck](https://chuck.stanford.edu/doc/examples/ai/word2vec/word2vec-prompt.ck)"
        ],
        "functions": [
            "**Methods:**",
            "```chuck\nint contains(string word)\n```\nQuery if 'word' is in the current model.",
            "```chuck\nint dim()\n```\nGet number of dimensions for word embedding.",
            "```chuck\nint getSimilar(string word, int k, string[] output)\n```\nGet the k most similar words to the given word; return false if 'word' is not in model.",
            "```chuck\nint getSimilar(float[] vec, int k, string[] output)\n```\nGet the k most similar words to the given vector.",
            "```chuck\nint getVector(string word, float[] output)\n```\nGet the vector of the given word; returns false if 'word' is not in model.",
            "```chuck\nint load(string path)\n```\nLoad pre-trained word embedding model from the given path.",
            "```chuck\nint load(string path, int useKDTreeDim)\n```\nLoad pre-trained word embedding model from the given path; will use KDTree for similarity searches if the data dimension is less than or equal to 'useKDTreeDim'. Set 'useKDTreeDim' to 0 to use linear (brute force) similarity search; set 'useKDTreeDim' to less than 0 to always use KDTree.",
            "```chuck\nvoid minMax(float[] mins, float[] maxs)\n```\nRetrieve the minimums and maximums for each dimension.",
            "```chuck\nint size()\n```\nGet number of words in dictionary.",
            "```chuck\nint useKDTree()\n```\nGet whether a KDTree is used for similarity search."
        ],
        "link": "[More...](https://chuck.stanford.edu/doc/reference/ai.html#Word2Vec)"
    },
    "Wurley": {
        "title": "**STK Wurlitzer**",
        "description": "STK Wurlitzer electric piano FM synthesis instrument. This class implements two simple FM Pairs summed together, also referred to as algorithm 5 of the TX81Z. Algorithm 5 is : 4->3-- + --> Out 2->1-- Control Change Numbers: - Modulator Index One = 2 (.controlOne) - Crossfade of Outputs = 4 (.controlTwo) - LFO Speed = 11 - LFO Depth = 1 - ADSR 2 & 4 Target = 128 The basic Chowning/Stanford FM patent expired in 1995, but there exist follow-on patents, mostly assigned to Yamaha. If you are of the type who should worry about this (making money) worry away. by Perry R. Cook and Gary P. Scavone, 1995 - 2002.",
        "constructors": [
            "**Constructors:**",
            "```chuck\nWurley()\n```\nDefault constructor for Wurley."
        ],
        "examples": [
            "Examples: \t [wurley.ck](https://chuck.stanford.edu/doc/examples/stk/wurley.ck), [wurley2.ck](https://chuck.stanford.edu/doc/examples/stk/wurley2.ck), [wurley3.ck](https://chuck.stanford.edu/doc/examples/stk/wurley3.ck)"
        ],
        "functions": [],
        "link": "[More...](https://chuck.stanford.edu/doc/reference/ugens-stk.html#Wurley)"
    },
    "WvIn": {
        "title": "**Audio File Input**",
        "description": "This class provides input support for various audio file formats. It also serves as a base class for 'realtime' streaming subclasses. WvIn loads the contents of an audio file for subsequent output. Linear interpolation is used for fractional 'read rates'. WvIn supports multi-channel data in interleaved format. It is important to distinguish the `tick()` methods, which return samples produced by averaging across sample frames, from the `tickFrame()` methods, which return pointers to multi-channel sample frames. For single-channel data, these methods return equivalent values. Small files are completely read into local memory during instantiation. Large files are read incrementally from disk. The file size threshold and the increment size values are defined in WvIn.h. WvIn currently supports WAV, AIFF, SND (AU), MAT-file (Matlab), and STK RAW file formats. Signed integer (8-, 16-, and 32-bit) and floating-point (32- and 64-bit) data types are supported. Uncompressed data types are not supported. If using MAT-files, data should be saved in an array with each data channel filling a matrix row. by Perry R. Cook and Gary P. Scavone, 1995 - 2002.",
        "constructors": [
            "**Constructors:**",
            "```chuck\nWvIn()\n```\nDefault constructor for WvIn."
        ],
        "examples": [],
        "functions": [
            "**Methods:**",
            "```chuck\nstring path(string value)\n```\nSet file to be played.",
            "```chuck\nstring path()\n```\nGet file to be played.",
            "```chuck\nfloat rate(float value)\n```\nSet playback rate.",
            "```chuck\nfloat rate()\n```\nGet playback rate."
        ],
        "link": "[More...](https://chuck.stanford.edu/doc/reference/ugens-stk.html#WvIn)"
    },
    "WvOut": {
        "title": "**Audio File Output**",
        "description": "This class provides output support for various audio file formats. It also serves as a base class for 'realtime' streaming subclasses. WvOut writes samples to an audio file. It supports multi-channel data in interleaved format. It is important to distinguish the `tick()` methods, which output single samples to all channels in a sample frame, from the `tickFrame()` method, which takes a pointer to multi-channel sample frame data. WvOut currently supports WAV, AIFF, AIFC, SND (AU), MAT-file (Matlab), and STK RAW file formats. Signed integer (8-, 16-, and 32-bit) and floating- point (32- and 64-bit) data types are supported. STK RAW files use 16-bit integers by definition. MAT-files will always be written as 64-bit floats. If a data type specification does not match the specified file type, the data type will automatically be modified. Uncompressed data types are not supported. Currently, WvOut is non-interpolating and the output rate is always `Stk::sampleRate()`. by Perry R. Cook and Gary P. Scavone, 1995 - 2002.",
        "constructors": [
            "**Constructors:**",
            "```chuck\nWvOut()\n```\nDefault constructor for WvOut."
        ],
        "examples": [
            "Examples: \t [rec.ck](https://chuck.stanford.edu/doc/examples/basic/rec.ck), [rec-auto.ck](https://chuck.stanford.edu/doc/examples/basic/rec-auto.ck), [rec-auto-stereo.ck](https://chuck.stanford.edu/doc/examples/basic/rec-auto-stereo.ck), [wvout-24bit.ck](https://chuck.stanford.edu/doc/examples/stk/wvout-24bit.ck)"
        ],
        "functions": [
            "**Methods:**",
            "```chuck\nstring aifFilename(string value)\n```\nOpen an AIFF file for writing (with default datatype IO.INT16).",
            "```chuck\nstring aifFilename(string value, int datatype)\n```\nOpen an AIFF file for writing, with datatype (e.g., IO.INT16, IO.INT24, IO.INT32, IO.FLOAT32, IO.FLOAT64).",
            "```chuck\nstring autoPrefix(string value)\n```\nSet auto prefix string for \"special:auto\" filename generation.",
            "```chuck\nstring autoPrefix()\n```\nGet auto prefix string for \"special:auto\" filename generation.",
            "```chuck\nstring closeFile(string value)\n```\nClose the file properly.",
            "```chuck\nstring closeFile()\n```\nClose the file properly.",
            "```chuck\nfloat fileGain(float value)\n```\nSet file gain.",
            "```chuck\nfloat fileGain()\n```\nGet file gain.",
            "```chuck\nstring filename()\n```\nGet filename.",
            "```chuck\nstring matFilename(string value)\n```\nOpen MATLAB file for writing (with default datatype IO.FLOAT64).",
            "```chuck\nstring matFilename(string value, int datatype)\n```\nOpen MATLAB file for writing; datatype for MATLAB files can only be IO.FLOAT64.",
            "```chuck\nstring rawFilename(string value)\n```\nOpen a RAW file for writing (note: raw audio files are mono and 16-bit).",
            "```chuck\nstring rawFilename(string value, int datatype)\n```\nOpen a RAW file for writing; datatype for raw files can only be IO.INT16.",
            "```chuck\nint record(int value)\n```\nStart/stop output.",
            "```chuck\nint record()\n```\nStart/stop output.",
            "```chuck\nstring sndFilename(string value)\n```\nOpen SND file for writing (with default datatype IO.INT16).",
            "```chuck\nstring sndFilename(string value, int datatype)\n```\nOpen SND file for writing, with datatype (e.g., IO.INT16, IO.INT24, IO.INT32, IO.FLOAT32, IO.FLOAT64).",
            "```chuck\nstring wavFilename(string value)\n```\nOpen WAVE file for writing (with default datatype IO.INT16).",
            "```chuck\nstring wavFilename(string value, int datatype)\n```\nOpen WAVE file for writing, with datatype (e.g., IO.INT16, IO.INT24, IO.INT32, IO.FLOAT32, IO.FLOAT64)."
        ],
        "link": "[More...](https://chuck.stanford.edu/doc/reference/ugens-stk.html#WvOut)"
    },
    "WvOut2": {
        "title": "**Audio File Output (Stereo)**",
        "description": "WvOut2 is the stereo version of WvOut; opens and writes a 2-channel audio file; see WvOut for usage.",
        "constructors": [
            "**Constructors:**",
            "```chuck\nWvOut2()\n```\nDefault constructor for WvOut2."
        ],
        "examples": [
            "Examples: \t [rec.ck](https://chuck.stanford.edu/doc/examples/basic/rec.ck), [rec-auto.ck](https://chuck.stanford.edu/doc/examples/basic/rec-auto.ck), [rec-auto-stereo.ck](https://chuck.stanford.edu/doc/examples/basic/rec-auto-stereo.ck), [wvout-24bit.ck](https://chuck.stanford.edu/doc/examples/stk/wvout-24bit.ck)"
        ],
        "functions": [],
        "link": "[More...](https://chuck.stanford.edu/doc/reference/ugens-stk.html#WvOut2)"
    },
    "XCorr": {
        "title": "**Cross Correlation**",
        "description": "A unit analyzer that computes cross-correlation between two incoming analysis frames.",
        "constructors": [
            "**Constructors:**",
            "```chuck\nXCorr()\n```\nDefault constructor for XCorr."
        ],
        "examples": [
            "Examples: \t [xcorr.ck](https://chuck.stanford.edu/doc/examples/analysis/xcorr.ck)"
        ],
        "functions": [
            "**Methods:**",
            "```chuck\nint normalize(int flag)\n```\n",
            "```chuck\nint normalize()\n```\n",
            "```chuck\nfloat[] compute(float[] f, float[] g, int normalize, float[] y)\n```\n"
        ],
        "link": "[More...](https://chuck.stanford.edu/doc/reference/uanae.html#XCorr)"
    },
    "ZeroX": {
        "title": "**Zero Crossing Detector**",
        "description": "Zero crossing detector.",
        "constructors": [
            "**Constructors:**",
            "```chuck\nZeroX()\n```\nDefault constructor for ZeroX."
        ],
        "examples": [
            "Examples: \t [zerox.ck](https://chuck.stanford.edu/doc/examples/ai/features/zerox.ck)"
        ],
        "functions": [
            "**Methods:**",
            "```chuck\nfloat compute(float[] input)\n```\nManually computes the zero crossing rate for an array."
        ],
        "link": "[More...](https://chuck.stanford.edu/doc/reference/uanae.html#ZeroX)"
    },
    "string": {
        "title": "**String Class**",
        "description": "Textual data as a sequence of characters, along with functions for manipulating text.",
        "constructors": [
            "**Constructors:**",
            "```chuck\nstring()\n```\nDefault constructor for string.",
            "```chuck\nstring(string str)\n```\nConstruct a string as a copy of another string."
        ],
        "examples": [
            "Examples: \t [strops.ck](https://chuck.stanford.edu/doc/examples/string/strops.ck), [strops2.ck](https://chuck.stanford.edu/doc/examples/string/strops2.ck), [replace.ck](https://chuck.stanford.edu/doc/examples/string/replace.ck), [token.ck](https://chuck.stanford.edu/doc/examples/string/token.ck), [escape.ck](https://chuck.stanford.edu/doc/examples/string/escape.ck), [tostr.ck](https://chuck.stanford.edu/doc/examples/string/tostr.ck)"
        ],
        "functions": [
            "**Methods:**",
            "```chuck\nint charAt(int index)\n```\nGet a character at the specified index.",
            "```chuck\nvoid erase(int start, int length)\n```\nErase length characters of the string from start position.",
            "```chuck\nint find(int theChar)\n```\nGet the index of the first occurrence of theChar, or -1 if theChar is not found.",
            "```chuck\nint find(int theChar, int start)\n```\nGet the index of the first occurrence of theChar at or after the start position, or -1 if theChar is not found.",
            "```chuck\nint find(string str)\n```\nGet the index of the first occurrence of str, or -1 if str is not found.",
            "```chuck\nint find(string str, int start)\n```\nGet the index of the first occurrence of str at or after the start position, or -1 if str is not found.",
            "```chuck\nvoid insert(int position, string str)\n```\nInsert a string at the specified position.",
            "```chuck\nint length()\n```\nGet the number of characters of the string.",
            "```chuck\nstring lower()\n```\nGet a new string in which the uppercase characters of the original string have been converted to lowercase.",
            "```chuck\nstring ltrim()\n```\nGet a new string in which leading whitespace has been removed.",
            "```chuck\nvoid replace(int position, string str)\n```\nReplace characters from 'position' with contents of 'str'.",
            "```chuck\nvoid replace(int position, int length, string str)\n```\nReplace 'length' characters from 'position' with contents of 'str'.",
            "```chuck\nvoid replace(string from, string to)\n```\nReplace all instances of 'from' in the string with 'to'.",
            "```chuck\nint rfind(int theChar)\n```\nGet the index of the last occurrence of theChar, or -1 if theChar is not found.",
            "```chuck\nint rfind(int theChar, int start)\n```\nGet the index of the last occurrence of theChar at or before the start position, or -1 if theChar is not found.",
            "```chuck\nint rfind(string str)\n```\nGet the index of the last occurrence of str, or -1 if str is not found.",
            "```chuck\nint rfind(string str, int start)\n```\nGet the index of the last occurrence of str at or before the start position, or -1 if str is not found.",
            "```chuck\nstring rtrim()\n```\nGet a new string in which trailing whitespace has been removed.",
            "```chuck\nint setCharAt(int index, int theChar)\n```\nSet the character at the specified index.",
            "```chuck\nstring substring(int start)\n```\nGet a new string containing the substring from the start index to the end of the string.",
            "```chuck\nstring substring(int start, int length)\n```\nGet a new string containing the substring from the start index of the specified length.",
            "```chuck\nfloat toFloat()\n```\nAttempt to convert the contents of the string to an float and return the result, or 0 if conversion failed.",
            "```chuck\nint toInt()\n```\nAttempt to convert the contents of the string to an integer and return the result, or 0 if conversion failed.",
            "```chuck\nstring toString()\n```\nReturn the reference of calling string.",
            "```chuck\nstring trim()\n```\nGet a new string in which leading and trailing whitespace has been removed.",
            "```chuck\nstring upper()\n```\nGet a new string in which the lowercase characters of the original string have been converted to uppercase."
        ],
        "link": "[More...](https://chuck.stanford.edu/doc/reference/base.html#string)"
    }
}